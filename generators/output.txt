package commands
type AlarmGet struct {
    node byte
    AlarmType byte
}

func (c *AlarmGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AlarmGet) Set(AlarmType byte,) error {
    c.AlarmType = AlarmType
}

func (c *AlarmGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Alarm),
        0x04,
        AlarmType,
        0x25,
    }
}
type AlarmReport struct {
    *report
    node byte
    AlarmType byte
    AlarmLevel byte
    data []byte
}

func NewAlarmReport(data []byte) *AlarmReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &AlarmReport{
        AlarmType: data[0],
        AlarmLevel: data[1],
        data: data,
    }
}

package commands
type AlarmGetV2 struct {
    node byte
    AlarmType byte
    ZWaveAlarmType byte
}

func (c *AlarmGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AlarmGetV2) Set(AlarmType byte,ZWaveAlarmType byte,) error {
    c.AlarmType = AlarmType
    c.ZWaveAlarmType = ZWaveAlarmType
}

func (c *AlarmGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AlarmV2),
        0x04,
        AlarmType,
        ZWaveAlarmType,
        0x25,
    }
}
type AlarmReportV2 struct {
    *report
    node byte
    AlarmType byte
    AlarmLevel byte
    ZensorNetSourceNodeID byte
    ZWaveAlarmStatus byte
    ZWaveAlarmType byte
    ZWaveAlarmEvent byte
    NumberofEventParameters byte
    EventParameter byte
    data []byte
}

func NewAlarmReportV2(data []byte) *AlarmReportV2 {
    if len(data) < 8 {
        for i := len(data); i < 8; i++ {
            data = append(data, 0x00)
        }
    }

    return &AlarmReportV2{
        AlarmType: data[0],
        AlarmLevel: data[1],
        ZensorNetSourceNodeID: data[2],
        ZWaveAlarmStatus: data[3],
        ZWaveAlarmType: data[4],
        ZWaveAlarmEvent: data[5],
        NumberofEventParameters: data[6],
        EventParameter: data[7],
        data: data,
    }
}

type AlarmSetV2 struct {
    node byte
    ZWaveAlarmType byte
    ZWaveAlarmStatus byte
}

func (c *AlarmSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AlarmSetV2) Set(ZWaveAlarmType byte,ZWaveAlarmStatus byte,) error {
    c.ZWaveAlarmType = ZWaveAlarmType
    c.ZWaveAlarmStatus = ZWaveAlarmStatus
}

func (c *AlarmSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AlarmV2),
        0x06,
        ZWaveAlarmType,
        ZWaveAlarmStatus,
        0x25,
    }
}
type AlarmTypeSupportedGetV2 struct {
    node byte
}

func (c *AlarmTypeSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AlarmTypeSupportedGetV2) Set() error {
}

func (c *AlarmTypeSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AlarmV2),
        0x07,
        0x25,
    }
}
type AlarmTypeSupportedReportV2 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewAlarmTypeSupportedReportV2(data []byte) *AlarmTypeSupportedReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &AlarmTypeSupportedReportV2{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

package commands
type NotificationGetV3 struct {
    node byte
    V1AlarmType byte
    NotificationType byte
    Event byte
}

func (c *NotificationGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationGetV3) Set(V1AlarmType byte,NotificationType byte,Event byte,) error {
    c.V1AlarmType = V1AlarmType
    c.NotificationType = NotificationType
    c.Event = Event
}

func (c *NotificationGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NotificationV3),
        0x04,
        V1AlarmType,
        NotificationType,
        Event,
        0x25,
    }
}
type NotificationReportV3 struct {
    *report
    node byte
    V1AlarmType byte
    V1AlarmLevel byte
    Reserved byte
    NotificationStatus byte
    NotificationType byte
    Event byte
    Properties1 byte
    EventParameter byte
    SequenceNumber byte
    data []byte
}

func NewNotificationReportV3(data []byte) *NotificationReportV3 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationReportV3{
        V1AlarmType: data[0],
        V1AlarmLevel: data[1],
        Reserved: data[2],
        NotificationStatus: data[3],
        NotificationType: data[4],
        Event: data[5],
        Properties1: data[6],
        EventParameter: data[7],
        SequenceNumber: data[8],
        data: data,
    }
}

type NotificationSetV3 struct {
    node byte
    NotificationType byte
    NotificationStatus byte
}

func (c *NotificationSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSetV3) Set(NotificationType byte,NotificationStatus byte,) error {
    c.NotificationType = NotificationType
    c.NotificationStatus = NotificationStatus
}

func (c *NotificationSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NotificationV3),
        0x06,
        NotificationType,
        NotificationStatus,
        0x25,
    }
}
type NotificationSupportedGetV3 struct {
    node byte
}

func (c *NotificationSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSupportedGetV3) Set() error {
}

func (c *NotificationSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NotificationV3),
        0x07,
        0x25,
    }
}
type NotificationSupportedReportV3 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewNotificationSupportedReportV3(data []byte) *NotificationSupportedReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationSupportedReportV3{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type EventSupportedGetV3 struct {
    node byte
    NotificationType byte
}

func (c *EventSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *EventSupportedGetV3) Set(NotificationType byte,) error {
    c.NotificationType = NotificationType
}

func (c *EventSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NotificationV3),
        0x01,
        NotificationType,
        0x25,
    }
}
type EventSupportedReportV3 struct {
    *report
    node byte
    NotificationType byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewEventSupportedReportV3(data []byte) *EventSupportedReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EventSupportedReportV3{
        NotificationType: data[0],
        Properties1: data[1],
        BitMask: data[2],
        data: data,
    }
}

package commands
type NotificationGetV4 struct {
    node byte
    V1AlarmType byte
    NotificationType byte
    Event byte
}

func (c *NotificationGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationGetV4) Set(V1AlarmType byte,NotificationType byte,Event byte,) error {
    c.V1AlarmType = V1AlarmType
    c.NotificationType = NotificationType
    c.Event = Event
}

func (c *NotificationGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NotificationV4),
        0x04,
        V1AlarmType,
        NotificationType,
        Event,
        0x25,
    }
}
type NotificationReportV4 struct {
    *report
    node byte
    V1AlarmType byte
    V1AlarmLevel byte
    Reserved byte
    NotificationStatus byte
    NotificationType byte
    Event byte
    Properties1 byte
    EventParameter byte
    SequenceNumber byte
    data []byte
}

func NewNotificationReportV4(data []byte) *NotificationReportV4 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationReportV4{
        V1AlarmType: data[0],
        V1AlarmLevel: data[1],
        Reserved: data[2],
        NotificationStatus: data[3],
        NotificationType: data[4],
        Event: data[5],
        Properties1: data[6],
        EventParameter: data[7],
        SequenceNumber: data[8],
        data: data,
    }
}

type NotificationSetV4 struct {
    node byte
    NotificationType byte
    NotificationStatus byte
}

func (c *NotificationSetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSetV4) Set(NotificationType byte,NotificationStatus byte,) error {
    c.NotificationType = NotificationType
    c.NotificationStatus = NotificationStatus
}

func (c *NotificationSetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NotificationV4),
        0x06,
        NotificationType,
        NotificationStatus,
        0x25,
    }
}
type NotificationSupportedGetV4 struct {
    node byte
}

func (c *NotificationSupportedGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSupportedGetV4) Set() error {
}

func (c *NotificationSupportedGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NotificationV4),
        0x07,
        0x25,
    }
}
type NotificationSupportedReportV4 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewNotificationSupportedReportV4(data []byte) *NotificationSupportedReportV4 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationSupportedReportV4{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type EventSupportedGetV4 struct {
    node byte
    NotificationType byte
}

func (c *EventSupportedGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *EventSupportedGetV4) Set(NotificationType byte,) error {
    c.NotificationType = NotificationType
}

func (c *EventSupportedGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NotificationV4),
        0x01,
        NotificationType,
        0x25,
    }
}
type EventSupportedReportV4 struct {
    *report
    node byte
    NotificationType byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewEventSupportedReportV4(data []byte) *EventSupportedReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EventSupportedReportV4{
        NotificationType: data[0],
        Properties1: data[1],
        BitMask: data[2],
        data: data,
    }
}

package commands
type NotificationGetV5 struct {
    node byte
    V1AlarmType byte
    NotificationType byte
    Event byte
}

func (c *NotificationGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationGetV5) Set(V1AlarmType byte,NotificationType byte,Event byte,) error {
    c.V1AlarmType = V1AlarmType
    c.NotificationType = NotificationType
    c.Event = Event
}

func (c *NotificationGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NotificationV5),
        0x04,
        V1AlarmType,
        NotificationType,
        Event,
        0x25,
    }
}
type NotificationReportV5 struct {
    *report
    node byte
    V1AlarmType byte
    V1AlarmLevel byte
    Reserved byte
    NotificationStatus byte
    NotificationType byte
    Event byte
    Properties1 byte
    EventParameter byte
    SequenceNumber byte
    data []byte
}

func NewNotificationReportV5(data []byte) *NotificationReportV5 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationReportV5{
        V1AlarmType: data[0],
        V1AlarmLevel: data[1],
        Reserved: data[2],
        NotificationStatus: data[3],
        NotificationType: data[4],
        Event: data[5],
        Properties1: data[6],
        EventParameter: data[7],
        SequenceNumber: data[8],
        data: data,
    }
}

type NotificationSetV5 struct {
    node byte
    NotificationType byte
    NotificationStatus byte
}

func (c *NotificationSetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSetV5) Set(NotificationType byte,NotificationStatus byte,) error {
    c.NotificationType = NotificationType
    c.NotificationStatus = NotificationStatus
}

func (c *NotificationSetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NotificationV5),
        0x06,
        NotificationType,
        NotificationStatus,
        0x25,
    }
}
type NotificationSupportedGetV5 struct {
    node byte
}

func (c *NotificationSupportedGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSupportedGetV5) Set() error {
}

func (c *NotificationSupportedGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NotificationV5),
        0x07,
        0x25,
    }
}
type NotificationSupportedReportV5 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewNotificationSupportedReportV5(data []byte) *NotificationSupportedReportV5 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationSupportedReportV5{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type EventSupportedGetV5 struct {
    node byte
    NotificationType byte
}

func (c *EventSupportedGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *EventSupportedGetV5) Set(NotificationType byte,) error {
    c.NotificationType = NotificationType
}

func (c *EventSupportedGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NotificationV5),
        0x01,
        NotificationType,
        0x25,
    }
}
type EventSupportedReportV5 struct {
    *report
    node byte
    NotificationType byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewEventSupportedReportV5(data []byte) *EventSupportedReportV5 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EventSupportedReportV5{
        NotificationType: data[0],
        Properties1: data[1],
        BitMask: data[2],
        data: data,
    }
}

package commands
type NotificationGetV6 struct {
    node byte
    V1AlarmType byte
    NotificationType byte
    Event byte
}

func (c *NotificationGetV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationGetV6) Set(V1AlarmType byte,NotificationType byte,Event byte,) error {
    c.V1AlarmType = V1AlarmType
    c.NotificationType = NotificationType
    c.Event = Event
}

func (c *NotificationGetV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NotificationV6),
        0x04,
        V1AlarmType,
        NotificationType,
        Event,
        0x25,
    }
}
type NotificationReportV6 struct {
    *report
    node byte
    V1AlarmType byte
    V1AlarmLevel byte
    Reserved byte
    NotificationStatus byte
    NotificationType byte
    Event byte
    Properties1 byte
    EventParameter byte
    SequenceNumber byte
    data []byte
}

func NewNotificationReportV6(data []byte) *NotificationReportV6 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationReportV6{
        V1AlarmType: data[0],
        V1AlarmLevel: data[1],
        Reserved: data[2],
        NotificationStatus: data[3],
        NotificationType: data[4],
        Event: data[5],
        Properties1: data[6],
        EventParameter: data[7],
        SequenceNumber: data[8],
        data: data,
    }
}

type NotificationSetV6 struct {
    node byte
    NotificationType byte
    NotificationStatus byte
}

func (c *NotificationSetV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSetV6) Set(NotificationType byte,NotificationStatus byte,) error {
    c.NotificationType = NotificationType
    c.NotificationStatus = NotificationStatus
}

func (c *NotificationSetV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NotificationV6),
        0x06,
        NotificationType,
        NotificationStatus,
        0x25,
    }
}
type NotificationSupportedGetV6 struct {
    node byte
}

func (c *NotificationSupportedGetV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSupportedGetV6) Set() error {
}

func (c *NotificationSupportedGetV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NotificationV6),
        0x07,
        0x25,
    }
}
type NotificationSupportedReportV6 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewNotificationSupportedReportV6(data []byte) *NotificationSupportedReportV6 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationSupportedReportV6{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type EventSupportedGetV6 struct {
    node byte
    NotificationType byte
}

func (c *EventSupportedGetV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *EventSupportedGetV6) Set(NotificationType byte,) error {
    c.NotificationType = NotificationType
}

func (c *EventSupportedGetV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NotificationV6),
        0x01,
        NotificationType,
        0x25,
    }
}
type EventSupportedReportV6 struct {
    *report
    node byte
    NotificationType byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewEventSupportedReportV6(data []byte) *EventSupportedReportV6 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EventSupportedReportV6{
        NotificationType: data[0],
        Properties1: data[1],
        BitMask: data[2],
        data: data,
    }
}

package commands
type NotificationGetV7 struct {
    node byte
    V1AlarmType byte
    NotificationType byte
    Event byte
}

func (c *NotificationGetV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationGetV7) Set(V1AlarmType byte,NotificationType byte,Event byte,) error {
    c.V1AlarmType = V1AlarmType
    c.NotificationType = NotificationType
    c.Event = Event
}

func (c *NotificationGetV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NotificationV7),
        0x04,
        V1AlarmType,
        NotificationType,
        Event,
        0x25,
    }
}
type NotificationReportV7 struct {
    *report
    node byte
    V1AlarmType byte
    V1AlarmLevel byte
    Reserved byte
    NotificationStatus byte
    NotificationType byte
    Event byte
    Properties1 byte
    EventParameter byte
    SequenceNumber byte
    data []byte
}

func NewNotificationReportV7(data []byte) *NotificationReportV7 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationReportV7{
        V1AlarmType: data[0],
        V1AlarmLevel: data[1],
        Reserved: data[2],
        NotificationStatus: data[3],
        NotificationType: data[4],
        Event: data[5],
        Properties1: data[6],
        EventParameter: data[7],
        SequenceNumber: data[8],
        data: data,
    }
}

type NotificationSetV7 struct {
    node byte
    NotificationType byte
    NotificationStatus byte
}

func (c *NotificationSetV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSetV7) Set(NotificationType byte,NotificationStatus byte,) error {
    c.NotificationType = NotificationType
    c.NotificationStatus = NotificationStatus
}

func (c *NotificationSetV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NotificationV7),
        0x06,
        NotificationType,
        NotificationStatus,
        0x25,
    }
}
type NotificationSupportedGetV7 struct {
    node byte
}

func (c *NotificationSupportedGetV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSupportedGetV7) Set() error {
}

func (c *NotificationSupportedGetV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NotificationV7),
        0x07,
        0x25,
    }
}
type NotificationSupportedReportV7 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewNotificationSupportedReportV7(data []byte) *NotificationSupportedReportV7 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationSupportedReportV7{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type EventSupportedGetV7 struct {
    node byte
    NotificationType byte
}

func (c *EventSupportedGetV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *EventSupportedGetV7) Set(NotificationType byte,) error {
    c.NotificationType = NotificationType
}

func (c *EventSupportedGetV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NotificationV7),
        0x01,
        NotificationType,
        0x25,
    }
}
type EventSupportedReportV7 struct {
    *report
    node byte
    NotificationType byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewEventSupportedReportV7(data []byte) *EventSupportedReportV7 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EventSupportedReportV7{
        NotificationType: data[0],
        Properties1: data[1],
        BitMask: data[2],
        data: data,
    }
}

package commands
type NotificationGetV8 struct {
    node byte
    V1AlarmType byte
    NotificationType byte
    Event byte
}

func (c *NotificationGetV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationGetV8) Set(V1AlarmType byte,NotificationType byte,Event byte,) error {
    c.V1AlarmType = V1AlarmType
    c.NotificationType = NotificationType
    c.Event = Event
}

func (c *NotificationGetV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NotificationV8),
        0x04,
        V1AlarmType,
        NotificationType,
        Event,
        0x25,
    }
}
type NotificationReportV8 struct {
    *report
    node byte
    V1AlarmType byte
    V1AlarmLevel byte
    Reserved byte
    NotificationStatus byte
    NotificationType byte
    Event byte
    Properties1 byte
    EventParameter byte
    SequenceNumber byte
    data []byte
}

func NewNotificationReportV8(data []byte) *NotificationReportV8 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationReportV8{
        V1AlarmType: data[0],
        V1AlarmLevel: data[1],
        Reserved: data[2],
        NotificationStatus: data[3],
        NotificationType: data[4],
        Event: data[5],
        Properties1: data[6],
        EventParameter: data[7],
        SequenceNumber: data[8],
        data: data,
    }
}

type NotificationSetV8 struct {
    node byte
    NotificationType byte
    NotificationStatus byte
}

func (c *NotificationSetV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSetV8) Set(NotificationType byte,NotificationStatus byte,) error {
    c.NotificationType = NotificationType
    c.NotificationStatus = NotificationStatus
}

func (c *NotificationSetV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NotificationV8),
        0x06,
        NotificationType,
        NotificationStatus,
        0x25,
    }
}
type NotificationSupportedGetV8 struct {
    node byte
}

func (c *NotificationSupportedGetV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *NotificationSupportedGetV8) Set() error {
}

func (c *NotificationSupportedGetV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NotificationV8),
        0x07,
        0x25,
    }
}
type NotificationSupportedReportV8 struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewNotificationSupportedReportV8(data []byte) *NotificationSupportedReportV8 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NotificationSupportedReportV8{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type EventSupportedGetV8 struct {
    node byte
    NotificationType byte
}

func (c *EventSupportedGetV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *EventSupportedGetV8) Set(NotificationType byte,) error {
    c.NotificationType = NotificationType
}

func (c *EventSupportedGetV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NotificationV8),
        0x01,
        NotificationType,
        0x25,
    }
}
type EventSupportedReportV8 struct {
    *report
    node byte
    NotificationType byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewEventSupportedReportV8(data []byte) *EventSupportedReportV8 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EventSupportedReportV8{
        NotificationType: data[0],
        Properties1: data[1],
        BitMask: data[2],
        data: data,
    }
}

package commands
type ApplicationBusy struct {
    node byte
    Status byte
    WaitTime byte
}

func (c *ApplicationBusy) SetNode(node int) {
    c.node = byte(node)
}

func (c *ApplicationBusy) Set(Status byte,WaitTime byte,) error {
    c.Status = Status
    c.WaitTime = WaitTime
}

func (c *ApplicationBusy) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ApplicationStatus),
        0x01,
        Status,
        WaitTime,
        0x25,
    }
}
type ApplicationRejectedRequest struct {
    node byte
    Status byte
}

func (c *ApplicationRejectedRequest) SetNode(node int) {
    c.node = byte(node)
}

func (c *ApplicationRejectedRequest) Set(Status byte,) error {
    c.Status = Status
}

func (c *ApplicationRejectedRequest) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ApplicationStatus),
        0x02,
        Status,
        0x25,
    }
}
package commands
type CommandConfigurationGet struct {
    node byte
    Groupingidentifier byte
    NodeID byte
}

func (c *CommandConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandConfigurationGet) Set(Groupingidentifier byte,NodeID byte,) error {
    c.Groupingidentifier = Groupingidentifier
    c.NodeID = NodeID
}

func (c *CommandConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationCommandConfiguration),
        0x04,
        Groupingidentifier,
        NodeID,
        0x25,
    }
}
type CommandConfigurationReport struct {
    *report
    node byte
    Groupingidentifier byte
    NodeID byte
    Properties1 byte
    Commandlength byte
    CommandClassidentifier byte
    Commandidentifier byte
    Commandbyte byte
    data []byte
}

func NewCommandConfigurationReport(data []byte) *CommandConfigurationReport {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandConfigurationReport{
        Groupingidentifier: data[0],
        NodeID: data[1],
        Properties1: data[2],
        Commandlength: data[3],
        CommandClassidentifier: data[4],
        Commandidentifier: data[5],
        Commandbyte: data[6],
        data: data,
    }
}

type CommandConfigurationSet struct {
    node byte
    Groupingidentifier byte
    NodeID byte
    Commandlength byte
    CommandClassidentifier byte
    Commandidentifier byte
    Commandbyte byte
}

func (c *CommandConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandConfigurationSet) Set(Groupingidentifier byte,NodeID byte,Commandlength byte,CommandClassidentifier byte,Commandidentifier byte,Commandbyte byte,) error {
    c.Groupingidentifier = Groupingidentifier
    c.NodeID = NodeID
    c.Commandlength = Commandlength
    c.CommandClassidentifier = CommandClassidentifier
    c.Commandidentifier = Commandidentifier
    c.Commandbyte = Commandbyte
}

func (c *CommandConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(AssociationCommandConfiguration),
        0x03,
        Groupingidentifier,
        NodeID,
        Commandlength,
        CommandClassidentifier,
        Commandidentifier,
        Commandbyte,
        0x25,
    }
}
type CommandRecordsSupportedGet struct {
    node byte
}

func (c *CommandRecordsSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandRecordsSupportedGet) Set() error {
}

func (c *CommandRecordsSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AssociationCommandConfiguration),
        0x01,
        0x25,
    }
}
type CommandRecordsSupportedReport struct {
    *report
    node byte
    Properties1 byte
    FreeCommandrecords byte
    MaxCommandrecords byte
    data []byte
}

func NewCommandRecordsSupportedReport(data []byte) *CommandRecordsSupportedReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandRecordsSupportedReport{
        Properties1: data[0],
        FreeCommandrecords: data[1],
        MaxCommandrecords: data[2],
        data: data,
    }
}

package commands
type AssociationGet struct {
    node byte
    GroupingIdentifier byte
}

func (c *AssociationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGet) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Association),
        0x02,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupingsGet struct {
    node byte
}

func (c *AssociationGroupingsGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupingsGet) Set() error {
}

func (c *AssociationGroupingsGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Association),
        0x05,
        0x25,
    }
}
type AssociationGroupingsReport struct {
    *report
    node byte
    SupportedGroupings byte
    data []byte
}

func NewAssociationGroupingsReport(data []byte) *AssociationGroupingsReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupingsReport{
        SupportedGroupings: data[0],
        data: data,
    }
}

type AssociationRemove struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
}

func (c *AssociationRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationRemove) Set(GroupingIdentifier byte,NodeID byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
}

func (c *AssociationRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Association),
        0x04,
        GroupingIdentifier,
        NodeID,
        0x25,
    }
}
type AssociationReport struct {
    *report
    node byte
    GroupingIdentifier byte
    MaxNodesSupported byte
    ReportstoFollow byte
    NodeID byte
    data []byte
}

func NewAssociationReport(data []byte) *AssociationReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationReport{
        GroupingIdentifier: data[0],
        MaxNodesSupported: data[1],
        ReportstoFollow: data[2],
        NodeID: data[3],
        data: data,
    }
}

type AssociationSet struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
}

func (c *AssociationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationSet) Set(GroupingIdentifier byte,NodeID byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
}

func (c *AssociationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Association),
        0x01,
        GroupingIdentifier,
        NodeID,
        0x25,
    }
}
package commands
type AssociationGetV2 struct {
    node byte
    GroupingIdentifier byte
}

func (c *AssociationGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGetV2) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(AssociationV2),
        0x02,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupingsGetV2 struct {
    node byte
}

func (c *AssociationGroupingsGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupingsGetV2) Set() error {
}

func (c *AssociationGroupingsGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AssociationV2),
        0x05,
        0x25,
    }
}
type AssociationGroupingsReportV2 struct {
    *report
    node byte
    SupportedGroupings byte
    data []byte
}

func NewAssociationGroupingsReportV2(data []byte) *AssociationGroupingsReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupingsReportV2{
        SupportedGroupings: data[0],
        data: data,
    }
}

type AssociationRemoveV2 struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
}

func (c *AssociationRemoveV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationRemoveV2) Set(GroupingIdentifier byte,NodeID byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
}

func (c *AssociationRemoveV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationV2),
        0x04,
        GroupingIdentifier,
        NodeID,
        0x25,
    }
}
type AssociationReportV2 struct {
    *report
    node byte
    GroupingIdentifier byte
    MaxNodesSupported byte
    ReportstoFollow byte
    NodeID byte
    data []byte
}

func NewAssociationReportV2(data []byte) *AssociationReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationReportV2{
        GroupingIdentifier: data[0],
        MaxNodesSupported: data[1],
        ReportstoFollow: data[2],
        NodeID: data[3],
        data: data,
    }
}

type AssociationSetV2 struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
}

func (c *AssociationSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationSetV2) Set(GroupingIdentifier byte,NodeID byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
}

func (c *AssociationSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationV2),
        0x01,
        GroupingIdentifier,
        NodeID,
        0x25,
    }
}
type AssociationSpecificGroupGetV2 struct {
    node byte
}

func (c *AssociationSpecificGroupGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationSpecificGroupGetV2) Set() error {
}

func (c *AssociationSpecificGroupGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AssociationV2),
        0x0B,
        0x25,
    }
}
type AssociationSpecificGroupReportV2 struct {
    *report
    node byte
    Group byte
    data []byte
}

func NewAssociationSpecificGroupReportV2(data []byte) *AssociationSpecificGroupReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationSpecificGroupReportV2{
        Group: data[0],
        data: data,
    }
}

package commands
type AvContentBrowseMdByLetterGet struct {
    node byte
}

func (c *AvContentBrowseMdByLetterGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvContentBrowseMdByLetterGet) Set() error {
}

func (c *AvContentBrowseMdByLetterGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvContentDirectoryMd),
        0x03,
        0x25,
    }
}
type AvContentBrowseMdByLetterReport struct {
    *report
    node byte
    data []byte
}

func NewAvContentBrowseMdByLetterReport(data []byte) *AvContentBrowseMdByLetterReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvContentBrowseMdByLetterReport{
        data: data,
    }
}

type AvContentBrowseMdChildCountGet struct {
    node byte
}

func (c *AvContentBrowseMdChildCountGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvContentBrowseMdChildCountGet) Set() error {
}

func (c *AvContentBrowseMdChildCountGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvContentDirectoryMd),
        0x05,
        0x25,
    }
}
type AvContentBrowseMdChildCountReport struct {
    *report
    node byte
    data []byte
}

func NewAvContentBrowseMdChildCountReport(data []byte) *AvContentBrowseMdChildCountReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvContentBrowseMdChildCountReport{
        data: data,
    }
}

type AvContentBrowseMdGet struct {
    node byte
}

func (c *AvContentBrowseMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvContentBrowseMdGet) Set() error {
}

func (c *AvContentBrowseMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvContentDirectoryMd),
        0x01,
        0x25,
    }
}
type AvContentBrowseMdReport struct {
    *report
    node byte
    data []byte
}

func NewAvContentBrowseMdReport(data []byte) *AvContentBrowseMdReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvContentBrowseMdReport{
        data: data,
    }
}

type AvMatchItemToRendererMdGet struct {
    node byte
}

func (c *AvMatchItemToRendererMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvMatchItemToRendererMdGet) Set() error {
}

func (c *AvMatchItemToRendererMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvContentDirectoryMd),
        0x07,
        0x25,
    }
}
type AvMatchItemToRendererMdReport struct {
    *report
    node byte
    data []byte
}

func NewAvMatchItemToRendererMdReport(data []byte) *AvMatchItemToRendererMdReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvMatchItemToRendererMdReport{
        data: data,
    }
}

package commands
type AvContentSearchMdGet struct {
    node byte
}

func (c *AvContentSearchMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvContentSearchMdGet) Set() error {
}

func (c *AvContentSearchMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvContentSearchMd),
        0x01,
        0x25,
    }
}
type AvContentSearchMdReport struct {
    *report
    node byte
    data []byte
}

func NewAvContentSearchMdReport(data []byte) *AvContentSearchMdReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvContentSearchMdReport{
        data: data,
    }
}

package commands
type AvRendererStatusGet struct {
    node byte
}

func (c *AvRendererStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvRendererStatusGet) Set() error {
}

func (c *AvRendererStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvRendererStatus),
        0x01,
        0x25,
    }
}
type AvRendererStatusReport struct {
    *report
    node byte
    data []byte
}

func NewAvRendererStatusReport(data []byte) *AvRendererStatusReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvRendererStatusReport{
        data: data,
    }
}

package commands
type AvTaggingMdGet struct {
    node byte
}

func (c *AvTaggingMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AvTaggingMdGet) Set() error {
}

func (c *AvTaggingMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AvTaggingMd),
        0x01,
        0x25,
    }
}
type AvTaggingMdReport struct {
    *report
    node byte
    data []byte
}

func NewAvTaggingMdReport(data []byte) *AvTaggingMdReport {
    if len(data) < 0 {
        for i := len(data); i < 0; i++ {
            data = append(data, 0x00)
        }
    }

    return &AvTaggingMdReport{
        data: data,
    }
}

package commands
type BasicTariffInfoGet struct {
    node byte
}

func (c *BasicTariffInfoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicTariffInfoGet) Set() error {
}

func (c *BasicTariffInfoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(BasicTariffInfo),
        0x01,
        0x25,
    }
}
type BasicTariffInfoReport struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    E1RateConsumptionRegister byte
    E1TimeforNextRateHours byte
    E1TimeforNextRateMinutes byte
    E1TimeforNextRateSeconds byte
    Properties3 byte
    E2RateConsumptionRegister byte
    data []byte
}

func NewBasicTariffInfoReport(data []byte) *BasicTariffInfoReport {
    if len(data) < 8 {
        for i := len(data); i < 8; i++ {
            data = append(data, 0x00)
        }
    }

    return &BasicTariffInfoReport{
        Properties1: data[0],
        Properties2: data[1],
        E1RateConsumptionRegister: data[2],
        E1TimeforNextRateHours: data[3],
        E1TimeforNextRateMinutes: data[4],
        E1TimeforNextRateSeconds: data[5],
        Properties3: data[6],
        E2RateConsumptionRegister: data[7],
        data: data,
    }
}

package commands
type BasicWindowCoveringStartLevelChange struct {
    node byte
    Level byte
}

func (c *BasicWindowCoveringStartLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicWindowCoveringStartLevelChange) Set(Level byte,) error {
    c.Level = Level
}

func (c *BasicWindowCoveringStartLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(BasicWindowCovering),
        0x01,
        Level,
        0x25,
    }
}
type BasicWindowCoveringStopLevelChange struct {
    node byte
}

func (c *BasicWindowCoveringStopLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicWindowCoveringStopLevelChange) Set() error {
}

func (c *BasicWindowCoveringStopLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(BasicWindowCovering),
        0x02,
        0x25,
    }
}
package commands
type BasicGet struct {
    node byte
}

func (c *BasicGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicGet) Set() error {
}

func (c *BasicGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Basic),
        0x02,
        0x25,
    }
}
type BasicReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewBasicReport(data []byte) *BasicReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &BasicReport{
        Value: data[0],
        data: data,
    }
}

type BasicSet struct {
    node byte
    Value byte
}

func (c *BasicSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicSet) Set(Value byte,) error {
    c.Value = Value
}

func (c *BasicSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Basic),
        0x01,
        Value,
        0x25,
    }
}
package commands
type BasicGetV2 struct {
    node byte
}

func (c *BasicGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicGetV2) Set() error {
}

func (c *BasicGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(BasicV2),
        0x02,
        0x25,
    }
}
type BasicReportV2 struct {
    *report
    node byte
    CurrentValue byte
    TargetValue byte
    Duration byte
    data []byte
}

func NewBasicReportV2(data []byte) *BasicReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &BasicReportV2{
        CurrentValue: data[0],
        TargetValue: data[1],
        Duration: data[2],
        data: data,
    }
}

type BasicSetV2 struct {
    node byte
    Value byte
}

func (c *BasicSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *BasicSetV2) Set(Value byte,) error {
    c.Value = Value
}

func (c *BasicSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(BasicV2),
        0x01,
        Value,
        0x25,
    }
}
package commands
type BatteryGet struct {
    node byte
}

func (c *BatteryGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BatteryGet) Set() error {
}

func (c *BatteryGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Battery),
        0x02,
        0x25,
    }
}
type BatteryReport struct {
    *report
    node byte
    BatteryLevel byte
    data []byte
}

func NewBatteryReport(data []byte) *BatteryReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &BatteryReport{
        BatteryLevel: data[0],
        data: data,
    }
}

package commands
type ChimneyFanAlarmLogGet struct {
    node byte
}

func (c *ChimneyFanAlarmLogGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanAlarmLogGet) Set() error {
}

func (c *ChimneyFanAlarmLogGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x20,
        0x25,
    }
}
type ChimneyFanAlarmLogReport struct {
    *report
    node byte
    AlarmEvent1 byte
    AlarmEvent2 byte
    AlarmEvent3 byte
    AlarmEvent4 byte
    AlarmEvent5 byte
    data []byte
}

func NewChimneyFanAlarmLogReport(data []byte) *ChimneyFanAlarmLogReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanAlarmLogReport{
        AlarmEvent1: data[0],
        AlarmEvent2: data[1],
        AlarmEvent3: data[2],
        AlarmEvent4: data[3],
        AlarmEvent5: data[4],
        data: data,
    }
}

type ChimneyFanAlarmLogSet struct {
    node byte
    Message byte
}

func (c *ChimneyFanAlarmLogSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanAlarmLogSet) Set(Message byte,) error {
    c.Message = Message
}

func (c *ChimneyFanAlarmLogSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x1F,
        Message,
        0x25,
    }
}
type ChimneyFanAlarmStatusGet struct {
    node byte
}

func (c *ChimneyFanAlarmStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanAlarmStatusGet) Set() error {
}

func (c *ChimneyFanAlarmStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x23,
        0x25,
    }
}
type ChimneyFanAlarmStatusReport struct {
    *report
    node byte
    AlarmStatus byte
    data []byte
}

func NewChimneyFanAlarmStatusReport(data []byte) *ChimneyFanAlarmStatusReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanAlarmStatusReport{
        AlarmStatus: data[0],
        data: data,
    }
}

type ChimneyFanAlarmStatusSet struct {
    node byte
    Message byte
}

func (c *ChimneyFanAlarmStatusSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanAlarmStatusSet) Set(Message byte,) error {
    c.Message = Message
}

func (c *ChimneyFanAlarmStatusSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x22,
        Message,
        0x25,
    }
}
type ChimneyFanAlarmTempGet struct {
    node byte
}

func (c *ChimneyFanAlarmTempGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanAlarmTempGet) Set() error {
}

func (c *ChimneyFanAlarmTempGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x0E,
        0x25,
    }
}
type ChimneyFanAlarmTempReport struct {
    *report
    node byte
    Properties1 byte
    Value byte
    data []byte
}

func NewChimneyFanAlarmTempReport(data []byte) *ChimneyFanAlarmTempReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanAlarmTempReport{
        Properties1: data[0],
        Value: data[1],
        data: data,
    }
}

type ChimneyFanAlarmTempSet struct {
    node byte
    Properties1 byte
    Value byte
}

func (c *ChimneyFanAlarmTempSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanAlarmTempSet) Set(Properties1 byte,Value byte,) error {
    c.Properties1 = Properties1
    c.Value = Value
}

func (c *ChimneyFanAlarmTempSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ChimneyFan),
        0x0D,
        Properties1,
        Value,
        0x25,
    }
}
type ChimneyFanBoostTimeGet struct {
    node byte
}

func (c *ChimneyFanBoostTimeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanBoostTimeGet) Set() error {
}

func (c *ChimneyFanBoostTimeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x11,
        0x25,
    }
}
type ChimneyFanBoostTimeReport struct {
    *report
    node byte
    Time byte
    data []byte
}

func NewChimneyFanBoostTimeReport(data []byte) *ChimneyFanBoostTimeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanBoostTimeReport{
        Time: data[0],
        data: data,
    }
}

type ChimneyFanBoostTimeSet struct {
    node byte
    Time byte
}

func (c *ChimneyFanBoostTimeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanBoostTimeSet) Set(Time byte,) error {
    c.Time = Time
}

func (c *ChimneyFanBoostTimeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x10,
        Time,
        0x25,
    }
}
type ChimneyFanDefaultSet struct {
    node byte
}

func (c *ChimneyFanDefaultSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanDefaultSet) Set() error {
}

func (c *ChimneyFanDefaultSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x28,
        0x25,
    }
}
type ChimneyFanMinSpeedGet struct {
    node byte
}

func (c *ChimneyFanMinSpeedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanMinSpeedGet) Set() error {
}

func (c *ChimneyFanMinSpeedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x26,
        0x25,
    }
}
type ChimneyFanMinSpeedReport struct {
    *report
    node byte
    MinSpeed byte
    data []byte
}

func NewChimneyFanMinSpeedReport(data []byte) *ChimneyFanMinSpeedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanMinSpeedReport{
        MinSpeed: data[0],
        data: data,
    }
}

type ChimneyFanMinSpeedSet struct {
    node byte
    MinSpeed byte
}

func (c *ChimneyFanMinSpeedSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanMinSpeedSet) Set(MinSpeed byte,) error {
    c.MinSpeed = MinSpeed
}

func (c *ChimneyFanMinSpeedSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x25,
        MinSpeed,
        0x25,
    }
}
type ChimneyFanModeGet struct {
    node byte
}

func (c *ChimneyFanModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanModeGet) Set() error {
}

func (c *ChimneyFanModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x17,
        0x25,
    }
}
type ChimneyFanModeReport struct {
    *report
    node byte
    Mode byte
    data []byte
}

func NewChimneyFanModeReport(data []byte) *ChimneyFanModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanModeReport{
        Mode: data[0],
        data: data,
    }
}

type ChimneyFanModeSet struct {
    node byte
    Mode byte
}

func (c *ChimneyFanModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanModeSet) Set(Mode byte,) error {
    c.Mode = Mode
}

func (c *ChimneyFanModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x16,
        Mode,
        0x25,
    }
}
type ChimneyFanSetupGet struct {
    node byte
}

func (c *ChimneyFanSetupGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanSetupGet) Set() error {
}

func (c *ChimneyFanSetupGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x1A,
        0x25,
    }
}
type ChimneyFanSetupReport struct {
    *report
    node byte
    Mode byte
    BoostTime byte
    StopTime byte
    Min.Speed byte
    Properties1 byte
    StartTemperature byte
    Properties2 byte
    StopTemperature byte
    Properties3 byte
    AlarmTemperatureValue byte
    data []byte
}

func NewChimneyFanSetupReport(data []byte) *ChimneyFanSetupReport {
    if len(data) < 10 {
        for i := len(data); i < 10; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanSetupReport{
        Mode: data[0],
        BoostTime: data[1],
        StopTime: data[2],
        Min.Speed: data[3],
        Properties1: data[4],
        StartTemperature: data[5],
        Properties2: data[6],
        StopTemperature: data[7],
        Properties3: data[8],
        AlarmTemperatureValue: data[9],
        data: data,
    }
}

type ChimneyFanSetupSet struct {
    node byte
    Mode byte
    BoostTime byte
    StopTime byte
    Min.Speed byte
    Properties1 byte
    StartTemperature byte
    Properties2 byte
    StopTemperature byte
    Properties3 byte
    AlarmTemperatureValue byte
}

func (c *ChimneyFanSetupSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanSetupSet) Set(Mode byte,BoostTime byte,StopTime byte,Min.Speed byte,Properties1 byte,StartTemperature byte,Properties2 byte,StopTemperature byte,Properties3 byte,AlarmTemperatureValue byte,) error {
    c.Mode = Mode
    c.BoostTime = BoostTime
    c.StopTime = StopTime
    c.Min.Speed = Min.Speed
    c.Properties1 = Properties1
    c.StartTemperature = StartTemperature
    c.Properties2 = Properties2
    c.StopTemperature = StopTemperature
    c.Properties3 = Properties3
    c.AlarmTemperatureValue = AlarmTemperatureValue
}

func (c *ChimneyFanSetupSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(10),
        byte(ChimneyFan),
        0x19,
        Mode,
        BoostTime,
        StopTime,
        Min.Speed,
        Properties1,
        StartTemperature,
        Properties2,
        StopTemperature,
        Properties3,
        AlarmTemperatureValue,
        0x25,
    }
}
type ChimneyFanSpeedGet struct {
    node byte
}

func (c *ChimneyFanSpeedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanSpeedGet) Set() error {
}

func (c *ChimneyFanSpeedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x05,
        0x25,
    }
}
type ChimneyFanSpeedReport struct {
    *report
    node byte
    Speed byte
    data []byte
}

func NewChimneyFanSpeedReport(data []byte) *ChimneyFanSpeedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanSpeedReport{
        Speed: data[0],
        data: data,
    }
}

type ChimneyFanSpeedSet struct {
    node byte
    Speed byte
}

func (c *ChimneyFanSpeedSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanSpeedSet) Set(Speed byte,) error {
    c.Speed = Speed
}

func (c *ChimneyFanSpeedSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x04,
        Speed,
        0x25,
    }
}
type ChimneyFanStartTempGet struct {
    node byte
}

func (c *ChimneyFanStartTempGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStartTempGet) Set() error {
}

func (c *ChimneyFanStartTempGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x08,
        0x25,
    }
}
type ChimneyFanStartTempReport struct {
    *report
    node byte
    Properties1 byte
    Value byte
    data []byte
}

func NewChimneyFanStartTempReport(data []byte) *ChimneyFanStartTempReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanStartTempReport{
        Properties1: data[0],
        Value: data[1],
        data: data,
    }
}

type ChimneyFanStartTempSet struct {
    node byte
    Properties1 byte
    Value byte
}

func (c *ChimneyFanStartTempSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStartTempSet) Set(Properties1 byte,Value byte,) error {
    c.Properties1 = Properties1
    c.Value = Value
}

func (c *ChimneyFanStartTempSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ChimneyFan),
        0x07,
        Properties1,
        Value,
        0x25,
    }
}
type ChimneyFanStateGet struct {
    node byte
}

func (c *ChimneyFanStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStateGet) Set() error {
}

func (c *ChimneyFanStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x02,
        0x25,
    }
}
type ChimneyFanStateReport struct {
    *report
    node byte
    State byte
    data []byte
}

func NewChimneyFanStateReport(data []byte) *ChimneyFanStateReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanStateReport{
        State: data[0],
        data: data,
    }
}

type ChimneyFanStateSet struct {
    node byte
    State byte
}

func (c *ChimneyFanStateSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStateSet) Set(State byte,) error {
    c.State = State
}

func (c *ChimneyFanStateSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x01,
        State,
        0x25,
    }
}
type ChimneyFanStatusGet struct {
    node byte
}

func (c *ChimneyFanStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStatusGet) Set() error {
}

func (c *ChimneyFanStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x1D,
        0x25,
    }
}
type ChimneyFanStatusReport struct {
    *report
    node byte
    State byte
    Speed byte
    AlarmStatus byte
    Properties1 byte
    Value byte
    data []byte
}

func NewChimneyFanStatusReport(data []byte) *ChimneyFanStatusReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanStatusReport{
        State: data[0],
        Speed: data[1],
        AlarmStatus: data[2],
        Properties1: data[3],
        Value: data[4],
        data: data,
    }
}

type ChimneyFanStopTempGet struct {
    node byte
}

func (c *ChimneyFanStopTempGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStopTempGet) Set() error {
}

func (c *ChimneyFanStopTempGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x0B,
        0x25,
    }
}
type ChimneyFanStopTempReport struct {
    *report
    node byte
    Properties1 byte
    Value byte
    data []byte
}

func NewChimneyFanStopTempReport(data []byte) *ChimneyFanStopTempReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanStopTempReport{
        Properties1: data[0],
        Value: data[1],
        data: data,
    }
}

type ChimneyFanStopTempSet struct {
    node byte
    Properties1 byte
    Value byte
}

func (c *ChimneyFanStopTempSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStopTempSet) Set(Properties1 byte,Value byte,) error {
    c.Properties1 = Properties1
    c.Value = Value
}

func (c *ChimneyFanStopTempSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ChimneyFan),
        0x0A,
        Properties1,
        Value,
        0x25,
    }
}
type ChimneyFanStopTimeGet struct {
    node byte
}

func (c *ChimneyFanStopTimeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStopTimeGet) Set() error {
}

func (c *ChimneyFanStopTimeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ChimneyFan),
        0x14,
        0x25,
    }
}
type ChimneyFanStopTimeReport struct {
    *report
    node byte
    Time byte
    data []byte
}

func NewChimneyFanStopTimeReport(data []byte) *ChimneyFanStopTimeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ChimneyFanStopTimeReport{
        Time: data[0],
        data: data,
    }
}

type ChimneyFanStopTimeSet struct {
    node byte
    Time byte
}

func (c *ChimneyFanStopTimeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ChimneyFanStopTimeSet) Set(Time byte,) error {
    c.Time = Time
}

func (c *ChimneyFanStopTimeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ChimneyFan),
        0x13,
        Time,
        0x25,
    }
}
package commands
type ScheduleChangedGet struct {
    node byte
}

func (c *ScheduleChangedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleChangedGet) Set() error {
}

func (c *ScheduleChangedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ClimateControlSchedule),
        0x04,
        0x25,
    }
}
type ScheduleChangedReport struct {
    *report
    node byte
    ChangeCounter byte
    data []byte
}

func NewScheduleChangedReport(data []byte) *ScheduleChangedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleChangedReport{
        ChangeCounter: data[0],
        data: data,
    }
}

type ScheduleGet struct {
    node byte
    Properties1 byte
}

func (c *ScheduleGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleGet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *ScheduleGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ClimateControlSchedule),
        0x02,
        Properties1,
        0x25,
    }
}
type ScheduleOverrideGet struct {
    node byte
}

func (c *ScheduleOverrideGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleOverrideGet) Set() error {
}

func (c *ScheduleOverrideGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ClimateControlSchedule),
        0x07,
        0x25,
    }
}
type ScheduleOverrideReport struct {
    *report
    node byte
    Properties1 byte
    OverrideState byte
    data []byte
}

func NewScheduleOverrideReport(data []byte) *ScheduleOverrideReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleOverrideReport{
        Properties1: data[0],
        OverrideState: data[1],
        data: data,
    }
}

type ScheduleOverrideSet struct {
    node byte
    Properties1 byte
    OverrideState byte
}

func (c *ScheduleOverrideSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleOverrideSet) Set(Properties1 byte,OverrideState byte,) error {
    c.Properties1 = Properties1
    c.OverrideState = OverrideState
}

func (c *ScheduleOverrideSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ClimateControlSchedule),
        0x06,
        Properties1,
        OverrideState,
        0x25,
    }
}
type ScheduleReport struct {
    *report
    node byte
    Properties1 byte
    Switchpoint0 byte
    Switchpoint1 byte
    Switchpoint2 byte
    Switchpoint3 byte
    Switchpoint4 byte
    Switchpoint5 byte
    Switchpoint6 byte
    Switchpoint7 byte
    Switchpoint8 byte
    data []byte
}

func NewScheduleReport(data []byte) *ScheduleReport {
    if len(data) < 10 {
        for i := len(data); i < 10; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleReport{
        Properties1: data[0],
        Switchpoint0: data[1],
        Switchpoint1: data[2],
        Switchpoint2: data[3],
        Switchpoint3: data[4],
        Switchpoint4: data[5],
        Switchpoint5: data[6],
        Switchpoint6: data[7],
        Switchpoint7: data[8],
        Switchpoint8: data[9],
        data: data,
    }
}

type ScheduleSet struct {
    node byte
    Properties1 byte
    Switchpoint0 byte
    Switchpoint1 byte
    Switchpoint2 byte
    Switchpoint3 byte
    Switchpoint4 byte
    Switchpoint5 byte
    Switchpoint6 byte
    Switchpoint7 byte
    Switchpoint8 byte
}

func (c *ScheduleSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleSet) Set(Properties1 byte,Switchpoint0 byte,Switchpoint1 byte,Switchpoint2 byte,Switchpoint3 byte,Switchpoint4 byte,Switchpoint5 byte,Switchpoint6 byte,Switchpoint7 byte,Switchpoint8 byte,) error {
    c.Properties1 = Properties1
    c.Switchpoint0 = Switchpoint0
    c.Switchpoint1 = Switchpoint1
    c.Switchpoint2 = Switchpoint2
    c.Switchpoint3 = Switchpoint3
    c.Switchpoint4 = Switchpoint4
    c.Switchpoint5 = Switchpoint5
    c.Switchpoint6 = Switchpoint6
    c.Switchpoint7 = Switchpoint7
    c.Switchpoint8 = Switchpoint8
}

func (c *ScheduleSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(10),
        byte(ClimateControlSchedule),
        0x01,
        Properties1,
        Switchpoint0,
        Switchpoint1,
        Switchpoint2,
        Switchpoint3,
        Switchpoint4,
        Switchpoint5,
        Switchpoint6,
        Switchpoint7,
        Switchpoint8,
        0x25,
    }
}
package commands
type ClockGet struct {
    node byte
}

func (c *ClockGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ClockGet) Set() error {
}

func (c *ClockGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Clock),
        0x05,
        0x25,
    }
}
type ClockReport struct {
    *report
    node byte
    Level byte
    Minute byte
    data []byte
}

func NewClockReport(data []byte) *ClockReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ClockReport{
        Level: data[0],
        Minute: data[1],
        data: data,
    }
}

type ClockSet struct {
    node byte
    Level byte
    Minute byte
}

func (c *ClockSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ClockSet) Set(Level byte,Minute byte,) error {
    c.Level = Level
    c.Minute = Minute
}

func (c *ClockSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Clock),
        0x04,
        Level,
        Minute,
        0x25,
    }
}
package commands
type ConfigurationGet struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationGet) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Configuration),
        0x05,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationReport struct {
    *report
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
    data []byte
}

func NewConfigurationReport(data []byte) *ConfigurationReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationReport{
        ParameterNumber: data[0],
        Level: data[1],
        ConfigurationValue: data[2],
        data: data,
    }
}

type ConfigurationSet struct {
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
}

func (c *ConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationSet) Set(ParameterNumber byte,Level byte,ConfigurationValue byte,) error {
    c.ParameterNumber = ParameterNumber
    c.Level = Level
    c.ConfigurationValue = ConfigurationValue
}

func (c *ConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Configuration),
        0x04,
        ParameterNumber,
        Level,
        ConfigurationValue,
        0x25,
    }
}
package commands
type ConfigurationBulkGetV2 struct {
    node byte
    ParameterOffset byte
    NumberofParameters byte
}

func (c *ConfigurationBulkGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationBulkGetV2) Set(ParameterOffset byte,NumberofParameters byte,) error {
    c.ParameterOffset = ParameterOffset
    c.NumberofParameters = NumberofParameters
}

func (c *ConfigurationBulkGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ConfigurationV2),
        0x08,
        ParameterOffset,
        NumberofParameters,
        0x25,
    }
}
type ConfigurationBulkReportV2 struct {
    *report
    node byte
    ParameterOffset byte
    NumberofParameters byte
    Reportstofollow byte
    Properties1 byte
    data []byte
}

func NewConfigurationBulkReportV2(data []byte) *ConfigurationBulkReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationBulkReportV2{
        ParameterOffset: data[0],
        NumberofParameters: data[1],
        Reportstofollow: data[2],
        Properties1: data[3],
        data: data,
    }
}

type ConfigurationBulkSetV2 struct {
    node byte
    ParameterOffset byte
    NumberofParameters byte
    Properties1 byte
}

func (c *ConfigurationBulkSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationBulkSetV2) Set(ParameterOffset byte,NumberofParameters byte,Properties1 byte,) error {
    c.ParameterOffset = ParameterOffset
    c.NumberofParameters = NumberofParameters
    c.Properties1 = Properties1
}

func (c *ConfigurationBulkSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ConfigurationV2),
        0x07,
        ParameterOffset,
        NumberofParameters,
        Properties1,
        0x25,
    }
}
type ConfigurationGetV2 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationGetV2) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV2),
        0x05,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationReportV2 struct {
    *report
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
    data []byte
}

func NewConfigurationReportV2(data []byte) *ConfigurationReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationReportV2{
        ParameterNumber: data[0],
        Level: data[1],
        ConfigurationValue: data[2],
        data: data,
    }
}

type ConfigurationSetV2 struct {
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
}

func (c *ConfigurationSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationSetV2) Set(ParameterNumber byte,Level byte,ConfigurationValue byte,) error {
    c.ParameterNumber = ParameterNumber
    c.Level = Level
    c.ConfigurationValue = ConfigurationValue
}

func (c *ConfigurationSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ConfigurationV2),
        0x04,
        ParameterNumber,
        Level,
        ConfigurationValue,
        0x25,
    }
}
package commands
type ConfigurationBulkGetV3 struct {
    node byte
    ParameterOffset byte
    NumberofParameters byte
}

func (c *ConfigurationBulkGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationBulkGetV3) Set(ParameterOffset byte,NumberofParameters byte,) error {
    c.ParameterOffset = ParameterOffset
    c.NumberofParameters = NumberofParameters
}

func (c *ConfigurationBulkGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ConfigurationV3),
        0x08,
        ParameterOffset,
        NumberofParameters,
        0x25,
    }
}
type ConfigurationBulkReportV3 struct {
    *report
    node byte
    ParameterOffset byte
    NumberofParameters byte
    Reportstofollow byte
    Properties1 byte
    data []byte
}

func NewConfigurationBulkReportV3(data []byte) *ConfigurationBulkReportV3 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationBulkReportV3{
        ParameterOffset: data[0],
        NumberofParameters: data[1],
        Reportstofollow: data[2],
        Properties1: data[3],
        data: data,
    }
}

type ConfigurationBulkSetV3 struct {
    node byte
    ParameterOffset byte
    NumberofParameters byte
    Properties1 byte
}

func (c *ConfigurationBulkSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationBulkSetV3) Set(ParameterOffset byte,NumberofParameters byte,Properties1 byte,) error {
    c.ParameterOffset = ParameterOffset
    c.NumberofParameters = NumberofParameters
    c.Properties1 = Properties1
}

func (c *ConfigurationBulkSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ConfigurationV3),
        0x07,
        ParameterOffset,
        NumberofParameters,
        Properties1,
        0x25,
    }
}
type ConfigurationGetV3 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationGetV3) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV3),
        0x05,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationReportV3 struct {
    *report
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
    data []byte
}

func NewConfigurationReportV3(data []byte) *ConfigurationReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationReportV3{
        ParameterNumber: data[0],
        Level: data[1],
        ConfigurationValue: data[2],
        data: data,
    }
}

type ConfigurationSetV3 struct {
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
}

func (c *ConfigurationSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationSetV3) Set(ParameterNumber byte,Level byte,ConfigurationValue byte,) error {
    c.ParameterNumber = ParameterNumber
    c.Level = Level
    c.ConfigurationValue = ConfigurationValue
}

func (c *ConfigurationSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ConfigurationV3),
        0x04,
        ParameterNumber,
        Level,
        ConfigurationValue,
        0x25,
    }
}
type ConfigurationNameGetV3 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationNameGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationNameGetV3) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationNameGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV3),
        0x0A,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationNameReportV3 struct {
    *report
    node byte
    ParameterNumber byte
    Reportstofollow byte
    Name byte
    data []byte
}

func NewConfigurationNameReportV3(data []byte) *ConfigurationNameReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationNameReportV3{
        ParameterNumber: data[0],
        Reportstofollow: data[1],
        Name: data[2],
        data: data,
    }
}

type ConfigurationInfoGetV3 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationInfoGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationInfoGetV3) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationInfoGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV3),
        0x0C,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationInfoReportV3 struct {
    *report
    node byte
    ParameterNumber byte
    Reportstofollow byte
    Info byte
    data []byte
}

func NewConfigurationInfoReportV3(data []byte) *ConfigurationInfoReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationInfoReportV3{
        ParameterNumber: data[0],
        Reportstofollow: data[1],
        Info: data[2],
        data: data,
    }
}

type ConfigurationPropertiesGetV3 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationPropertiesGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationPropertiesGetV3) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationPropertiesGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV3),
        0x0E,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationPropertiesReportV3 struct {
    *report
    node byte
    ParameterNumber byte
    Properties1 byte
    MinValue byte
    MaxValue byte
    DefaultValue byte
    NextParameterNumber byte
    data []byte
}

func NewConfigurationPropertiesReportV3(data []byte) *ConfigurationPropertiesReportV3 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationPropertiesReportV3{
        ParameterNumber: data[0],
        Properties1: data[1],
        MinValue: data[2],
        MaxValue: data[3],
        DefaultValue: data[4],
        NextParameterNumber: data[5],
        data: data,
    }
}

package commands
type ConfigurationBulkGetV4 struct {
    node byte
    ParameterOffset byte
    NumberofParameters byte
}

func (c *ConfigurationBulkGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationBulkGetV4) Set(ParameterOffset byte,NumberofParameters byte,) error {
    c.ParameterOffset = ParameterOffset
    c.NumberofParameters = NumberofParameters
}

func (c *ConfigurationBulkGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ConfigurationV4),
        0x08,
        ParameterOffset,
        NumberofParameters,
        0x25,
    }
}
type ConfigurationBulkReportV4 struct {
    *report
    node byte
    ParameterOffset byte
    NumberofParameters byte
    Reportstofollow byte
    Properties1 byte
    data []byte
}

func NewConfigurationBulkReportV4(data []byte) *ConfigurationBulkReportV4 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationBulkReportV4{
        ParameterOffset: data[0],
        NumberofParameters: data[1],
        Reportstofollow: data[2],
        Properties1: data[3],
        data: data,
    }
}

type ConfigurationBulkSetV4 struct {
    node byte
    ParameterOffset byte
    NumberofParameters byte
    Properties1 byte
}

func (c *ConfigurationBulkSetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationBulkSetV4) Set(ParameterOffset byte,NumberofParameters byte,Properties1 byte,) error {
    c.ParameterOffset = ParameterOffset
    c.NumberofParameters = NumberofParameters
    c.Properties1 = Properties1
}

func (c *ConfigurationBulkSetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ConfigurationV4),
        0x07,
        ParameterOffset,
        NumberofParameters,
        Properties1,
        0x25,
    }
}
type ConfigurationGetV4 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationGetV4) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV4),
        0x05,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationReportV4 struct {
    *report
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
    data []byte
}

func NewConfigurationReportV4(data []byte) *ConfigurationReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationReportV4{
        ParameterNumber: data[0],
        Level: data[1],
        ConfigurationValue: data[2],
        data: data,
    }
}

type ConfigurationSetV4 struct {
    node byte
    ParameterNumber byte
    Level byte
    ConfigurationValue byte
}

func (c *ConfigurationSetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationSetV4) Set(ParameterNumber byte,Level byte,ConfigurationValue byte,) error {
    c.ParameterNumber = ParameterNumber
    c.Level = Level
    c.ConfigurationValue = ConfigurationValue
}

func (c *ConfigurationSetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ConfigurationV4),
        0x04,
        ParameterNumber,
        Level,
        ConfigurationValue,
        0x25,
    }
}
type ConfigurationNameGetV4 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationNameGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationNameGetV4) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationNameGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV4),
        0x0A,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationNameReportV4 struct {
    *report
    node byte
    ParameterNumber byte
    Reportstofollow byte
    Name byte
    data []byte
}

func NewConfigurationNameReportV4(data []byte) *ConfigurationNameReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationNameReportV4{
        ParameterNumber: data[0],
        Reportstofollow: data[1],
        Name: data[2],
        data: data,
    }
}

type ConfigurationInfoGetV4 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationInfoGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationInfoGetV4) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationInfoGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV4),
        0x0C,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationInfoReportV4 struct {
    *report
    node byte
    ParameterNumber byte
    Reportstofollow byte
    Info byte
    data []byte
}

func NewConfigurationInfoReportV4(data []byte) *ConfigurationInfoReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationInfoReportV4{
        ParameterNumber: data[0],
        Reportstofollow: data[1],
        Info: data[2],
        data: data,
    }
}

type ConfigurationPropertiesGetV4 struct {
    node byte
    ParameterNumber byte
}

func (c *ConfigurationPropertiesGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationPropertiesGetV4) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *ConfigurationPropertiesGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ConfigurationV4),
        0x0E,
        ParameterNumber,
        0x25,
    }
}
type ConfigurationPropertiesReportV4 struct {
    *report
    node byte
    ParameterNumber byte
    Properties1 byte
    MinValue byte
    MaxValue byte
    DefaultValue byte
    NextParameterNumber byte
    Properties2 byte
    data []byte
}

func NewConfigurationPropertiesReportV4(data []byte) *ConfigurationPropertiesReportV4 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &ConfigurationPropertiesReportV4{
        ParameterNumber: data[0],
        Properties1: data[1],
        MinValue: data[2],
        MaxValue: data[3],
        DefaultValue: data[4],
        NextParameterNumber: data[5],
        Properties2: data[6],
        data: data,
    }
}

type ConfigurationDefaultResetV4 struct {
    node byte
}

func (c *ConfigurationDefaultResetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ConfigurationDefaultResetV4) Set() error {
}

func (c *ConfigurationDefaultResetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ConfigurationV4),
        0x01,
        0x25,
    }
}
package commands
type CtrlReplicationTransferGroup struct {
    node byte
    SequenceNumber byte
    GroupID byte
    NodeID byte
}

func (c *CtrlReplicationTransferGroup) SetNode(node int) {
    c.node = byte(node)
}

func (c *CtrlReplicationTransferGroup) Set(SequenceNumber byte,GroupID byte,NodeID byte,) error {
    c.SequenceNumber = SequenceNumber
    c.GroupID = GroupID
    c.NodeID = NodeID
}

func (c *CtrlReplicationTransferGroup) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ControllerReplication),
        0x31,
        SequenceNumber,
        GroupID,
        NodeID,
        0x25,
    }
}
type CtrlReplicationTransferGroupName struct {
    node byte
    SequenceNumber byte
    GroupID byte
    GroupName byte
}

func (c *CtrlReplicationTransferGroupName) SetNode(node int) {
    c.node = byte(node)
}

func (c *CtrlReplicationTransferGroupName) Set(SequenceNumber byte,GroupID byte,GroupName byte,) error {
    c.SequenceNumber = SequenceNumber
    c.GroupID = GroupID
    c.GroupName = GroupName
}

func (c *CtrlReplicationTransferGroupName) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ControllerReplication),
        0x32,
        SequenceNumber,
        GroupID,
        GroupName,
        0x25,
    }
}
type CtrlReplicationTransferScene struct {
    node byte
    SequenceNumber byte
    SceneID byte
    NodeID byte
    Level byte
}

func (c *CtrlReplicationTransferScene) SetNode(node int) {
    c.node = byte(node)
}

func (c *CtrlReplicationTransferScene) Set(SequenceNumber byte,SceneID byte,NodeID byte,Level byte,) error {
    c.SequenceNumber = SequenceNumber
    c.SceneID = SceneID
    c.NodeID = NodeID
    c.Level = Level
}

func (c *CtrlReplicationTransferScene) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(ControllerReplication),
        0x33,
        SequenceNumber,
        SceneID,
        NodeID,
        Level,
        0x25,
    }
}
type CtrlReplicationTransferSceneName struct {
    node byte
    SequenceNumber byte
    SceneID byte
    SceneName byte
}

func (c *CtrlReplicationTransferSceneName) SetNode(node int) {
    c.node = byte(node)
}

func (c *CtrlReplicationTransferSceneName) Set(SequenceNumber byte,SceneID byte,SceneName byte,) error {
    c.SequenceNumber = SequenceNumber
    c.SceneID = SceneID
    c.SceneName = SceneName
}

func (c *CtrlReplicationTransferSceneName) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ControllerReplication),
        0x34,
        SequenceNumber,
        SceneID,
        SceneName,
        0x25,
    }
}
package commands
type Crc16Encap struct {
    node byte
    CommandClass byte
    Command byte
    Data byte
    Checksum byte
}

func (c *Crc16Encap) SetNode(node int) {
    c.node = byte(node)
}

func (c *Crc16Encap) Set(CommandClass byte,Command byte,Data byte,Checksum byte,) error {
    c.CommandClass = CommandClass
    c.Command = Command
    c.Data = Data
    c.Checksum = Checksum
}

func (c *Crc16Encap) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(Crc16Encap),
        0x01,
        CommandClass,
        Command,
        Data,
        Checksum,
        0x25,
    }
}
package commands
type DcpListRemove struct {
    node byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
}

func (c *DcpListRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *DcpListRemove) Set(Year byte,Month byte,Day byte,HourLocalTime byte,MinuteLocalTime byte,SecondLocalTime byte,) error {
    c.Year = Year
    c.Month = Month
    c.Day = Day
    c.HourLocalTime = HourLocalTime
    c.MinuteLocalTime = MinuteLocalTime
    c.SecondLocalTime = SecondLocalTime
}

func (c *DcpListRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(DcpConfig),
        0x04,
        Year,
        Month,
        Day,
        HourLocalTime,
        MinuteLocalTime,
        SecondLocalTime,
        0x25,
    }
}
type DcpListSet struct {
    node byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    DCPRateID byte
    Properties1 byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    DurationHourTime byte
    DurationMinuteTime byte
    DurationSecondTime byte
    EventPriority byte
    Loadshedding byte
    StartAssociationGroup byte
    StopAssociationGroup byte
    Randomizationinterval byte
}

func (c *DcpListSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DcpListSet) Set(Year byte,Month byte,Day byte,HourLocalTime byte,MinuteLocalTime byte,SecondLocalTime byte,DCPRateID byte,Properties1 byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StartSecondLocalTime byte,DurationHourTime byte,DurationMinuteTime byte,DurationSecondTime byte,EventPriority byte,Loadshedding byte,StartAssociationGroup byte,StopAssociationGroup byte,Randomizationinterval byte,) error {
    c.Year = Year
    c.Month = Month
    c.Day = Day
    c.HourLocalTime = HourLocalTime
    c.MinuteLocalTime = MinuteLocalTime
    c.SecondLocalTime = SecondLocalTime
    c.DCPRateID = DCPRateID
    c.Properties1 = Properties1
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StartSecondLocalTime = StartSecondLocalTime
    c.DurationHourTime = DurationHourTime
    c.DurationMinuteTime = DurationMinuteTime
    c.DurationSecondTime = DurationSecondTime
    c.EventPriority = EventPriority
    c.Loadshedding = Loadshedding
    c.StartAssociationGroup = StartAssociationGroup
    c.StopAssociationGroup = StopAssociationGroup
    c.Randomizationinterval = Randomizationinterval
}

func (c *DcpListSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(22),
        byte(DcpConfig),
        0x03,
        Year,
        Month,
        Day,
        HourLocalTime,
        MinuteLocalTime,
        SecondLocalTime,
        DCPRateID,
        Properties1,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StartSecondLocalTime,
        DurationHourTime,
        DurationMinuteTime,
        DurationSecondTime,
        EventPriority,
        Loadshedding,
        StartAssociationGroup,
        StopAssociationGroup,
        Randomizationinterval,
        0x25,
    }
}
type DcpListSupportedGet struct {
    node byte
}

func (c *DcpListSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DcpListSupportedGet) Set() error {
}

func (c *DcpListSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DcpConfig),
        0x01,
        0x25,
    }
}
type DcpListSupportedReport struct {
    *report
    node byte
    DCPListSize byte
    FreeDCPListentries byte
    data []byte
}

func NewDcpListSupportedReport(data []byte) *DcpListSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &DcpListSupportedReport{
        DCPListSize: data[0],
        FreeDCPListentries: data[1],
        data: data,
    }
}

package commands
type DcpEventStatusGet struct {
    node byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
}

func (c *DcpEventStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DcpEventStatusGet) Set(Year byte,Month byte,Day byte,HourLocalTime byte,MinuteLocalTime byte,SecondLocalTime byte,) error {
    c.Year = Year
    c.Month = Month
    c.Day = Day
    c.HourLocalTime = HourLocalTime
    c.MinuteLocalTime = MinuteLocalTime
    c.SecondLocalTime = SecondLocalTime
}

func (c *DcpEventStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(DcpMonitor),
        0x03,
        Year,
        Month,
        Day,
        HourLocalTime,
        MinuteLocalTime,
        SecondLocalTime,
        0x25,
    }
}
type DcpEventStatusReport struct {
    *report
    node byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    Eventstatus byte
    data []byte
}

func NewDcpEventStatusReport(data []byte) *DcpEventStatusReport {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &DcpEventStatusReport{
        Year: data[0],
        Month: data[1],
        Day: data[2],
        HourLocalTime: data[3],
        MinuteLocalTime: data[4],
        SecondLocalTime: data[5],
        Eventstatus: data[6],
        data: data,
    }
}

type DcpListGet struct {
    node byte
}

func (c *DcpListGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DcpListGet) Set() error {
}

func (c *DcpListGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DcpMonitor),
        0x01,
        0x25,
    }
}
type DcpListReport struct {
    *report
    node byte
    ReportstoFollow byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    DCPID byte
    Properties1 byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    DurationHourTime byte
    DurationMinuteTime byte
    DurationSecondTime byte
    EventPriority byte
    Loadshedding byte
    StartAssociationGroup byte
    StopAssociationGroup byte
    Randomizationinterval byte
    data []byte
}

func NewDcpListReport(data []byte) *DcpListReport {
    if len(data) < 23 {
        for i := len(data); i < 23; i++ {
            data = append(data, 0x00)
        }
    }

    return &DcpListReport{
        ReportstoFollow: data[0],
        Year: data[1],
        Month: data[2],
        Day: data[3],
        HourLocalTime: data[4],
        MinuteLocalTime: data[5],
        SecondLocalTime: data[6],
        DCPID: data[7],
        Properties1: data[8],
        StartYear: data[9],
        StartMonth: data[10],
        StartDay: data[11],
        StartHourLocalTime: data[12],
        StartMinuteLocalTime: data[13],
        StartSecondLocalTime: data[14],
        DurationHourTime: data[15],
        DurationMinuteTime: data[16],
        DurationSecondTime: data[17],
        EventPriority: data[18],
        Loadshedding: data[19],
        StartAssociationGroup: data[20],
        StopAssociationGroup: data[21],
        Randomizationinterval: data[22],
        data: data,
    }
}

package commands
type DoorLockLoggingRecordsSupportedGet struct {
    node byte
}

func (c *DoorLockLoggingRecordsSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockLoggingRecordsSupportedGet) Set() error {
}

func (c *DoorLockLoggingRecordsSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLockLogging),
        0x01,
        0x25,
    }
}
type DoorLockLoggingRecordsSupportedReport struct {
    *report
    node byte
    Maxrecordsstored byte
    data []byte
}

func NewDoorLockLoggingRecordsSupportedReport(data []byte) *DoorLockLoggingRecordsSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockLoggingRecordsSupportedReport{
        Maxrecordsstored: data[0],
        data: data,
    }
}

type RecordGet struct {
    node byte
    Recordnumber byte
}

func (c *RecordGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RecordGet) Set(Recordnumber byte,) error {
    c.Recordnumber = Recordnumber
}

func (c *RecordGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(DoorLockLogging),
        0x03,
        Recordnumber,
        0x25,
    }
}
type RecordReport struct {
    *report
    node byte
    Recordnumber byte
    Year byte
    Month byte
    Day byte
    Properties1 byte
    MinuteLocalTime byte
    SecondLocalTime byte
    EventType byte
    UserIdentifier byte
    UserCodeLength byte
    USER_CODE byte
    data []byte
}

func NewRecordReport(data []byte) *RecordReport {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &RecordReport{
        Recordnumber: data[0],
        Year: data[1],
        Month: data[2],
        Day: data[3],
        Properties1: data[4],
        MinuteLocalTime: data[5],
        SecondLocalTime: data[6],
        EventType: data[7],
        UserIdentifier: data[8],
        UserCodeLength: data[9],
        USER_CODE: data[10],
        data: data,
    }
}

package commands
type DoorLockConfigurationGet struct {
    node byte
}

func (c *DoorLockConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockConfigurationGet) Set() error {
}

func (c *DoorLockConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLock),
        0x05,
        0x25,
    }
}
type DoorLockConfigurationReport struct {
    *report
    node byte
    OperationType byte
    Properties1 byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
    data []byte
}

func NewDoorLockConfigurationReport(data []byte) *DoorLockConfigurationReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockConfigurationReport{
        OperationType: data[0],
        Properties1: data[1],
        LockTimeoutMinutes: data[2],
        LockTimeoutSeconds: data[3],
        data: data,
    }
}

type DoorLockConfigurationSet struct {
    node byte
    OperationType byte
    Properties1 byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
}

func (c *DoorLockConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockConfigurationSet) Set(OperationType byte,Properties1 byte,LockTimeoutMinutes byte,LockTimeoutSeconds byte,) error {
    c.OperationType = OperationType
    c.Properties1 = Properties1
    c.LockTimeoutMinutes = LockTimeoutMinutes
    c.LockTimeoutSeconds = LockTimeoutSeconds
}

func (c *DoorLockConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(DoorLock),
        0x04,
        OperationType,
        Properties1,
        LockTimeoutMinutes,
        LockTimeoutSeconds,
        0x25,
    }
}
type DoorLockOperationGet struct {
    node byte
}

func (c *DoorLockOperationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockOperationGet) Set() error {
}

func (c *DoorLockOperationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLock),
        0x02,
        0x25,
    }
}
type DoorLockOperationReport struct {
    *report
    node byte
    DoorLockMode byte
    Properties1 byte
    DoorCondition byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
    data []byte
}

func NewDoorLockOperationReport(data []byte) *DoorLockOperationReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockOperationReport{
        DoorLockMode: data[0],
        Properties1: data[1],
        DoorCondition: data[2],
        LockTimeoutMinutes: data[3],
        LockTimeoutSeconds: data[4],
        data: data,
    }
}

type DoorLockOperationSet struct {
    node byte
    DoorLockMode byte
}

func (c *DoorLockOperationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockOperationSet) Set(DoorLockMode byte,) error {
    c.DoorLockMode = DoorLockMode
}

func (c *DoorLockOperationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(DoorLock),
        0x01,
        DoorLockMode,
        0x25,
    }
}
package commands
type DoorLockConfigurationGetV2 struct {
    node byte
}

func (c *DoorLockConfigurationGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockConfigurationGetV2) Set() error {
}

func (c *DoorLockConfigurationGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLockV2),
        0x05,
        0x25,
    }
}
type DoorLockConfigurationReportV2 struct {
    *report
    node byte
    OperationType byte
    Properties1 byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
    data []byte
}

func NewDoorLockConfigurationReportV2(data []byte) *DoorLockConfigurationReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockConfigurationReportV2{
        OperationType: data[0],
        Properties1: data[1],
        LockTimeoutMinutes: data[2],
        LockTimeoutSeconds: data[3],
        data: data,
    }
}

type DoorLockConfigurationSetV2 struct {
    node byte
    OperationType byte
    Properties1 byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
}

func (c *DoorLockConfigurationSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockConfigurationSetV2) Set(OperationType byte,Properties1 byte,LockTimeoutMinutes byte,LockTimeoutSeconds byte,) error {
    c.OperationType = OperationType
    c.Properties1 = Properties1
    c.LockTimeoutMinutes = LockTimeoutMinutes
    c.LockTimeoutSeconds = LockTimeoutSeconds
}

func (c *DoorLockConfigurationSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(DoorLockV2),
        0x04,
        OperationType,
        Properties1,
        LockTimeoutMinutes,
        LockTimeoutSeconds,
        0x25,
    }
}
type DoorLockOperationGetV2 struct {
    node byte
}

func (c *DoorLockOperationGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockOperationGetV2) Set() error {
}

func (c *DoorLockOperationGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLockV2),
        0x02,
        0x25,
    }
}
type DoorLockOperationReportV2 struct {
    *report
    node byte
    DoorLockMode byte
    Properties1 byte
    DoorCondition byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
    data []byte
}

func NewDoorLockOperationReportV2(data []byte) *DoorLockOperationReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockOperationReportV2{
        DoorLockMode: data[0],
        Properties1: data[1],
        DoorCondition: data[2],
        LockTimeoutMinutes: data[3],
        LockTimeoutSeconds: data[4],
        data: data,
    }
}

type DoorLockOperationSetV2 struct {
    node byte
    DoorLockMode byte
}

func (c *DoorLockOperationSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockOperationSetV2) Set(DoorLockMode byte,) error {
    c.DoorLockMode = DoorLockMode
}

func (c *DoorLockOperationSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(DoorLockV2),
        0x01,
        DoorLockMode,
        0x25,
    }
}
package commands
type DoorLockConfigurationGetV3 struct {
    node byte
}

func (c *DoorLockConfigurationGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockConfigurationGetV3) Set() error {
}

func (c *DoorLockConfigurationGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLockV3),
        0x05,
        0x25,
    }
}
type DoorLockConfigurationReportV3 struct {
    *report
    node byte
    OperationType byte
    Properties1 byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
    data []byte
}

func NewDoorLockConfigurationReportV3(data []byte) *DoorLockConfigurationReportV3 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockConfigurationReportV3{
        OperationType: data[0],
        Properties1: data[1],
        LockTimeoutMinutes: data[2],
        LockTimeoutSeconds: data[3],
        data: data,
    }
}

type DoorLockConfigurationSetV3 struct {
    node byte
    OperationType byte
    Properties1 byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
}

func (c *DoorLockConfigurationSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockConfigurationSetV3) Set(OperationType byte,Properties1 byte,LockTimeoutMinutes byte,LockTimeoutSeconds byte,) error {
    c.OperationType = OperationType
    c.Properties1 = Properties1
    c.LockTimeoutMinutes = LockTimeoutMinutes
    c.LockTimeoutSeconds = LockTimeoutSeconds
}

func (c *DoorLockConfigurationSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(DoorLockV3),
        0x04,
        OperationType,
        Properties1,
        LockTimeoutMinutes,
        LockTimeoutSeconds,
        0x25,
    }
}
type DoorLockOperationGetV3 struct {
    node byte
}

func (c *DoorLockOperationGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockOperationGetV3) Set() error {
}

func (c *DoorLockOperationGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DoorLockV3),
        0x02,
        0x25,
    }
}
type DoorLockOperationReportV3 struct {
    *report
    node byte
    CurrentDoorLockMode byte
    Properties1 byte
    DoorCondition byte
    LockTimeoutMinutes byte
    LockTimeoutSeconds byte
    TargetDoorLockMode byte
    Duration byte
    data []byte
}

func NewDoorLockOperationReportV3(data []byte) *DoorLockOperationReportV3 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &DoorLockOperationReportV3{
        CurrentDoorLockMode: data[0],
        Properties1: data[1],
        DoorCondition: data[2],
        LockTimeoutMinutes: data[3],
        LockTimeoutSeconds: data[4],
        TargetDoorLockMode: data[5],
        Duration: data[6],
        data: data,
    }
}

type DoorLockOperationSetV3 struct {
    node byte
    DoorLockMode byte
}

func (c *DoorLockOperationSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *DoorLockOperationSetV3) Set(DoorLockMode byte,) error {
    c.DoorLockMode = DoorLockMode
}

func (c *DoorLockOperationSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(DoorLockV3),
        0x01,
        DoorLockMode,
        0x25,
    }
}
package commands
type EnergyProductionGet struct {
    node byte
    ParameterNumber byte
}

func (c *EnergyProductionGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *EnergyProductionGet) Set(ParameterNumber byte,) error {
    c.ParameterNumber = ParameterNumber
}

func (c *EnergyProductionGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(EnergyProduction),
        0x02,
        ParameterNumber,
        0x25,
    }
}
type EnergyProductionReport struct {
    *report
    node byte
    ParameterNumber byte
    Level byte
    Value byte
    data []byte
}

func NewEnergyProductionReport(data []byte) *EnergyProductionReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &EnergyProductionReport{
        ParameterNumber: data[0],
        Level: data[1],
        Value: data[2],
        data: data,
    }
}

package commands
type FirmwareMdGet struct {
    node byte
}

func (c *FirmwareMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareMdGet) Set() error {
}

func (c *FirmwareMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(FirmwareUpdateMd),
        0x01,
        0x25,
    }
}
type FirmwareMdReport struct {
    *report
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    data []byte
}

func NewFirmwareMdReport(data []byte) *FirmwareMdReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareMdReport{
        ManufacturerID: data[0],
        FirmwareID: data[1],
        Checksum: data[2],
        data: data,
    }
}

type FirmwareUpdateMdGet struct {
    node byte
    NumberofReports byte
    Properties1 byte
    Reportnumber2 byte
}

func (c *FirmwareUpdateMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdGet) Set(NumberofReports byte,Properties1 byte,Reportnumber2 byte,) error {
    c.NumberofReports = NumberofReports
    c.Properties1 = Properties1
    c.Reportnumber2 = Reportnumber2
}

func (c *FirmwareUpdateMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMd),
        0x05,
        NumberofReports,
        Properties1,
        Reportnumber2,
        0x25,
    }
}
type FirmwareUpdateMdReport struct {
    *report
    node byte
    Properties1 byte
    Reportnumber2 byte
    Data byte
    data []byte
}

func NewFirmwareUpdateMdReport(data []byte) *FirmwareUpdateMdReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdReport{
        Properties1: data[0],
        Reportnumber2: data[1],
        Data: data[2],
        data: data,
    }
}

type FirmwareUpdateMdRequestGet struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
}

func (c *FirmwareUpdateMdRequestGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdRequestGet) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
}

func (c *FirmwareUpdateMdRequestGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMd),
        0x03,
        ManufacturerID,
        FirmwareID,
        Checksum,
        0x25,
    }
}
type FirmwareUpdateMdRequestReport struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdRequestReport(data []byte) *FirmwareUpdateMdRequestReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdRequestReport{
        Status: data[0],
        data: data,
    }
}

type FirmwareUpdateMdStatusReport struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdStatusReport(data []byte) *FirmwareUpdateMdStatusReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdStatusReport{
        Status: data[0],
        data: data,
    }
}

package commands
type FirmwareMdGetV2 struct {
    node byte
}

func (c *FirmwareMdGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareMdGetV2) Set() error {
}

func (c *FirmwareMdGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(FirmwareUpdateMdV2),
        0x01,
        0x25,
    }
}
type FirmwareMdReportV2 struct {
    *report
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    data []byte
}

func NewFirmwareMdReportV2(data []byte) *FirmwareMdReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareMdReportV2{
        ManufacturerID: data[0],
        FirmwareID: data[1],
        Checksum: data[2],
        data: data,
    }
}

type FirmwareUpdateMdGetV2 struct {
    node byte
    NumberofReports byte
    Properties1 byte
    Reportnumber2 byte
}

func (c *FirmwareUpdateMdGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdGetV2) Set(NumberofReports byte,Properties1 byte,Reportnumber2 byte,) error {
    c.NumberofReports = NumberofReports
    c.Properties1 = Properties1
    c.Reportnumber2 = Reportnumber2
}

func (c *FirmwareUpdateMdGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMdV2),
        0x05,
        NumberofReports,
        Properties1,
        Reportnumber2,
        0x25,
    }
}
type FirmwareUpdateMdReportV2 struct {
    *report
    node byte
    Properties1 byte
    Reportnumber2 byte
    Data byte
    Checksum byte
    data []byte
}

func NewFirmwareUpdateMdReportV2(data []byte) *FirmwareUpdateMdReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdReportV2{
        Properties1: data[0],
        Reportnumber2: data[1],
        Data: data[2],
        Checksum: data[3],
        data: data,
    }
}

type FirmwareUpdateMdRequestGetV2 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
}

func (c *FirmwareUpdateMdRequestGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdRequestGetV2) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
}

func (c *FirmwareUpdateMdRequestGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMdV2),
        0x03,
        ManufacturerID,
        FirmwareID,
        Checksum,
        0x25,
    }
}
type FirmwareUpdateMdRequestReportV2 struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdRequestReportV2(data []byte) *FirmwareUpdateMdRequestReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdRequestReportV2{
        Status: data[0],
        data: data,
    }
}

type FirmwareUpdateMdStatusReportV2 struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdStatusReportV2(data []byte) *FirmwareUpdateMdStatusReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdStatusReportV2{
        Status: data[0],
        data: data,
    }
}

package commands
type FirmwareMdGetV3 struct {
    node byte
}

func (c *FirmwareMdGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareMdGetV3) Set() error {
}

func (c *FirmwareMdGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(FirmwareUpdateMdV3),
        0x01,
        0x25,
    }
}
type FirmwareMdReportV3 struct {
    *report
    node byte
    ManufacturerID byte
    Firmware0ID byte
    Firmware0Checksum byte
    FirmwareUpgradable byte
    NumberofFirmwareTargets byte
    MaxFragmentSize byte
    data []byte
}

func NewFirmwareMdReportV3(data []byte) *FirmwareMdReportV3 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareMdReportV3{
        ManufacturerID: data[0],
        Firmware0ID: data[1],
        Firmware0Checksum: data[2],
        FirmwareUpgradable: data[3],
        NumberofFirmwareTargets: data[4],
        MaxFragmentSize: data[5],
        data: data,
    }
}

type FirmwareUpdateMdGetV3 struct {
    node byte
    NumberofReports byte
    Properties1 byte
    Reportnumber2 byte
}

func (c *FirmwareUpdateMdGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdGetV3) Set(NumberofReports byte,Properties1 byte,Reportnumber2 byte,) error {
    c.NumberofReports = NumberofReports
    c.Properties1 = Properties1
    c.Reportnumber2 = Reportnumber2
}

func (c *FirmwareUpdateMdGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMdV3),
        0x05,
        NumberofReports,
        Properties1,
        Reportnumber2,
        0x25,
    }
}
type FirmwareUpdateMdReportV3 struct {
    *report
    node byte
    Properties1 byte
    Reportnumber2 byte
    Data byte
    Checksum byte
    data []byte
}

func NewFirmwareUpdateMdReportV3(data []byte) *FirmwareUpdateMdReportV3 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdReportV3{
        Properties1: data[0],
        Reportnumber2: data[1],
        Data: data[2],
        Checksum: data[3],
        data: data,
    }
}

type FirmwareUpdateMdRequestGetV3 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
    FragmentSize byte
}

func (c *FirmwareUpdateMdRequestGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdRequestGetV3) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,FirmwareTarget byte,FragmentSize byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
    c.FirmwareTarget = FirmwareTarget
    c.FragmentSize = FragmentSize
}

func (c *FirmwareUpdateMdRequestGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(FirmwareUpdateMdV3),
        0x03,
        ManufacturerID,
        FirmwareID,
        Checksum,
        FirmwareTarget,
        FragmentSize,
        0x25,
    }
}
type FirmwareUpdateMdRequestReportV3 struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdRequestReportV3(data []byte) *FirmwareUpdateMdRequestReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdRequestReportV3{
        Status: data[0],
        data: data,
    }
}

type FirmwareUpdateMdStatusReportV3 struct {
    *report
    node byte
    Status byte
    WaitTime byte
    data []byte
}

func NewFirmwareUpdateMdStatusReportV3(data []byte) *FirmwareUpdateMdStatusReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdStatusReportV3{
        Status: data[0],
        WaitTime: data[1],
        data: data,
    }
}

package commands
type FirmwareMdGetV4 struct {
    node byte
}

func (c *FirmwareMdGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareMdGetV4) Set() error {
}

func (c *FirmwareMdGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(FirmwareUpdateMdV4),
        0x01,
        0x25,
    }
}
type FirmwareMdReportV4 struct {
    *report
    node byte
    ManufacturerID byte
    Firmware0ID byte
    Firmware0Checksum byte
    FirmwareUpgradable byte
    NumberofFirmwareTargets byte
    MaxFragmentSize byte
    data []byte
}

func NewFirmwareMdReportV4(data []byte) *FirmwareMdReportV4 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareMdReportV4{
        ManufacturerID: data[0],
        Firmware0ID: data[1],
        Firmware0Checksum: data[2],
        FirmwareUpgradable: data[3],
        NumberofFirmwareTargets: data[4],
        MaxFragmentSize: data[5],
        data: data,
    }
}

type FirmwareUpdateMdGetV4 struct {
    node byte
    NumberofReports byte
    Properties1 byte
    Reportnumber2 byte
}

func (c *FirmwareUpdateMdGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdGetV4) Set(NumberofReports byte,Properties1 byte,Reportnumber2 byte,) error {
    c.NumberofReports = NumberofReports
    c.Properties1 = Properties1
    c.Reportnumber2 = Reportnumber2
}

func (c *FirmwareUpdateMdGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMdV4),
        0x05,
        NumberofReports,
        Properties1,
        Reportnumber2,
        0x25,
    }
}
type FirmwareUpdateMdReportV4 struct {
    *report
    node byte
    Properties1 byte
    Reportnumber2 byte
    Data byte
    Checksum byte
    data []byte
}

func NewFirmwareUpdateMdReportV4(data []byte) *FirmwareUpdateMdReportV4 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdReportV4{
        Properties1: data[0],
        Reportnumber2: data[1],
        Data: data[2],
        Checksum: data[3],
        data: data,
    }
}

type FirmwareUpdateMdRequestGetV4 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
    FragmentSize byte
    Properties1 byte
}

func (c *FirmwareUpdateMdRequestGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdRequestGetV4) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,FirmwareTarget byte,FragmentSize byte,Properties1 byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
    c.FirmwareTarget = FirmwareTarget
    c.FragmentSize = FragmentSize
    c.Properties1 = Properties1
}

func (c *FirmwareUpdateMdRequestGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(FirmwareUpdateMdV4),
        0x03,
        ManufacturerID,
        FirmwareID,
        Checksum,
        FirmwareTarget,
        FragmentSize,
        Properties1,
        0x25,
    }
}
type FirmwareUpdateMdRequestReportV4 struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdRequestReportV4(data []byte) *FirmwareUpdateMdRequestReportV4 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdRequestReportV4{
        Status: data[0],
        data: data,
    }
}

type FirmwareUpdateMdStatusReportV4 struct {
    *report
    node byte
    Status byte
    WaitTime byte
    data []byte
}

func NewFirmwareUpdateMdStatusReportV4(data []byte) *FirmwareUpdateMdStatusReportV4 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdStatusReportV4{
        Status: data[0],
        WaitTime: data[1],
        data: data,
    }
}

type FirmwareUpdateActivationSetV4 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
}

func (c *FirmwareUpdateActivationSetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateActivationSetV4) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,FirmwareTarget byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
    c.FirmwareTarget = FirmwareTarget
}

func (c *FirmwareUpdateActivationSetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(FirmwareUpdateMdV4),
        0x08,
        ManufacturerID,
        FirmwareID,
        Checksum,
        FirmwareTarget,
        0x25,
    }
}
type FirmwareUpdateActivationStatusReportV4 struct {
    *report
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
    FirmwareUpdateStatus byte
    data []byte
}

func NewFirmwareUpdateActivationStatusReportV4(data []byte) *FirmwareUpdateActivationStatusReportV4 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateActivationStatusReportV4{
        ManufacturerID: data[0],
        FirmwareID: data[1],
        Checksum: data[2],
        FirmwareTarget: data[3],
        FirmwareUpdateStatus: data[4],
        data: data,
    }
}

package commands
type FirmwareMdGetV5 struct {
    node byte
}

func (c *FirmwareMdGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareMdGetV5) Set() error {
}

func (c *FirmwareMdGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(FirmwareUpdateMdV5),
        0x01,
        0x25,
    }
}
type FirmwareMdReportV5 struct {
    *report
    node byte
    ManufacturerID byte
    Firmware0ID byte
    Firmware0Checksum byte
    FirmwareUpgradable byte
    NumberofFirmwareTargets byte
    MaxFragmentSize byte
    HardwareVersion byte
    data []byte
}

func NewFirmwareMdReportV5(data []byte) *FirmwareMdReportV5 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareMdReportV5{
        ManufacturerID: data[0],
        Firmware0ID: data[1],
        Firmware0Checksum: data[2],
        FirmwareUpgradable: data[3],
        NumberofFirmwareTargets: data[4],
        MaxFragmentSize: data[5],
        HardwareVersion: data[6],
        data: data,
    }
}

type FirmwareUpdateMdGetV5 struct {
    node byte
    NumberofReports byte
    Properties1 byte
    Reportnumber2 byte
}

func (c *FirmwareUpdateMdGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdGetV5) Set(NumberofReports byte,Properties1 byte,Reportnumber2 byte,) error {
    c.NumberofReports = NumberofReports
    c.Properties1 = Properties1
    c.Reportnumber2 = Reportnumber2
}

func (c *FirmwareUpdateMdGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(FirmwareUpdateMdV5),
        0x05,
        NumberofReports,
        Properties1,
        Reportnumber2,
        0x25,
    }
}
type FirmwareUpdateMdReportV5 struct {
    *report
    node byte
    Properties1 byte
    Reportnumber2 byte
    Data byte
    Checksum byte
    data []byte
}

func NewFirmwareUpdateMdReportV5(data []byte) *FirmwareUpdateMdReportV5 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdReportV5{
        Properties1: data[0],
        Reportnumber2: data[1],
        Data: data[2],
        Checksum: data[3],
        data: data,
    }
}

type FirmwareUpdateMdRequestGetV5 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
    FragmentSize byte
    Properties1 byte
    HardwareVersion byte
}

func (c *FirmwareUpdateMdRequestGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdRequestGetV5) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,FirmwareTarget byte,FragmentSize byte,Properties1 byte,HardwareVersion byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
    c.FirmwareTarget = FirmwareTarget
    c.FragmentSize = FragmentSize
    c.Properties1 = Properties1
    c.HardwareVersion = HardwareVersion
}

func (c *FirmwareUpdateMdRequestGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(7),
        byte(FirmwareUpdateMdV5),
        0x03,
        ManufacturerID,
        FirmwareID,
        Checksum,
        FirmwareTarget,
        FragmentSize,
        Properties1,
        HardwareVersion,
        0x25,
    }
}
type FirmwareUpdateMdRequestReportV5 struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewFirmwareUpdateMdRequestReportV5(data []byte) *FirmwareUpdateMdRequestReportV5 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdRequestReportV5{
        Status: data[0],
        data: data,
    }
}

type FirmwareUpdateMdStatusReportV5 struct {
    *report
    node byte
    Status byte
    WaitTime byte
    data []byte
}

func NewFirmwareUpdateMdStatusReportV5(data []byte) *FirmwareUpdateMdStatusReportV5 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdStatusReportV5{
        Status: data[0],
        WaitTime: data[1],
        data: data,
    }
}

type FirmwareUpdateActivationSetV5 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
    HardwareVersion byte
}

func (c *FirmwareUpdateActivationSetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateActivationSetV5) Set(ManufacturerID byte,FirmwareID byte,Checksum byte,FirmwareTarget byte,HardwareVersion byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.Checksum = Checksum
    c.FirmwareTarget = FirmwareTarget
    c.HardwareVersion = HardwareVersion
}

func (c *FirmwareUpdateActivationSetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(FirmwareUpdateMdV5),
        0x08,
        ManufacturerID,
        FirmwareID,
        Checksum,
        FirmwareTarget,
        HardwareVersion,
        0x25,
    }
}
type FirmwareUpdateActivationStatusReportV5 struct {
    *report
    node byte
    ManufacturerID byte
    FirmwareID byte
    Checksum byte
    FirmwareTarget byte
    FirmwareUpdateStatus byte
    HardwareVersion byte
    data []byte
}

func NewFirmwareUpdateActivationStatusReportV5(data []byte) *FirmwareUpdateActivationStatusReportV5 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateActivationStatusReportV5{
        ManufacturerID: data[0],
        FirmwareID: data[1],
        Checksum: data[2],
        FirmwareTarget: data[3],
        FirmwareUpdateStatus: data[4],
        HardwareVersion: data[5],
        data: data,
    }
}

type FirmwareUpdateMdPrepareGetV5 struct {
    node byte
    ManufacturerID byte
    FirmwareID byte
    FirmwareTarget byte
    FragmentSize byte
    HardwareVersion byte
}

func (c *FirmwareUpdateMdPrepareGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *FirmwareUpdateMdPrepareGetV5) Set(ManufacturerID byte,FirmwareID byte,FirmwareTarget byte,FragmentSize byte,HardwareVersion byte,) error {
    c.ManufacturerID = ManufacturerID
    c.FirmwareID = FirmwareID
    c.FirmwareTarget = FirmwareTarget
    c.FragmentSize = FragmentSize
    c.HardwareVersion = HardwareVersion
}

func (c *FirmwareUpdateMdPrepareGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(FirmwareUpdateMdV5),
        0x0A,
        ManufacturerID,
        FirmwareID,
        FirmwareTarget,
        FragmentSize,
        HardwareVersion,
        0x25,
    }
}
type FirmwareUpdateMdPrepareReportV5 struct {
    *report
    node byte
    Status byte
    FirmwareChecksum byte
    data []byte
}

func NewFirmwareUpdateMdPrepareReportV5(data []byte) *FirmwareUpdateMdPrepareReportV5 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &FirmwareUpdateMdPrepareReportV5{
        Status: data[0],
        FirmwareChecksum: data[1],
        data: data,
    }
}

package commands
type GeographicLocationGet struct {
    node byte
}

func (c *GeographicLocationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GeographicLocationGet) Set() error {
}

func (c *GeographicLocationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(GeographicLocation),
        0x02,
        0x25,
    }
}
type GeographicLocationReport struct {
    *report
    node byte
    LongitudeDegrees byte
    Level byte
    LatitudeDegrees byte
    Level2 byte
    data []byte
}

func NewGeographicLocationReport(data []byte) *GeographicLocationReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &GeographicLocationReport{
        LongitudeDegrees: data[0],
        Level: data[1],
        LatitudeDegrees: data[2],
        Level2: data[3],
        data: data,
    }
}

type GeographicLocationSet struct {
    node byte
    LongitudeDegrees byte
    Level byte
    LatitudeDegrees byte
    Level2 byte
}

func (c *GeographicLocationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GeographicLocationSet) Set(LongitudeDegrees byte,Level byte,LatitudeDegrees byte,Level2 byte,) error {
    c.LongitudeDegrees = LongitudeDegrees
    c.Level = Level
    c.LatitudeDegrees = LatitudeDegrees
    c.Level2 = Level2
}

func (c *GeographicLocationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(GeographicLocation),
        0x01,
        LongitudeDegrees,
        Level,
        LatitudeDegrees,
        Level2,
        0x25,
    }
}
package commands
type GroupingNameGet struct {
    node byte
    Groupingidentifier byte
}

func (c *GroupingNameGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GroupingNameGet) Set(Groupingidentifier byte,) error {
    c.Groupingidentifier = Groupingidentifier
}

func (c *GroupingNameGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(GroupingName),
        0x02,
        Groupingidentifier,
        0x25,
    }
}
type GroupingNameReport struct {
    *report
    node byte
    Groupingidentifier byte
    Properties1 byte
    GroupingName byte
    data []byte
}

func NewGroupingNameReport(data []byte) *GroupingNameReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &GroupingNameReport{
        Groupingidentifier: data[0],
        Properties1: data[1],
        GroupingName: data[2],
        data: data,
    }
}

type GroupingNameSet struct {
    node byte
    Groupingidentifier byte
    Properties1 byte
    GroupingName byte
}

func (c *GroupingNameSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GroupingNameSet) Set(Groupingidentifier byte,Properties1 byte,GroupingName byte,) error {
    c.Groupingidentifier = Groupingidentifier
    c.Properties1 = Properties1
    c.GroupingName = GroupingName
}

func (c *GroupingNameSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(GroupingName),
        0x01,
        Groupingidentifier,
        Properties1,
        GroupingName,
        0x25,
    }
}
package commands
type Hail struct {
    node byte
}

func (c *Hail) SetNode(node int) {
    c.node = byte(node)
}

func (c *Hail) Set() error {
}

func (c *Hail) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Hail),
        0x01,
        0x25,
    }
}
package commands
type HrvControlBypassGet struct {
    node byte
}

func (c *HrvControlBypassGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlBypassGet) Set() error {
}

func (c *HrvControlBypassGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HrvControl),
        0x05,
        0x25,
    }
}
type HrvControlBypassReport struct {
    *report
    node byte
    Bypass byte
    data []byte
}

func NewHrvControlBypassReport(data []byte) *HrvControlBypassReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HrvControlBypassReport{
        Bypass: data[0],
        data: data,
    }
}

type HrvControlBypassSet struct {
    node byte
    Bypass byte
}

func (c *HrvControlBypassSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlBypassSet) Set(Bypass byte,) error {
    c.Bypass = Bypass
}

func (c *HrvControlBypassSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HrvControl),
        0x04,
        Bypass,
        0x25,
    }
}
type HrvControlModeGet struct {
    node byte
}

func (c *HrvControlModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlModeGet) Set() error {
}

func (c *HrvControlModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HrvControl),
        0x02,
        0x25,
    }
}
type HrvControlModeReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewHrvControlModeReport(data []byte) *HrvControlModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HrvControlModeReport{
        Properties1: data[0],
        data: data,
    }
}

type HrvControlModeSet struct {
    node byte
    Properties1 byte
}

func (c *HrvControlModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlModeSet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *HrvControlModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HrvControl),
        0x01,
        Properties1,
        0x25,
    }
}
type HrvControlModeSupportedGet struct {
    node byte
}

func (c *HrvControlModeSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlModeSupportedGet) Set() error {
}

func (c *HrvControlModeSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HrvControl),
        0x0A,
        0x25,
    }
}
type HrvControlModeSupportedReport struct {
    *report
    node byte
    Properties1 byte
    BitMask byte
    data []byte
}

func NewHrvControlModeSupportedReport(data []byte) *HrvControlModeSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &HrvControlModeSupportedReport{
        Properties1: data[0],
        BitMask: data[1],
        data: data,
    }
}

type HrvControlVentilationRateGet struct {
    node byte
}

func (c *HrvControlVentilationRateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlVentilationRateGet) Set() error {
}

func (c *HrvControlVentilationRateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HrvControl),
        0x08,
        0x25,
    }
}
type HrvControlVentilationRateReport struct {
    *report
    node byte
    VentilationRate byte
    data []byte
}

func NewHrvControlVentilationRateReport(data []byte) *HrvControlVentilationRateReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HrvControlVentilationRateReport{
        VentilationRate: data[0],
        data: data,
    }
}

type HrvControlVentilationRateSet struct {
    node byte
    VentilationRate byte
}

func (c *HrvControlVentilationRateSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvControlVentilationRateSet) Set(VentilationRate byte,) error {
    c.VentilationRate = VentilationRate
}

func (c *HrvControlVentilationRateSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HrvControl),
        0x07,
        VentilationRate,
        0x25,
    }
}
package commands
type HrvStatusGet struct {
    node byte
    StatusParameter byte
}

func (c *HrvStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvStatusGet) Set(StatusParameter byte,) error {
    c.StatusParameter = StatusParameter
}

func (c *HrvStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HrvStatus),
        0x01,
        StatusParameter,
        0x25,
    }
}
type HrvStatusReport struct {
    *report
    node byte
    StatusParameter byte
    Properties1 byte
    Value byte
    data []byte
}

func NewHrvStatusReport(data []byte) *HrvStatusReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &HrvStatusReport{
        StatusParameter: data[0],
        Properties1: data[1],
        Value: data[2],
        data: data,
    }
}

type HrvStatusSupportedGet struct {
    node byte
}

func (c *HrvStatusSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HrvStatusSupportedGet) Set() error {
}

func (c *HrvStatusSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HrvStatus),
        0x03,
        0x25,
    }
}
type HrvStatusSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewHrvStatusSupportedReport(data []byte) *HrvStatusSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HrvStatusSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

package commands
type IndicatorGet struct {
    node byte
}

func (c *IndicatorGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IndicatorGet) Set() error {
}

func (c *IndicatorGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Indicator),
        0x02,
        0x25,
    }
}
type IndicatorReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewIndicatorReport(data []byte) *IndicatorReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &IndicatorReport{
        Value: data[0],
        data: data,
    }
}

type IndicatorSet struct {
    node byte
    Value byte
}

func (c *IndicatorSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IndicatorSet) Set(Value byte,) error {
    c.Value = Value
}

func (c *IndicatorSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Indicator),
        0x01,
        Value,
        0x25,
    }
}
package commands
type IndicatorGetV2 struct {
    node byte
    IndicatorID byte
}

func (c *IndicatorGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *IndicatorGetV2) Set(IndicatorID byte,) error {
    c.IndicatorID = IndicatorID
}

func (c *IndicatorGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(IndicatorV2),
        0x02,
        IndicatorID,
        0x25,
    }
}
type IndicatorReportV2 struct {
    *report
    node byte
    Indicator0Value byte
    Properties1 byte
    data []byte
}

func NewIndicatorReportV2(data []byte) *IndicatorReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &IndicatorReportV2{
        Indicator0Value: data[0],
        Properties1: data[1],
        data: data,
    }
}

type IndicatorSetV2 struct {
    node byte
    Indicator0Value byte
    Properties1 byte
}

func (c *IndicatorSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *IndicatorSetV2) Set(Indicator0Value byte,Properties1 byte,) error {
    c.Indicator0Value = Indicator0Value
    c.Properties1 = Properties1
}

func (c *IndicatorSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(IndicatorV2),
        0x01,
        Indicator0Value,
        Properties1,
        0x25,
    }
}
type IndicatorSupportedGetV2 struct {
    node byte
    IndicatorID byte
}

func (c *IndicatorSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *IndicatorSupportedGetV2) Set(IndicatorID byte,) error {
    c.IndicatorID = IndicatorID
}

func (c *IndicatorSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(IndicatorV2),
        0x04,
        IndicatorID,
        0x25,
    }
}
type IndicatorSupportedReportV2 struct {
    *report
    node byte
    IndicatorID byte
    NextIndicatorID byte
    Properties1 byte
    PropertySupportedBitMask byte
    data []byte
}

func NewIndicatorSupportedReportV2(data []byte) *IndicatorSupportedReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &IndicatorSupportedReportV2{
        IndicatorID: data[0],
        NextIndicatorID: data[1],
        Properties1: data[2],
        PropertySupportedBitMask: data[3],
        data: data,
    }
}

package commands
type IpConfigurationGet struct {
    node byte
}

func (c *IpConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpConfigurationGet) Set() error {
}

func (c *IpConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(IpConfiguration),
        0x02,
        0x25,
    }
}
type IpConfigurationRelease struct {
    node byte
}

func (c *IpConfigurationRelease) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpConfigurationRelease) Set() error {
}

func (c *IpConfigurationRelease) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(IpConfiguration),
        0x04,
        0x25,
    }
}
type IpConfigurationRenew struct {
    node byte
}

func (c *IpConfigurationRenew) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpConfigurationRenew) Set() error {
}

func (c *IpConfigurationRenew) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(IpConfiguration),
        0x05,
        0x25,
    }
}
type IpConfigurationReport struct {
    *report
    node byte
    Properties1 byte
    IPAddress byte
    SubnetMask byte
    Gateway byte
    DNS1 byte
    DNS2 byte
    LeaseTime byte
    data []byte
}

func NewIpConfigurationReport(data []byte) *IpConfigurationReport {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &IpConfigurationReport{
        Properties1: data[0],
        IPAddress: data[1],
        SubnetMask: data[2],
        Gateway: data[3],
        DNS1: data[4],
        DNS2: data[5],
        LeaseTime: data[6],
        data: data,
    }
}

type IpConfigurationSet struct {
    node byte
    Properties1 byte
    IPAddress byte
    SubnetMask byte
    Gateway byte
    DNS1 byte
    DNS2 byte
}

func (c *IpConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpConfigurationSet) Set(Properties1 byte,IPAddress byte,SubnetMask byte,Gateway byte,DNS1 byte,DNS2 byte,) error {
    c.Properties1 = Properties1
    c.IPAddress = IPAddress
    c.SubnetMask = SubnetMask
    c.Gateway = Gateway
    c.DNS1 = DNS1
    c.DNS2 = DNS2
}

func (c *IpConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(IpConfiguration),
        0x01,
        Properties1,
        IPAddress,
        SubnetMask,
        Gateway,
        DNS1,
        DNS2,
        0x25,
    }
}
package commands
type LanguageGet struct {
    node byte
}

func (c *LanguageGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LanguageGet) Set() error {
}

func (c *LanguageGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Language),
        0x02,
        0x25,
    }
}
type LanguageReport struct {
    *report
    node byte
    Language byte
    Country byte
    data []byte
}

func NewLanguageReport(data []byte) *LanguageReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &LanguageReport{
        Language: data[0],
        Country: data[1],
        data: data,
    }
}

type LanguageSet struct {
    node byte
    Language byte
    Country byte
}

func (c *LanguageSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LanguageSet) Set(Language byte,Country byte,) error {
    c.Language = Language
    c.Country = Country
}

func (c *LanguageSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Language),
        0x01,
        Language,
        Country,
        0x25,
    }
}
package commands
type LockGet struct {
    node byte
}

func (c *LockGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LockGet) Set() error {
}

func (c *LockGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Lock),
        0x02,
        0x25,
    }
}
type LockReport struct {
    *report
    node byte
    LockState byte
    data []byte
}

func NewLockReport(data []byte) *LockReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &LockReport{
        LockState: data[0],
        data: data,
    }
}

type LockSet struct {
    node byte
    LockState byte
}

func (c *LockSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LockSet) Set(LockState byte,) error {
    c.LockState = LockState
}

func (c *LockSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Lock),
        0x01,
        LockState,
        0x25,
    }
}
package commands
type ManufacturerSpecificGet struct {
    node byte
}

func (c *ManufacturerSpecificGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ManufacturerSpecificGet) Set() error {
}

func (c *ManufacturerSpecificGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ManufacturerSpecific),
        0x04,
        0x25,
    }
}
type ManufacturerSpecificReport struct {
    *report
    node byte
    ManufacturerID byte
    ProductTypeID byte
    ProductID byte
    data []byte
}

func NewManufacturerSpecificReport(data []byte) *ManufacturerSpecificReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ManufacturerSpecificReport{
        ManufacturerID: data[0],
        ProductTypeID: data[1],
        ProductID: data[2],
        data: data,
    }
}

package commands
type ManufacturerSpecificGetV2 struct {
    node byte
}

func (c *ManufacturerSpecificGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ManufacturerSpecificGetV2) Set() error {
}

func (c *ManufacturerSpecificGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ManufacturerSpecificV2),
        0x04,
        0x25,
    }
}
type ManufacturerSpecificReportV2 struct {
    *report
    node byte
    ManufacturerID byte
    ProductTypeID byte
    ProductID byte
    data []byte
}

func NewManufacturerSpecificReportV2(data []byte) *ManufacturerSpecificReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ManufacturerSpecificReportV2{
        ManufacturerID: data[0],
        ProductTypeID: data[1],
        ProductID: data[2],
        data: data,
    }
}

type DeviceSpecificGetV2 struct {
    node byte
    Properties1 byte
}

func (c *DeviceSpecificGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DeviceSpecificGetV2) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *DeviceSpecificGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ManufacturerSpecificV2),
        0x06,
        Properties1,
        0x25,
    }
}
type DeviceSpecificReportV2 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    DeviceIDData byte
    data []byte
}

func NewDeviceSpecificReportV2(data []byte) *DeviceSpecificReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &DeviceSpecificReportV2{
        Properties1: data[0],
        Properties2: data[1],
        DeviceIDData: data[2],
        data: data,
    }
}

package commands
type MeterPulseGet struct {
    node byte
}

func (c *MeterPulseGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterPulseGet) Set() error {
}

func (c *MeterPulseGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterPulse),
        0x04,
        0x25,
    }
}
type MeterPulseReport struct {
    *report
    node byte
    PulseCount byte
    data []byte
}

func NewMeterPulseReport(data []byte) *MeterPulseReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterPulseReport{
        PulseCount: data[0],
        data: data,
    }
}

package commands
type MeterTblTablePointAdmNoSet struct {
    node byte
    Properties1 byte
    MeterPointAdmNumberCharacter byte
}

func (c *MeterTblTablePointAdmNoSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTablePointAdmNoSet) Set(Properties1 byte,MeterPointAdmNumberCharacter byte,) error {
    c.Properties1 = Properties1
    c.MeterPointAdmNumberCharacter = MeterPointAdmNumberCharacter
}

func (c *MeterTblTablePointAdmNoSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(MeterTblConfig),
        0x01,
        Properties1,
        MeterPointAdmNumberCharacter,
        0x25,
    }
}
package commands
type MeterTblStatusReport struct {
    *report
    node byte
    Reportstofollow byte
    CurrentOperatingStatus byte
    data []byte
}

func NewMeterTblStatusReport(data []byte) *MeterTblStatusReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblStatusReport{
        Reportstofollow: data[0],
        CurrentOperatingStatus: data[1],
        data: data,
    }
}

type MeterTblStatusDateGet struct {
    node byte
    MaximumReports byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
    StopSecondLocalTime byte
}

func (c *MeterTblStatusDateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblStatusDateGet) Set(MaximumReports byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StartSecondLocalTime byte,StopYear byte,StopMonth byte,StopDay byte,StopHourLocalTime byte,StopMinuteLocalTime byte,StopSecondLocalTime byte,) error {
    c.MaximumReports = MaximumReports
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StartSecondLocalTime = StartSecondLocalTime
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHourLocalTime = StopHourLocalTime
    c.StopMinuteLocalTime = StopMinuteLocalTime
    c.StopSecondLocalTime = StopSecondLocalTime
}

func (c *MeterTblStatusDateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(13),
        byte(MeterTblMonitor),
        0x0A,
        MaximumReports,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StartSecondLocalTime,
        StopYear,
        StopMonth,
        StopDay,
        StopHourLocalTime,
        StopMinuteLocalTime,
        StopSecondLocalTime,
        0x25,
    }
}
type MeterTblStatusDepthGet struct {
    node byte
    StatusEventLogDepth byte
}

func (c *MeterTblStatusDepthGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblStatusDepthGet) Set(StatusEventLogDepth byte,) error {
    c.StatusEventLogDepth = StatusEventLogDepth
}

func (c *MeterTblStatusDepthGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MeterTblMonitor),
        0x09,
        StatusEventLogDepth,
        0x25,
    }
}
type MeterTblStatusSupportedGet struct {
    node byte
}

func (c *MeterTblStatusSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblStatusSupportedGet) Set() error {
}

func (c *MeterTblStatusSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitor),
        0x07,
        0x25,
    }
}
type MeterTblStatusSupportedReport struct {
    *report
    node byte
    SupportedOperatingStatus byte
    StatusEventLogDepth byte
    data []byte
}

func NewMeterTblStatusSupportedReport(data []byte) *MeterTblStatusSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblStatusSupportedReport{
        SupportedOperatingStatus: data[0],
        StatusEventLogDepth: data[1],
        data: data,
    }
}

type MeterTblCurrentDataGet struct {
    node byte
    DatasetRequested byte
}

func (c *MeterTblCurrentDataGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblCurrentDataGet) Set(DatasetRequested byte,) error {
    c.DatasetRequested = DatasetRequested
}

func (c *MeterTblCurrentDataGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MeterTblMonitor),
        0x0C,
        DatasetRequested,
        0x25,
    }
}
type MeterTblCurrentDataReport struct {
    *report
    node byte
    ReportstoFollow byte
    Properties1 byte
    Dataset byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewMeterTblCurrentDataReport(data []byte) *MeterTblCurrentDataReport {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblCurrentDataReport{
        ReportstoFollow: data[0],
        Properties1: data[1],
        Dataset: data[2],
        Year: data[3],
        Month: data[4],
        Day: data[5],
        HourLocalTime: data[6],
        MinuteLocalTime: data[7],
        SecondLocalTime: data[8],
        data: data,
    }
}

type MeterTblHistoricalDataGet struct {
    node byte
    MaximumReports byte
    HistoricalDatasetRequested byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
    StopSecondLocalTime byte
}

func (c *MeterTblHistoricalDataGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblHistoricalDataGet) Set(MaximumReports byte,HistoricalDatasetRequested byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StartSecondLocalTime byte,StopYear byte,StopMonth byte,StopDay byte,StopHourLocalTime byte,StopMinuteLocalTime byte,StopSecondLocalTime byte,) error {
    c.MaximumReports = MaximumReports
    c.HistoricalDatasetRequested = HistoricalDatasetRequested
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StartSecondLocalTime = StartSecondLocalTime
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHourLocalTime = StopHourLocalTime
    c.StopMinuteLocalTime = StopMinuteLocalTime
    c.StopSecondLocalTime = StopSecondLocalTime
}

func (c *MeterTblHistoricalDataGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(14),
        byte(MeterTblMonitor),
        0x0E,
        MaximumReports,
        HistoricalDatasetRequested,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StartSecondLocalTime,
        StopYear,
        StopMonth,
        StopDay,
        StopHourLocalTime,
        StopMinuteLocalTime,
        StopSecondLocalTime,
        0x25,
    }
}
type MeterTblHistoricalDataReport struct {
    *report
    node byte
    ReportstoFollow byte
    Properties1 byte
    Dataset byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewMeterTblHistoricalDataReport(data []byte) *MeterTblHistoricalDataReport {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblHistoricalDataReport{
        ReportstoFollow: data[0],
        Properties1: data[1],
        Dataset: data[2],
        Year: data[3],
        Month: data[4],
        Day: data[5],
        HourLocalTime: data[6],
        MinuteLocalTime: data[7],
        SecondLocalTime: data[8],
        data: data,
    }
}

type MeterTblReport struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    DatasetSupported byte
    DatasetHistorySupported byte
    DataHistorySupported byte
    data []byte
}

func NewMeterTblReport(data []byte) *MeterTblReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblReport{
        Properties1: data[0],
        Properties2: data[1],
        DatasetSupported: data[2],
        DatasetHistorySupported: data[3],
        DataHistorySupported: data[4],
        data: data,
    }
}

type MeterTblTableCapabilityGet struct {
    node byte
}

func (c *MeterTblTableCapabilityGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTableCapabilityGet) Set() error {
}

func (c *MeterTblTableCapabilityGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitor),
        0x05,
        0x25,
    }
}
type MeterTblTableIdGet struct {
    node byte
}

func (c *MeterTblTableIdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTableIdGet) Set() error {
}

func (c *MeterTblTableIdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitor),
        0x03,
        0x25,
    }
}
type MeterTblTableIdReport struct {
    *report
    node byte
    Properties1 byte
    MeterIDCharacter byte
    data []byte
}

func NewMeterTblTableIdReport(data []byte) *MeterTblTableIdReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblTableIdReport{
        Properties1: data[0],
        MeterIDCharacter: data[1],
        data: data,
    }
}

type MeterTblTablePointAdmNoGet struct {
    node byte
}

func (c *MeterTblTablePointAdmNoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTablePointAdmNoGet) Set() error {
}

func (c *MeterTblTablePointAdmNoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitor),
        0x01,
        0x25,
    }
}
type MeterTblTablePointAdmNoReport struct {
    *report
    node byte
    Properties1 byte
    MeterPointAdmNumberCharacter byte
    data []byte
}

func NewMeterTblTablePointAdmNoReport(data []byte) *MeterTblTablePointAdmNoReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblTablePointAdmNoReport{
        Properties1: data[0],
        MeterPointAdmNumberCharacter: data[1],
        data: data,
    }
}

package commands
type MeterTblStatusReportV2 struct {
    *report
    node byte
    Reportstofollow byte
    CurrentOperatingStatus byte
    data []byte
}

func NewMeterTblStatusReportV2(data []byte) *MeterTblStatusReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblStatusReportV2{
        Reportstofollow: data[0],
        CurrentOperatingStatus: data[1],
        data: data,
    }
}

type MeterTblStatusDateGetV2 struct {
    node byte
    MaximumReports byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
    StopSecondLocalTime byte
}

func (c *MeterTblStatusDateGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblStatusDateGetV2) Set(MaximumReports byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StartSecondLocalTime byte,StopYear byte,StopMonth byte,StopDay byte,StopHourLocalTime byte,StopMinuteLocalTime byte,StopSecondLocalTime byte,) error {
    c.MaximumReports = MaximumReports
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StartSecondLocalTime = StartSecondLocalTime
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHourLocalTime = StopHourLocalTime
    c.StopMinuteLocalTime = StopMinuteLocalTime
    c.StopSecondLocalTime = StopSecondLocalTime
}

func (c *MeterTblStatusDateGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(13),
        byte(MeterTblMonitorV2),
        0x0A,
        MaximumReports,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StartSecondLocalTime,
        StopYear,
        StopMonth,
        StopDay,
        StopHourLocalTime,
        StopMinuteLocalTime,
        StopSecondLocalTime,
        0x25,
    }
}
type MeterTblStatusDepthGetV2 struct {
    node byte
    StatusEventLogDepth byte
}

func (c *MeterTblStatusDepthGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblStatusDepthGetV2) Set(StatusEventLogDepth byte,) error {
    c.StatusEventLogDepth = StatusEventLogDepth
}

func (c *MeterTblStatusDepthGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MeterTblMonitorV2),
        0x09,
        StatusEventLogDepth,
        0x25,
    }
}
type MeterTblStatusSupportedGetV2 struct {
    node byte
}

func (c *MeterTblStatusSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblStatusSupportedGetV2) Set() error {
}

func (c *MeterTblStatusSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitorV2),
        0x07,
        0x25,
    }
}
type MeterTblStatusSupportedReportV2 struct {
    *report
    node byte
    SupportedOperatingStatus byte
    StatusEventLogDepth byte
    data []byte
}

func NewMeterTblStatusSupportedReportV2(data []byte) *MeterTblStatusSupportedReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblStatusSupportedReportV2{
        SupportedOperatingStatus: data[0],
        StatusEventLogDepth: data[1],
        data: data,
    }
}

type MeterTblCurrentDataGetV2 struct {
    node byte
    DatasetRequested byte
}

func (c *MeterTblCurrentDataGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblCurrentDataGetV2) Set(DatasetRequested byte,) error {
    c.DatasetRequested = DatasetRequested
}

func (c *MeterTblCurrentDataGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MeterTblMonitorV2),
        0x0C,
        DatasetRequested,
        0x25,
    }
}
type MeterTblCurrentDataReportV2 struct {
    *report
    node byte
    ReportstoFollow byte
    Properties1 byte
    Dataset byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewMeterTblCurrentDataReportV2(data []byte) *MeterTblCurrentDataReportV2 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblCurrentDataReportV2{
        ReportstoFollow: data[0],
        Properties1: data[1],
        Dataset: data[2],
        Year: data[3],
        Month: data[4],
        Day: data[5],
        HourLocalTime: data[6],
        MinuteLocalTime: data[7],
        SecondLocalTime: data[8],
        data: data,
    }
}

type MeterTblHistoricalDataGetV2 struct {
    node byte
    MaximumReports byte
    HistoricalDatasetRequested byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
    StopSecondLocalTime byte
}

func (c *MeterTblHistoricalDataGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblHistoricalDataGetV2) Set(MaximumReports byte,HistoricalDatasetRequested byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StartSecondLocalTime byte,StopYear byte,StopMonth byte,StopDay byte,StopHourLocalTime byte,StopMinuteLocalTime byte,StopSecondLocalTime byte,) error {
    c.MaximumReports = MaximumReports
    c.HistoricalDatasetRequested = HistoricalDatasetRequested
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StartSecondLocalTime = StartSecondLocalTime
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHourLocalTime = StopHourLocalTime
    c.StopMinuteLocalTime = StopMinuteLocalTime
    c.StopSecondLocalTime = StopSecondLocalTime
}

func (c *MeterTblHistoricalDataGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(14),
        byte(MeterTblMonitorV2),
        0x0E,
        MaximumReports,
        HistoricalDatasetRequested,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StartSecondLocalTime,
        StopYear,
        StopMonth,
        StopDay,
        StopHourLocalTime,
        StopMinuteLocalTime,
        StopSecondLocalTime,
        0x25,
    }
}
type MeterTblHistoricalDataReportV2 struct {
    *report
    node byte
    ReportstoFollow byte
    Properties1 byte
    Dataset byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewMeterTblHistoricalDataReportV2(data []byte) *MeterTblHistoricalDataReportV2 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblHistoricalDataReportV2{
        ReportstoFollow: data[0],
        Properties1: data[1],
        Dataset: data[2],
        Year: data[3],
        Month: data[4],
        Day: data[5],
        HourLocalTime: data[6],
        MinuteLocalTime: data[7],
        SecondLocalTime: data[8],
        data: data,
    }
}

type MeterTblReportV2 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    DatasetSupported byte
    DatasetHistorySupported byte
    DataHistorySupported byte
    data []byte
}

func NewMeterTblReportV2(data []byte) *MeterTblReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblReportV2{
        Properties1: data[0],
        Properties2: data[1],
        DatasetSupported: data[2],
        DatasetHistorySupported: data[3],
        DataHistorySupported: data[4],
        data: data,
    }
}

type MeterTblTableCapabilityGetV2 struct {
    node byte
}

func (c *MeterTblTableCapabilityGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTableCapabilityGetV2) Set() error {
}

func (c *MeterTblTableCapabilityGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitorV2),
        0x05,
        0x25,
    }
}
type MeterTblTableIdGetV2 struct {
    node byte
}

func (c *MeterTblTableIdGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTableIdGetV2) Set() error {
}

func (c *MeterTblTableIdGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitorV2),
        0x03,
        0x25,
    }
}
type MeterTblTableIdReportV2 struct {
    *report
    node byte
    Properties1 byte
    MeterIDCharacter byte
    data []byte
}

func NewMeterTblTableIdReportV2(data []byte) *MeterTblTableIdReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblTableIdReportV2{
        Properties1: data[0],
        MeterIDCharacter: data[1],
        data: data,
    }
}

type MeterTblTablePointAdmNoGetV2 struct {
    node byte
}

func (c *MeterTblTablePointAdmNoGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblTablePointAdmNoGetV2) Set() error {
}

func (c *MeterTblTablePointAdmNoGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblMonitorV2),
        0x01,
        0x25,
    }
}
type MeterTblTablePointAdmNoReportV2 struct {
    *report
    node byte
    Properties1 byte
    MeterPointAdmNumberCharacter byte
    data []byte
}

func NewMeterTblTablePointAdmNoReportV2(data []byte) *MeterTblTablePointAdmNoReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblTablePointAdmNoReportV2{
        Properties1: data[0],
        MeterPointAdmNumberCharacter: data[1],
        data: data,
    }
}

package commands
type MeterTblPushConfigurationGet struct {
    node byte
}

func (c *MeterTblPushConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblPushConfigurationGet) Set() error {
}

func (c *MeterTblPushConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterTblPush),
        0x02,
        0x25,
    }
}
type MeterTblPushConfigurationReport struct {
    *report
    node byte
    Properties1 byte
    PushDataset byte
    IntervalMonths byte
    IntervalDays byte
    IntervalHours byte
    IntervalMinutes byte
    PushNodeID byte
    data []byte
}

func NewMeterTblPushConfigurationReport(data []byte) *MeterTblPushConfigurationReport {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterTblPushConfigurationReport{
        Properties1: data[0],
        PushDataset: data[1],
        IntervalMonths: data[2],
        IntervalDays: data[3],
        IntervalHours: data[4],
        IntervalMinutes: data[5],
        PushNodeID: data[6],
        data: data,
    }
}

type MeterTblPushConfigurationSet struct {
    node byte
    Properties1 byte
    PushDataset byte
    IntervalMonths byte
    IntervalDays byte
    IntervalHours byte
    IntervalMinutes byte
    PushNodeID byte
}

func (c *MeterTblPushConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterTblPushConfigurationSet) Set(Properties1 byte,PushDataset byte,IntervalMonths byte,IntervalDays byte,IntervalHours byte,IntervalMinutes byte,PushNodeID byte,) error {
    c.Properties1 = Properties1
    c.PushDataset = PushDataset
    c.IntervalMonths = IntervalMonths
    c.IntervalDays = IntervalDays
    c.IntervalHours = IntervalHours
    c.IntervalMinutes = IntervalMinutes
    c.PushNodeID = PushNodeID
}

func (c *MeterTblPushConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(7),
        byte(MeterTblPush),
        0x01,
        Properties1,
        PushDataset,
        IntervalMonths,
        IntervalDays,
        IntervalHours,
        IntervalMinutes,
        PushNodeID,
        0x25,
    }
}
package commands
type MeterGet struct {
    node byte
}

func (c *MeterGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterGet) Set() error {
}

func (c *MeterGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Meter),
        0x01,
        0x25,
    }
}
type MeterReport struct {
    *report
    node byte
    MeterType byte
    Properties1 byte
    MeterValue byte
    data []byte
}

func NewMeterReport(data []byte) *MeterReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterReport{
        MeterType: data[0],
        Properties1: data[1],
        MeterValue: data[2],
        data: data,
    }
}

package commands
type MeterGetV2 struct {
    node byte
    Properties1 byte
}

func (c *MeterGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterGetV2) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *MeterGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MeterV2),
        0x01,
        Properties1,
        0x25,
    }
}
type MeterReportV2 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    MeterValue byte
    DeltaTime byte
    PreviousMeterValue byte
    data []byte
}

func NewMeterReportV2(data []byte) *MeterReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterReportV2{
        Properties1: data[0],
        Properties2: data[1],
        MeterValue: data[2],
        DeltaTime: data[3],
        PreviousMeterValue: data[4],
        data: data,
    }
}

type MeterResetV2 struct {
    node byte
}

func (c *MeterResetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterResetV2) Set() error {
}

func (c *MeterResetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterV2),
        0x05,
        0x25,
    }
}
type MeterSupportedGetV2 struct {
    node byte
}

func (c *MeterSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterSupportedGetV2) Set() error {
}

func (c *MeterSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterV2),
        0x03,
        0x25,
    }
}
type MeterSupportedReportV2 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    data []byte
}

func NewMeterSupportedReportV2(data []byte) *MeterSupportedReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterSupportedReportV2{
        Properties1: data[0],
        Properties2: data[1],
        data: data,
    }
}

package commands
type MeterGetV3 struct {
    node byte
    Properties1 byte
}

func (c *MeterGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterGetV3) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *MeterGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MeterV3),
        0x01,
        Properties1,
        0x25,
    }
}
type MeterReportV3 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    MeterValue byte
    DeltaTime byte
    PreviousMeterValue byte
    data []byte
}

func NewMeterReportV3(data []byte) *MeterReportV3 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterReportV3{
        Properties1: data[0],
        Properties2: data[1],
        MeterValue: data[2],
        DeltaTime: data[3],
        PreviousMeterValue: data[4],
        data: data,
    }
}

type MeterResetV3 struct {
    node byte
}

func (c *MeterResetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterResetV3) Set() error {
}

func (c *MeterResetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterV3),
        0x05,
        0x25,
    }
}
type MeterSupportedGetV3 struct {
    node byte
}

func (c *MeterSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterSupportedGetV3) Set() error {
}

func (c *MeterSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterV3),
        0x03,
        0x25,
    }
}
type MeterSupportedReportV3 struct {
    *report
    node byte
    Properties1 byte
    ScaleSupported byte
    data []byte
}

func NewMeterSupportedReportV3(data []byte) *MeterSupportedReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterSupportedReportV3{
        Properties1: data[0],
        ScaleSupported: data[1],
        data: data,
    }
}

package commands
type MeterGetV4 struct {
    node byte
    Properties1 byte
    Scale2 byte
}

func (c *MeterGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterGetV4) Set(Properties1 byte,Scale2 byte,) error {
    c.Properties1 = Properties1
    c.Scale2 = Scale2
}

func (c *MeterGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(MeterV4),
        0x01,
        Properties1,
        Scale2,
        0x25,
    }
}
type MeterReportV4 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    MeterValue byte
    DeltaTime byte
    PreviousMeterValue byte
    Scale2 byte
    data []byte
}

func NewMeterReportV4(data []byte) *MeterReportV4 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterReportV4{
        Properties1: data[0],
        Properties2: data[1],
        MeterValue: data[2],
        DeltaTime: data[3],
        PreviousMeterValue: data[4],
        Scale2: data[5],
        data: data,
    }
}

type MeterResetV4 struct {
    node byte
}

func (c *MeterResetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterResetV4) Set() error {
}

func (c *MeterResetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterV4),
        0x05,
        0x25,
    }
}
type MeterSupportedGetV4 struct {
    node byte
}

func (c *MeterSupportedGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MeterSupportedGetV4) Set() error {
}

func (c *MeterSupportedGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MeterV4),
        0x03,
        0x25,
    }
}
type MeterSupportedReportV4 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    NumberofScaleSupportedBytestoFollow byte
    ScaleSupported byte
    data []byte
}

func NewMeterSupportedReportV4(data []byte) *MeterSupportedReportV4 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &MeterSupportedReportV4{
        Properties1: data[0],
        Properties2: data[1],
        NumberofScaleSupportedBytestoFollow: data[2],
        ScaleSupported: data[3],
        data: data,
    }
}

package commands
type MoveToPositionGet struct {
    node byte
}

func (c *MoveToPositionGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MoveToPositionGet) Set() error {
}

func (c *MoveToPositionGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MtpWindowCovering),
        0x02,
        0x25,
    }
}
type MoveToPositionReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewMoveToPositionReport(data []byte) *MoveToPositionReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &MoveToPositionReport{
        Value: data[0],
        data: data,
    }
}

type MoveToPositionSet struct {
    node byte
    Value byte
}

func (c *MoveToPositionSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MoveToPositionSet) Set(Value byte,) error {
    c.Value = Value
}

func (c *MoveToPositionSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MtpWindowCovering),
        0x01,
        Value,
        0x25,
    }
}
package commands
type MultiChannelAssociationGetV2 struct {
    node byte
    GroupingIdentifier byte
}

func (c *MultiChannelAssociationGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationGetV2) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *MultiChannelAssociationGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelAssociationV2),
        0x02,
        GroupingIdentifier,
        0x25,
    }
}
type MultiChannelAssociationGroupingsGetV2 struct {
    node byte
}

func (c *MultiChannelAssociationGroupingsGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationGroupingsGetV2) Set() error {
}

func (c *MultiChannelAssociationGroupingsGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MultiChannelAssociationV2),
        0x05,
        0x25,
    }
}
type MultiChannelAssociationGroupingsReportV2 struct {
    *report
    node byte
    SupportedGroupings byte
    data []byte
}

func NewMultiChannelAssociationGroupingsReportV2(data []byte) *MultiChannelAssociationGroupingsReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelAssociationGroupingsReportV2{
        SupportedGroupings: data[0],
        data: data,
    }
}

type MultiChannelAssociationRemoveV2 struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
    Marker byte
}

func (c *MultiChannelAssociationRemoveV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationRemoveV2) Set(GroupingIdentifier byte,NodeID byte,Marker byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
    c.Marker = Marker
}

func (c *MultiChannelAssociationRemoveV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(MultiChannelAssociationV2),
        0x04,
        GroupingIdentifier,
        NodeID,
        Marker,
        0x25,
    }
}
type MultiChannelAssociationReportV2 struct {
    *report
    node byte
    GroupingIdentifier byte
    MaxNodesSupported byte
    ReportstoFollow byte
    NodeID byte
    Marker byte
    data []byte
}

func NewMultiChannelAssociationReportV2(data []byte) *MultiChannelAssociationReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelAssociationReportV2{
        GroupingIdentifier: data[0],
        MaxNodesSupported: data[1],
        ReportstoFollow: data[2],
        NodeID: data[3],
        Marker: data[4],
        data: data,
    }
}

type MultiChannelAssociationSetV2 struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
    Marker byte
}

func (c *MultiChannelAssociationSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationSetV2) Set(GroupingIdentifier byte,NodeID byte,Marker byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
    c.Marker = Marker
}

func (c *MultiChannelAssociationSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(MultiChannelAssociationV2),
        0x01,
        GroupingIdentifier,
        NodeID,
        Marker,
        0x25,
    }
}
package commands
type MultiChannelAssociationGetV3 struct {
    node byte
    GroupingIdentifier byte
}

func (c *MultiChannelAssociationGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationGetV3) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *MultiChannelAssociationGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelAssociationV3),
        0x02,
        GroupingIdentifier,
        0x25,
    }
}
type MultiChannelAssociationGroupingsGetV3 struct {
    node byte
}

func (c *MultiChannelAssociationGroupingsGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationGroupingsGetV3) Set() error {
}

func (c *MultiChannelAssociationGroupingsGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MultiChannelAssociationV3),
        0x05,
        0x25,
    }
}
type MultiChannelAssociationGroupingsReportV3 struct {
    *report
    node byte
    SupportedGroupings byte
    data []byte
}

func NewMultiChannelAssociationGroupingsReportV3(data []byte) *MultiChannelAssociationGroupingsReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelAssociationGroupingsReportV3{
        SupportedGroupings: data[0],
        data: data,
    }
}

type MultiChannelAssociationRemoveV3 struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
    Marker byte
}

func (c *MultiChannelAssociationRemoveV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationRemoveV3) Set(GroupingIdentifier byte,NodeID byte,Marker byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
    c.Marker = Marker
}

func (c *MultiChannelAssociationRemoveV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(MultiChannelAssociationV3),
        0x04,
        GroupingIdentifier,
        NodeID,
        Marker,
        0x25,
    }
}
type MultiChannelAssociationReportV3 struct {
    *report
    node byte
    GroupingIdentifier byte
    MaxNodesSupported byte
    ReportstoFollow byte
    NodeID byte
    Marker byte
    data []byte
}

func NewMultiChannelAssociationReportV3(data []byte) *MultiChannelAssociationReportV3 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelAssociationReportV3{
        GroupingIdentifier: data[0],
        MaxNodesSupported: data[1],
        ReportstoFollow: data[2],
        NodeID: data[3],
        Marker: data[4],
        data: data,
    }
}

type MultiChannelAssociationSetV3 struct {
    node byte
    GroupingIdentifier byte
    NodeID byte
    Marker byte
}

func (c *MultiChannelAssociationSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAssociationSetV3) Set(GroupingIdentifier byte,NodeID byte,Marker byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.NodeID = NodeID
    c.Marker = Marker
}

func (c *MultiChannelAssociationSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(MultiChannelAssociationV3),
        0x01,
        GroupingIdentifier,
        NodeID,
        Marker,
        0x25,
    }
}
package commands
type MultiChannelCapabilityGetV2 struct {
    node byte
    Properties1 byte
}

func (c *MultiChannelCapabilityGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelCapabilityGetV2) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *MultiChannelCapabilityGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV2),
        0x09,
        Properties1,
        0x25,
    }
}
type MultiChannelCapabilityReportV2 struct {
    *report
    node byte
    Properties1 byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    CommandClass byte
    data []byte
}

func NewMultiChannelCapabilityReportV2(data []byte) *MultiChannelCapabilityReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelCapabilityReportV2{
        Properties1: data[0],
        GenericDeviceClass: data[1],
        SpecificDeviceClass: data[2],
        CommandClass: data[3],
        data: data,
    }
}

type MultiChannelCmdEncapV2 struct {
    node byte
    Properties1 byte
    Properties2 byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiChannelCmdEncapV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelCmdEncapV2) Set(Properties1 byte,Properties2 byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiChannelCmdEncapV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(MultiChannelV2),
        0x0D,
        Properties1,
        Properties2,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiChannelEndPointFindV2 struct {
    node byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
}

func (c *MultiChannelEndPointFindV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelEndPointFindV2) Set(GenericDeviceClass byte,SpecificDeviceClass byte,) error {
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
}

func (c *MultiChannelEndPointFindV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(MultiChannelV2),
        0x0B,
        GenericDeviceClass,
        SpecificDeviceClass,
        0x25,
    }
}
type MultiChannelEndPointFindReportV2 struct {
    *report
    node byte
    ReportstoFollow byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    data []byte
}

func NewMultiChannelEndPointFindReportV2(data []byte) *MultiChannelEndPointFindReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelEndPointFindReportV2{
        ReportstoFollow: data[0],
        GenericDeviceClass: data[1],
        SpecificDeviceClass: data[2],
        data: data,
    }
}

type MultiChannelEndPointGetV2 struct {
    node byte
}

func (c *MultiChannelEndPointGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelEndPointGetV2) Set() error {
}

func (c *MultiChannelEndPointGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MultiChannelV2),
        0x07,
        0x25,
    }
}
type MultiChannelEndPointReportV2 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    data []byte
}

func NewMultiChannelEndPointReportV2(data []byte) *MultiChannelEndPointReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelEndPointReportV2{
        Properties1: data[0],
        Properties2: data[1],
        data: data,
    }
}

type MultiInstanceCmdEncapV2 struct {
    node byte
    Properties1 byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiInstanceCmdEncapV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceCmdEncapV2) Set(Properties1 byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Properties1 = Properties1
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiInstanceCmdEncapV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(MultiChannelV2),
        0x06,
        Properties1,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiInstanceGetV2 struct {
    node byte
    CommandClass byte
}

func (c *MultiInstanceGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceGetV2) Set(CommandClass byte,) error {
    c.CommandClass = CommandClass
}

func (c *MultiInstanceGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV2),
        0x04,
        CommandClass,
        0x25,
    }
}
type MultiInstanceReportV2 struct {
    *report
    node byte
    CommandClass byte
    Properties1 byte
    data []byte
}

func NewMultiInstanceReportV2(data []byte) *MultiInstanceReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiInstanceReportV2{
        CommandClass: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type MultiChannelCapabilityGetV3 struct {
    node byte
    Properties1 byte
}

func (c *MultiChannelCapabilityGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelCapabilityGetV3) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *MultiChannelCapabilityGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV3),
        0x09,
        Properties1,
        0x25,
    }
}
type MultiChannelCapabilityReportV3 struct {
    *report
    node byte
    Properties1 byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    CommandClass byte
    data []byte
}

func NewMultiChannelCapabilityReportV3(data []byte) *MultiChannelCapabilityReportV3 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelCapabilityReportV3{
        Properties1: data[0],
        GenericDeviceClass: data[1],
        SpecificDeviceClass: data[2],
        CommandClass: data[3],
        data: data,
    }
}

type MultiChannelCmdEncapV3 struct {
    node byte
    Properties1 byte
    Properties2 byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiChannelCmdEncapV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelCmdEncapV3) Set(Properties1 byte,Properties2 byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiChannelCmdEncapV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(MultiChannelV3),
        0x0D,
        Properties1,
        Properties2,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiChannelEndPointFindV3 struct {
    node byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
}

func (c *MultiChannelEndPointFindV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelEndPointFindV3) Set(GenericDeviceClass byte,SpecificDeviceClass byte,) error {
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
}

func (c *MultiChannelEndPointFindV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(MultiChannelV3),
        0x0B,
        GenericDeviceClass,
        SpecificDeviceClass,
        0x25,
    }
}
type MultiChannelEndPointFindReportV3 struct {
    *report
    node byte
    ReportstoFollow byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    data []byte
}

func NewMultiChannelEndPointFindReportV3(data []byte) *MultiChannelEndPointFindReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelEndPointFindReportV3{
        ReportstoFollow: data[0],
        GenericDeviceClass: data[1],
        SpecificDeviceClass: data[2],
        data: data,
    }
}

type MultiChannelEndPointGetV3 struct {
    node byte
}

func (c *MultiChannelEndPointGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelEndPointGetV3) Set() error {
}

func (c *MultiChannelEndPointGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MultiChannelV3),
        0x07,
        0x25,
    }
}
type MultiChannelEndPointReportV3 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    data []byte
}

func NewMultiChannelEndPointReportV3(data []byte) *MultiChannelEndPointReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelEndPointReportV3{
        Properties1: data[0],
        Properties2: data[1],
        data: data,
    }
}

type MultiInstanceCmdEncapV3 struct {
    node byte
    Properties1 byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiInstanceCmdEncapV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceCmdEncapV3) Set(Properties1 byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Properties1 = Properties1
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiInstanceCmdEncapV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(MultiChannelV3),
        0x06,
        Properties1,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiInstanceGetV3 struct {
    node byte
    CommandClass byte
}

func (c *MultiInstanceGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceGetV3) Set(CommandClass byte,) error {
    c.CommandClass = CommandClass
}

func (c *MultiInstanceGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV3),
        0x04,
        CommandClass,
        0x25,
    }
}
type MultiInstanceReportV3 struct {
    *report
    node byte
    CommandClass byte
    Properties1 byte
    data []byte
}

func NewMultiInstanceReportV3(data []byte) *MultiInstanceReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiInstanceReportV3{
        CommandClass: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type MultiChannelCapabilityGetV4 struct {
    node byte
    Properties1 byte
}

func (c *MultiChannelCapabilityGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelCapabilityGetV4) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *MultiChannelCapabilityGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV4),
        0x09,
        Properties1,
        0x25,
    }
}
type MultiChannelCapabilityReportV4 struct {
    *report
    node byte
    Properties1 byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    CommandClass byte
    data []byte
}

func NewMultiChannelCapabilityReportV4(data []byte) *MultiChannelCapabilityReportV4 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelCapabilityReportV4{
        Properties1: data[0],
        GenericDeviceClass: data[1],
        SpecificDeviceClass: data[2],
        CommandClass: data[3],
        data: data,
    }
}

type MultiChannelCmdEncapV4 struct {
    node byte
    Properties1 byte
    Properties2 byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiChannelCmdEncapV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelCmdEncapV4) Set(Properties1 byte,Properties2 byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiChannelCmdEncapV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(MultiChannelV4),
        0x0D,
        Properties1,
        Properties2,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiChannelEndPointFindV4 struct {
    node byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
}

func (c *MultiChannelEndPointFindV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelEndPointFindV4) Set(GenericDeviceClass byte,SpecificDeviceClass byte,) error {
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
}

func (c *MultiChannelEndPointFindV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(MultiChannelV4),
        0x0B,
        GenericDeviceClass,
        SpecificDeviceClass,
        0x25,
    }
}
type MultiChannelEndPointFindReportV4 struct {
    *report
    node byte
    ReportstoFollow byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    data []byte
}

func NewMultiChannelEndPointFindReportV4(data []byte) *MultiChannelEndPointFindReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelEndPointFindReportV4{
        ReportstoFollow: data[0],
        GenericDeviceClass: data[1],
        SpecificDeviceClass: data[2],
        data: data,
    }
}

type MultiChannelEndPointGetV4 struct {
    node byte
}

func (c *MultiChannelEndPointGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelEndPointGetV4) Set() error {
}

func (c *MultiChannelEndPointGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MultiChannelV4),
        0x07,
        0x25,
    }
}
type MultiChannelEndPointReportV4 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    data []byte
}

func NewMultiChannelEndPointReportV4(data []byte) *MultiChannelEndPointReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelEndPointReportV4{
        Properties1: data[0],
        Properties2: data[1],
        Properties3: data[2],
        data: data,
    }
}

type MultiInstanceCmdEncapV4 struct {
    node byte
    Properties1 byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiInstanceCmdEncapV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceCmdEncapV4) Set(Properties1 byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Properties1 = Properties1
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiInstanceCmdEncapV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(MultiChannelV4),
        0x06,
        Properties1,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiInstanceGetV4 struct {
    node byte
    CommandClass byte
}

func (c *MultiInstanceGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceGetV4) Set(CommandClass byte,) error {
    c.CommandClass = CommandClass
}

func (c *MultiInstanceGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV4),
        0x04,
        CommandClass,
        0x25,
    }
}
type MultiInstanceReportV4 struct {
    *report
    node byte
    CommandClass byte
    Properties1 byte
    data []byte
}

func NewMultiInstanceReportV4(data []byte) *MultiInstanceReportV4 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiInstanceReportV4{
        CommandClass: data[0],
        Properties1: data[1],
        data: data,
    }
}

type MultiChannelAggregatedMembersGetV4 struct {
    node byte
    Properties1 byte
}

func (c *MultiChannelAggregatedMembersGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiChannelAggregatedMembersGetV4) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *MultiChannelAggregatedMembersGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiChannelV4),
        0x0E,
        Properties1,
        0x25,
    }
}
type MultiChannelAggregatedMembersReportV4 struct {
    *report
    node byte
    Properties1 byte
    NumberofBitMasks byte
    AggregatedMembersBitMask byte
    data []byte
}

func NewMultiChannelAggregatedMembersReportV4(data []byte) *MultiChannelAggregatedMembersReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiChannelAggregatedMembersReportV4{
        Properties1: data[0],
        NumberofBitMasks: data[1],
        AggregatedMembersBitMask: data[2],
        data: data,
    }
}

package commands
type MultiCmdEncap struct {
    node byte
    NumberofCommands byte
}

func (c *MultiCmdEncap) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiCmdEncap) Set(NumberofCommands byte,) error {
    c.NumberofCommands = NumberofCommands
}

func (c *MultiCmdEncap) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiCmd),
        0x01,
        NumberofCommands,
        0x25,
    }
}
package commands
type MultiInstanceAssociationGet struct {
    node byte
    GroupingIdentifier byte
}

func (c *MultiInstanceAssociationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceAssociationGet) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *MultiInstanceAssociationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiInstanceAssociation),
        0x02,
        GroupingIdentifier,
        0x25,
    }
}
type MultiInstanceAssociationGroupingsGet struct {
    node byte
}

func (c *MultiInstanceAssociationGroupingsGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceAssociationGroupingsGet) Set() error {
}

func (c *MultiInstanceAssociationGroupingsGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(MultiInstanceAssociation),
        0x05,
        0x25,
    }
}
type MultiInstanceAssociationGroupingsReport struct {
    *report
    node byte
    SupportedGroupings byte
    data []byte
}

func NewMultiInstanceAssociationGroupingsReport(data []byte) *MultiInstanceAssociationGroupingsReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiInstanceAssociationGroupingsReport{
        SupportedGroupings: data[0],
        data: data,
    }
}

type MultiInstanceAssociationRemove struct {
    node byte
    Groupingidentifier byte
    NodeID byte
    Marker byte
}

func (c *MultiInstanceAssociationRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceAssociationRemove) Set(Groupingidentifier byte,NodeID byte,Marker byte,) error {
    c.Groupingidentifier = Groupingidentifier
    c.NodeID = NodeID
    c.Marker = Marker
}

func (c *MultiInstanceAssociationRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(MultiInstanceAssociation),
        0x04,
        Groupingidentifier,
        NodeID,
        Marker,
        0x25,
    }
}
type MultiInstanceAssociationReport struct {
    *report
    node byte
    GroupingIdentifier byte
    MaxNodesSupported byte
    ReportstoFollow byte
    NodeID byte
    Marker byte
    data []byte
}

func NewMultiInstanceAssociationReport(data []byte) *MultiInstanceAssociationReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiInstanceAssociationReport{
        GroupingIdentifier: data[0],
        MaxNodesSupported: data[1],
        ReportstoFollow: data[2],
        NodeID: data[3],
        Marker: data[4],
        data: data,
    }
}

type MultiInstanceAssociationSet struct {
    node byte
    Groupingidentifier byte
    NodeID byte
    Marker byte
}

func (c *MultiInstanceAssociationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceAssociationSet) Set(Groupingidentifier byte,NodeID byte,Marker byte,) error {
    c.Groupingidentifier = Groupingidentifier
    c.NodeID = NodeID
    c.Marker = Marker
}

func (c *MultiInstanceAssociationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(MultiInstanceAssociation),
        0x01,
        Groupingidentifier,
        NodeID,
        Marker,
        0x25,
    }
}
package commands
type MultiInstanceCmdEncap struct {
    node byte
    Instance byte
    CommandClass byte
    Command byte
    Parameter byte
}

func (c *MultiInstanceCmdEncap) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceCmdEncap) Set(Instance byte,CommandClass byte,Command byte,Parameter byte,) error {
    c.Instance = Instance
    c.CommandClass = CommandClass
    c.Command = Command
    c.Parameter = Parameter
}

func (c *MultiInstanceCmdEncap) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(MultiInstance),
        0x06,
        Instance,
        CommandClass,
        Command,
        Parameter,
        0x25,
    }
}
type MultiInstanceGet struct {
    node byte
    CommandClass byte
}

func (c *MultiInstanceGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MultiInstanceGet) Set(CommandClass byte,) error {
    c.CommandClass = CommandClass
}

func (c *MultiInstanceGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(MultiInstance),
        0x04,
        CommandClass,
        0x25,
    }
}
type MultiInstanceReport struct {
    *report
    node byte
    CommandClass byte
    Instances byte
    data []byte
}

func NewMultiInstanceReport(data []byte) *MultiInstanceReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &MultiInstanceReport{
        CommandClass: data[0],
        Instances: data[1],
        data: data,
    }
}

package commands
type NodeInfoCachedGet struct {
    node byte
    Seq.No byte
    Properties1 byte
    NodeID byte
}

func (c *NodeInfoCachedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeInfoCachedGet) Set(Seq.No byte,Properties1 byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Properties1 = Properties1
    c.NodeID = NodeID
}

func (c *NodeInfoCachedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementProxy),
        0x03,
        Seq.No,
        Properties1,
        NodeID,
        0x25,
    }
}
type NodeInfoCachedReport struct {
    *report
    node byte
    Seq.No byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Reserved byte
    BasicDeviceClass byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    Non-SecureCommandClass byte
    SecurityScheme0MARK byte
    SecurityScheme0CommandClass byte
    data []byte
}

func NewNodeInfoCachedReport(data []byte) *NodeInfoCachedReport {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeInfoCachedReport{
        Seq.No: data[0],
        Properties1: data[1],
        Properties2: data[2],
        Properties3: data[3],
        Reserved: data[4],
        BasicDeviceClass: data[5],
        GenericDeviceClass: data[6],
        SpecificDeviceClass: data[7],
        Non-SecureCommandClass: data[8],
        SecurityScheme0MARK: data[9],
        SecurityScheme0CommandClass: data[10],
        data: data,
    }
}

type NodeListGet struct {
    node byte
    Seq.No byte
}

func (c *NodeListGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeListGet) Set(Seq.No byte,) error {
    c.Seq.No = Seq.No
}

func (c *NodeListGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementProxy),
        0x01,
        Seq.No,
        0x25,
    }
}
type NodeListReport struct {
    *report
    node byte
    Seq.No byte
    Status byte
    NodeListControllerID byte
    NodeListData byte
    data []byte
}

func NewNodeListReport(data []byte) *NodeListReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeListReport{
        Seq.No: data[0],
        Status: data[1],
        NodeListControllerID: data[2],
        NodeListData: data[3],
        data: data,
    }
}

package commands
type NodeInfoCachedGetV2 struct {
    node byte
    Seq.No byte
    Properties1 byte
    NodeID byte
}

func (c *NodeInfoCachedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeInfoCachedGetV2) Set(Seq.No byte,Properties1 byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Properties1 = Properties1
    c.NodeID = NodeID
}

func (c *NodeInfoCachedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementProxyV2),
        0x03,
        Seq.No,
        Properties1,
        NodeID,
        0x25,
    }
}
type NodeInfoCachedReportV2 struct {
    *report
    node byte
    Seq.No byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    GrantedKeys byte
    BasicDeviceClass byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    Non-SecureCommandClass byte
    SecurityMARK byte
    SecureCommandClass byte
    data []byte
}

func NewNodeInfoCachedReportV2(data []byte) *NodeInfoCachedReportV2 {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeInfoCachedReportV2{
        Seq.No: data[0],
        Properties1: data[1],
        Properties2: data[2],
        Properties3: data[3],
        GrantedKeys: data[4],
        BasicDeviceClass: data[5],
        GenericDeviceClass: data[6],
        SpecificDeviceClass: data[7],
        Non-SecureCommandClass: data[8],
        SecurityMARK: data[9],
        SecureCommandClass: data[10],
        data: data,
    }
}

type NodeListGetV2 struct {
    node byte
    Seq.No byte
}

func (c *NodeListGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeListGetV2) Set(Seq.No byte,) error {
    c.Seq.No = Seq.No
}

func (c *NodeListGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementProxyV2),
        0x01,
        Seq.No,
        0x25,
    }
}
type NodeListReportV2 struct {
    *report
    node byte
    Seq.No byte
    Status byte
    NodeListControllerID byte
    NodeListData byte
    data []byte
}

func NewNodeListReportV2(data []byte) *NodeListReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeListReportV2{
        Seq.No: data[0],
        Status: data[1],
        NodeListControllerID: data[2],
        NodeListData: data[3],
        data: data,
    }
}

package commands
type LearnModeSet struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
}

func (c *LearnModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LearnModeSet) Set(Seq.No byte,Reserved byte,Mode byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
}

func (c *LearnModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementBasic),
        0x01,
        Seq.No,
        Reserved,
        Mode,
        0x25,
    }
}
type LearnModeSetStatus struct {
    node byte
    Seq.No byte
    Status byte
    Reserved byte
    NewNodeID byte
}

func (c *LearnModeSetStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *LearnModeSetStatus) Set(Seq.No byte,Status byte,Reserved byte,NewNodeID byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.Reserved = Reserved
    c.NewNodeID = NewNodeID
}

func (c *LearnModeSetStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementBasic),
        0x02,
        Seq.No,
        Status,
        Reserved,
        NewNodeID,
        0x25,
    }
}
type NodeInformationSend struct {
    node byte
    Seq.No byte
    Reserved byte
    DestinationNodeID byte
    txOptions byte
}

func (c *NodeInformationSend) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeInformationSend) Set(Seq.No byte,Reserved byte,DestinationNodeID byte,txOptions byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.DestinationNodeID = DestinationNodeID
    c.txOptions = txOptions
}

func (c *NodeInformationSend) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementBasic),
        0x05,
        Seq.No,
        Reserved,
        DestinationNodeID,
        txOptions,
        0x25,
    }
}
type NetworkUpdateRequest struct {
    node byte
    Seq.No byte
}

func (c *NetworkUpdateRequest) SetNode(node int) {
    c.node = byte(node)
}

func (c *NetworkUpdateRequest) Set(Seq.No byte,) error {
    c.Seq.No = Seq.No
}

func (c *NetworkUpdateRequest) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementBasic),
        0x03,
        Seq.No,
        0x25,
    }
}
type NetworkUpdateRequestStatus struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *NetworkUpdateRequestStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *NetworkUpdateRequestStatus) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *NetworkUpdateRequestStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementBasic),
        0x04,
        Seq.No,
        Status,
        0x25,
    }
}
type DefaultSet struct {
    node byte
    Seq.No byte
}

func (c *DefaultSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DefaultSet) Set(Seq.No byte,) error {
    c.Seq.No = Seq.No
}

func (c *DefaultSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementBasic),
        0x06,
        Seq.No,
        0x25,
    }
}
type DefaultSetComplete struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *DefaultSetComplete) SetNode(node int) {
    c.node = byte(node)
}

func (c *DefaultSetComplete) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *DefaultSetComplete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementBasic),
        0x07,
        Seq.No,
        Status,
        0x25,
    }
}
package commands
type LearnModeSetV2 struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
}

func (c *LearnModeSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *LearnModeSetV2) Set(Seq.No byte,Reserved byte,Mode byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
}

func (c *LearnModeSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementBasicV2),
        0x01,
        Seq.No,
        Reserved,
        Mode,
        0x25,
    }
}
type LearnModeSetStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
    Reserved byte
    NewNodeID byte
    GrantedKeys byte
    DSK byte
}

func (c *LearnModeSetStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *LearnModeSetStatusV2) Set(Seq.No byte,Status byte,Reserved byte,NewNodeID byte,GrantedKeys byte,DSK byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.Reserved = Reserved
    c.NewNodeID = NewNodeID
    c.GrantedKeys = GrantedKeys
    c.DSK = DSK
}

func (c *LearnModeSetStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(NetworkManagementBasicV2),
        0x02,
        Seq.No,
        Status,
        Reserved,
        NewNodeID,
        GrantedKeys,
        DSK,
        0x25,
    }
}
type NodeInformationSendV2 struct {
    node byte
    Seq.No byte
    Reserved byte
    DestinationNodeID byte
    txOptions byte
}

func (c *NodeInformationSendV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeInformationSendV2) Set(Seq.No byte,Reserved byte,DestinationNodeID byte,txOptions byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.DestinationNodeID = DestinationNodeID
    c.txOptions = txOptions
}

func (c *NodeInformationSendV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementBasicV2),
        0x05,
        Seq.No,
        Reserved,
        DestinationNodeID,
        txOptions,
        0x25,
    }
}
type NetworkUpdateRequestV2 struct {
    node byte
    Seq.No byte
}

func (c *NetworkUpdateRequestV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NetworkUpdateRequestV2) Set(Seq.No byte,) error {
    c.Seq.No = Seq.No
}

func (c *NetworkUpdateRequestV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementBasicV2),
        0x03,
        Seq.No,
        0x25,
    }
}
type NetworkUpdateRequestStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *NetworkUpdateRequestStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NetworkUpdateRequestStatusV2) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *NetworkUpdateRequestStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementBasicV2),
        0x04,
        Seq.No,
        Status,
        0x25,
    }
}
type DefaultSetV2 struct {
    node byte
    Seq.No byte
}

func (c *DefaultSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DefaultSetV2) Set(Seq.No byte,) error {
    c.Seq.No = Seq.No
}

func (c *DefaultSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementBasicV2),
        0x06,
        Seq.No,
        0x25,
    }
}
type DefaultSetCompleteV2 struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *DefaultSetCompleteV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DefaultSetCompleteV2) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *DefaultSetCompleteV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementBasicV2),
        0x07,
        Seq.No,
        Status,
        0x25,
    }
}
type DskGetV2 struct {
    node byte
    SeqNo byte
}

func (c *DskGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DskGetV2) Set(SeqNo byte,) error {
    c.SeqNo = SeqNo
}

func (c *DskGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementBasicV2),
        0x08,
        SeqNo,
        0x25,
    }
}
type DskReportV2 struct {
    *report
    node byte
    SeqNo byte
    DSK byte
    data []byte
}

func NewDskReportV2(data []byte) *DskReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &DskReportV2{
        SeqNo: data[0],
        DSK: data[1],
        data: data,
    }
}

package commands
type FailedNodeRemove struct {
    node byte
    Seq.No byte
    NodeID byte
}

func (c *FailedNodeRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeRemove) Set(Seq.No byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
}

func (c *FailedNodeRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusion),
        0x07,
        Seq.No,
        NodeID,
        0x25,
    }
}
type FailedNodeRemoveStatus struct {
    node byte
    Seq.No byte
    Status byte
    NodeID byte
}

func (c *FailedNodeRemoveStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeRemoveStatus) Set(Seq.No byte,Status byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.NodeID = NodeID
}

func (c *FailedNodeRemoveStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusion),
        0x08,
        Seq.No,
        Status,
        NodeID,
        0x25,
    }
}
type NodeAdd struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
    txOptions byte
}

func (c *NodeAdd) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeAdd) Set(Seq.No byte,Reserved byte,Mode byte,txOptions byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
    c.txOptions = txOptions
}

func (c *NodeAdd) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementInclusion),
        0x01,
        Seq.No,
        Reserved,
        Mode,
        txOptions,
        0x25,
    }
}
type NodeAddStatus struct {
    node byte
    Seq.No byte
    Status byte
    Reserved byte
    NewNodeID byte
    NodeInfoLength byte
    Properties1 byte
    Properties2 byte
    BasicDeviceClass byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    CommandClass byte
}

func (c *NodeAddStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeAddStatus) Set(Seq.No byte,Status byte,Reserved byte,NewNodeID byte,NodeInfoLength byte,Properties1 byte,Properties2 byte,BasicDeviceClass byte,GenericDeviceClass byte,SpecificDeviceClass byte,CommandClass byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.Reserved = Reserved
    c.NewNodeID = NewNodeID
    c.NodeInfoLength = NodeInfoLength
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.BasicDeviceClass = BasicDeviceClass
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
    c.CommandClass = CommandClass
}

func (c *NodeAddStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(NetworkManagementInclusion),
        0x02,
        Seq.No,
        Status,
        Reserved,
        NewNodeID,
        NodeInfoLength,
        Properties1,
        Properties2,
        BasicDeviceClass,
        GenericDeviceClass,
        SpecificDeviceClass,
        CommandClass,
        0x25,
    }
}
type NodeRemove struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
}

func (c *NodeRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeRemove) Set(Seq.No byte,Reserved byte,Mode byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
}

func (c *NodeRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusion),
        0x03,
        Seq.No,
        Reserved,
        Mode,
        0x25,
    }
}
type NodeRemoveStatus struct {
    node byte
    Seq.No byte
    Status byte
    NodeID byte
}

func (c *NodeRemoveStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeRemoveStatus) Set(Seq.No byte,Status byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.NodeID = NodeID
}

func (c *NodeRemoveStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusion),
        0x04,
        Seq.No,
        Status,
        NodeID,
        0x25,
    }
}
type FailedNodeReplace struct {
    node byte
    Seq.No byte
    NodeID byte
    txOptions byte
    Mode byte
}

func (c *FailedNodeReplace) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeReplace) Set(Seq.No byte,NodeID byte,txOptions byte,Mode byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
    c.txOptions = txOptions
    c.Mode = Mode
}

func (c *FailedNodeReplace) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementInclusion),
        0x09,
        Seq.No,
        NodeID,
        txOptions,
        Mode,
        0x25,
    }
}
type FailedNodeReplaceStatus struct {
    node byte
    Seq.No byte
    Status byte
    NodeID byte
}

func (c *FailedNodeReplaceStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeReplaceStatus) Set(Seq.No byte,Status byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.NodeID = NodeID
}

func (c *FailedNodeReplaceStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusion),
        0x0A,
        Seq.No,
        Status,
        NodeID,
        0x25,
    }
}
type NodeNeighborUpdateRequest struct {
    node byte
    Seq.No byte
    NodeID byte
}

func (c *NodeNeighborUpdateRequest) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNeighborUpdateRequest) Set(Seq.No byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
}

func (c *NodeNeighborUpdateRequest) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusion),
        0x0B,
        Seq.No,
        NodeID,
        0x25,
    }
}
type NodeNeighborUpdateStatus struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *NodeNeighborUpdateStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNeighborUpdateStatus) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *NodeNeighborUpdateStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusion),
        0x0C,
        Seq.No,
        Status,
        0x25,
    }
}
type ReturnRouteAssign struct {
    node byte
    Seq.No byte
    SourceNodeID byte
    DestinationNodeID byte
}

func (c *ReturnRouteAssign) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteAssign) Set(Seq.No byte,SourceNodeID byte,DestinationNodeID byte,) error {
    c.Seq.No = Seq.No
    c.SourceNodeID = SourceNodeID
    c.DestinationNodeID = DestinationNodeID
}

func (c *ReturnRouteAssign) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusion),
        0x0D,
        Seq.No,
        SourceNodeID,
        DestinationNodeID,
        0x25,
    }
}
type ReturnRouteAssignComplete struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *ReturnRouteAssignComplete) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteAssignComplete) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *ReturnRouteAssignComplete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusion),
        0x0E,
        Seq.No,
        Status,
        0x25,
    }
}
type ReturnRouteDelete struct {
    node byte
    Seq.No byte
    NodeID byte
}

func (c *ReturnRouteDelete) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteDelete) Set(Seq.No byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
}

func (c *ReturnRouteDelete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusion),
        0x0F,
        Seq.No,
        NodeID,
        0x25,
    }
}
type ReturnRouteDeleteComplete struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *ReturnRouteDeleteComplete) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteDeleteComplete) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *ReturnRouteDeleteComplete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusion),
        0x10,
        Seq.No,
        Status,
        0x25,
    }
}
package commands
type FailedNodeRemoveV2 struct {
    node byte
    Seq.No byte
    NodeID byte
}

func (c *FailedNodeRemoveV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeRemoveV2) Set(Seq.No byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
}

func (c *FailedNodeRemoveV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusionV2),
        0x07,
        Seq.No,
        NodeID,
        0x25,
    }
}
type FailedNodeRemoveStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
    NodeID byte
}

func (c *FailedNodeRemoveStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeRemoveStatusV2) Set(Seq.No byte,Status byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.NodeID = NodeID
}

func (c *FailedNodeRemoveStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusionV2),
        0x08,
        Seq.No,
        Status,
        NodeID,
        0x25,
    }
}
type NodeAddV2 struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
    txOptions byte
}

func (c *NodeAddV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeAddV2) Set(Seq.No byte,Reserved byte,Mode byte,txOptions byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
    c.txOptions = txOptions
}

func (c *NodeAddV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementInclusionV2),
        0x01,
        Seq.No,
        Reserved,
        Mode,
        txOptions,
        0x25,
    }
}
type NodeAddStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
    Reserved byte
    NewNodeID byte
    NodeInfoLength byte
    Properties1 byte
    Properties2 byte
    BasicDeviceClass byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    Non-SecureCommandClass byte
    SecurityMARK byte
    SecureCommandClass byte
    GrantedKeys byte
    KEXFailType byte
}

func (c *NodeAddStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeAddStatusV2) Set(Seq.No byte,Status byte,Reserved byte,NewNodeID byte,NodeInfoLength byte,Properties1 byte,Properties2 byte,BasicDeviceClass byte,GenericDeviceClass byte,SpecificDeviceClass byte,Non-SecureCommandClass byte,SecurityMARK byte,SecureCommandClass byte,GrantedKeys byte,KEXFailType byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.Reserved = Reserved
    c.NewNodeID = NewNodeID
    c.NodeInfoLength = NodeInfoLength
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.BasicDeviceClass = BasicDeviceClass
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
    c.Non-SecureCommandClass = Non-SecureCommandClass
    c.SecurityMARK = SecurityMARK
    c.SecureCommandClass = SecureCommandClass
    c.GrantedKeys = GrantedKeys
    c.KEXFailType = KEXFailType
}

func (c *NodeAddStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(15),
        byte(NetworkManagementInclusionV2),
        0x02,
        Seq.No,
        Status,
        Reserved,
        NewNodeID,
        NodeInfoLength,
        Properties1,
        Properties2,
        BasicDeviceClass,
        GenericDeviceClass,
        SpecificDeviceClass,
        Non-SecureCommandClass,
        SecurityMARK,
        SecureCommandClass,
        GrantedKeys,
        KEXFailType,
        0x25,
    }
}
type NodeRemoveV2 struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
}

func (c *NodeRemoveV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeRemoveV2) Set(Seq.No byte,Reserved byte,Mode byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
}

func (c *NodeRemoveV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusionV2),
        0x03,
        Seq.No,
        Reserved,
        Mode,
        0x25,
    }
}
type NodeRemoveStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
    NodeID byte
}

func (c *NodeRemoveStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeRemoveStatusV2) Set(Seq.No byte,Status byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.NodeID = NodeID
}

func (c *NodeRemoveStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusionV2),
        0x04,
        Seq.No,
        Status,
        NodeID,
        0x25,
    }
}
type FailedNodeReplaceV2 struct {
    node byte
    Seq.No byte
    NodeID byte
    txOptions byte
    Mode byte
}

func (c *FailedNodeReplaceV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeReplaceV2) Set(Seq.No byte,NodeID byte,txOptions byte,Mode byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
    c.txOptions = txOptions
    c.Mode = Mode
}

func (c *FailedNodeReplaceV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementInclusionV2),
        0x09,
        Seq.No,
        NodeID,
        txOptions,
        Mode,
        0x25,
    }
}
type FailedNodeReplaceStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
    NodeID byte
    GrantedKeys byte
    KEXFailType byte
}

func (c *FailedNodeReplaceStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *FailedNodeReplaceStatusV2) Set(Seq.No byte,Status byte,NodeID byte,GrantedKeys byte,KEXFailType byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.NodeID = NodeID
    c.GrantedKeys = GrantedKeys
    c.KEXFailType = KEXFailType
}

func (c *FailedNodeReplaceStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(NetworkManagementInclusionV2),
        0x0A,
        Seq.No,
        Status,
        NodeID,
        GrantedKeys,
        KEXFailType,
        0x25,
    }
}
type NodeNeighborUpdateRequestV2 struct {
    node byte
    Seq.No byte
    NodeID byte
}

func (c *NodeNeighborUpdateRequestV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNeighborUpdateRequestV2) Set(Seq.No byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
}

func (c *NodeNeighborUpdateRequestV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusionV2),
        0x0B,
        Seq.No,
        NodeID,
        0x25,
    }
}
type NodeNeighborUpdateStatusV2 struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *NodeNeighborUpdateStatusV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNeighborUpdateStatusV2) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *NodeNeighborUpdateStatusV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusionV2),
        0x0C,
        Seq.No,
        Status,
        0x25,
    }
}
type ReturnRouteAssignV2 struct {
    node byte
    Seq.No byte
    SourceNodeID byte
    DestinationNodeID byte
}

func (c *ReturnRouteAssignV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteAssignV2) Set(Seq.No byte,SourceNodeID byte,DestinationNodeID byte,) error {
    c.Seq.No = Seq.No
    c.SourceNodeID = SourceNodeID
    c.DestinationNodeID = DestinationNodeID
}

func (c *ReturnRouteAssignV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusionV2),
        0x0D,
        Seq.No,
        SourceNodeID,
        DestinationNodeID,
        0x25,
    }
}
type ReturnRouteAssignCompleteV2 struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *ReturnRouteAssignCompleteV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteAssignCompleteV2) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *ReturnRouteAssignCompleteV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusionV2),
        0x0E,
        Seq.No,
        Status,
        0x25,
    }
}
type ReturnRouteDeleteV2 struct {
    node byte
    Seq.No byte
    NodeID byte
}

func (c *ReturnRouteDeleteV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteDeleteV2) Set(Seq.No byte,NodeID byte,) error {
    c.Seq.No = Seq.No
    c.NodeID = NodeID
}

func (c *ReturnRouteDeleteV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusionV2),
        0x0F,
        Seq.No,
        NodeID,
        0x25,
    }
}
type ReturnRouteDeleteCompleteV2 struct {
    node byte
    Seq.No byte
    Status byte
}

func (c *ReturnRouteDeleteCompleteV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ReturnRouteDeleteCompleteV2) Set(Seq.No byte,Status byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
}

func (c *ReturnRouteDeleteCompleteV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NetworkManagementInclusionV2),
        0x10,
        Seq.No,
        Status,
        0x25,
    }
}
type NodeAddKeysReportV2 struct {
    *report
    node byte
    SeqNo byte
    Properties1 byte
    RequestedKeys byte
    data []byte
}

func NewNodeAddKeysReportV2(data []byte) *NodeAddKeysReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeAddKeysReportV2{
        SeqNo: data[0],
        Properties1: data[1],
        RequestedKeys: data[2],
        data: data,
    }
}

type NodeAddKeysSetV2 struct {
    node byte
    SeqNo byte
    Properties1 byte
    GrantedKeys byte
}

func (c *NodeAddKeysSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeAddKeysSetV2) Set(SeqNo byte,Properties1 byte,GrantedKeys byte,) error {
    c.SeqNo = SeqNo
    c.Properties1 = Properties1
    c.GrantedKeys = GrantedKeys
}

func (c *NodeAddKeysSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusionV2),
        0x12,
        SeqNo,
        Properties1,
        GrantedKeys,
        0x25,
    }
}
type NodeAddDskReportV2 struct {
    *report
    node byte
    SeqNo byte
    Properties1 byte
    DSK byte
    data []byte
}

func NewNodeAddDskReportV2(data []byte) *NodeAddDskReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeAddDskReportV2{
        SeqNo: data[0],
        Properties1: data[1],
        DSK: data[2],
        data: data,
    }
}

type NodeAddDskSetV2 struct {
    node byte
    SeqNo byte
    Properties1 byte
    InputDSK byte
}

func (c *NodeAddDskSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeAddDskSetV2) Set(SeqNo byte,Properties1 byte,InputDSK byte,) error {
    c.SeqNo = SeqNo
    c.Properties1 = Properties1
    c.InputDSK = InputDSK
}

func (c *NodeAddDskSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(NetworkManagementInclusionV2),
        0x14,
        SeqNo,
        Properties1,
        InputDSK,
        0x25,
    }
}
package commands
type NodeNamingNodeLocationReport struct {
    *report
    node byte
    Level byte
    Nodelocationchar byte
    data []byte
}

func NewNodeNamingNodeLocationReport(data []byte) *NodeNamingNodeLocationReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeNamingNodeLocationReport{
        Level: data[0],
        Nodelocationchar: data[1],
        data: data,
    }
}

type NodeNamingNodeLocationSet struct {
    node byte
    Level byte
    Nodelocationchar byte
}

func (c *NodeNamingNodeLocationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNamingNodeLocationSet) Set(Level byte,Nodelocationchar byte,) error {
    c.Level = Level
    c.Nodelocationchar = Nodelocationchar
}

func (c *NodeNamingNodeLocationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NodeNaming),
        0x04,
        Level,
        Nodelocationchar,
        0x25,
    }
}
type NodeNamingNodeLocationGet struct {
    node byte
}

func (c *NodeNamingNodeLocationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNamingNodeLocationGet) Set() error {
}

func (c *NodeNamingNodeLocationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NodeNaming),
        0x05,
        0x25,
    }
}
type NodeNamingNodeNameGet struct {
    node byte
}

func (c *NodeNamingNodeNameGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNamingNodeNameGet) Set() error {
}

func (c *NodeNamingNodeNameGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NodeNaming),
        0x02,
        0x25,
    }
}
type NodeNamingNodeNameReport struct {
    *report
    node byte
    Level byte
    Nodenamechar byte
    data []byte
}

func NewNodeNamingNodeNameReport(data []byte) *NodeNamingNodeNameReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &NodeNamingNodeNameReport{
        Level: data[0],
        Nodenamechar: data[1],
        data: data,
    }
}

type NodeNamingNodeNameSet struct {
    node byte
    Level byte
    Nodenamechar byte
}

func (c *NodeNamingNodeNameSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeNamingNodeNameSet) Set(Level byte,Nodenamechar byte,) error {
    c.Level = Level
    c.Nodenamechar = Nodenamechar
}

func (c *NodeNamingNodeNameSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(NodeNaming),
        0x01,
        Level,
        Nodenamechar,
        0x25,
    }
}
package commands
type PowerlevelGet struct {
    node byte
}

func (c *PowerlevelGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *PowerlevelGet) Set() error {
}

func (c *PowerlevelGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Powerlevel),
        0x02,
        0x25,
    }
}
type PowerlevelReport struct {
    *report
    node byte
    Powerlevel byte
    Timeout byte
    data []byte
}

func NewPowerlevelReport(data []byte) *PowerlevelReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &PowerlevelReport{
        Powerlevel: data[0],
        Timeout: data[1],
        data: data,
    }
}

type PowerlevelSet struct {
    node byte
    Powerlevel byte
    Timeout byte
}

func (c *PowerlevelSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *PowerlevelSet) Set(Powerlevel byte,Timeout byte,) error {
    c.Powerlevel = Powerlevel
    c.Timeout = Timeout
}

func (c *PowerlevelSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Powerlevel),
        0x01,
        Powerlevel,
        Timeout,
        0x25,
    }
}
type PowerlevelTestNodeGet struct {
    node byte
}

func (c *PowerlevelTestNodeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *PowerlevelTestNodeGet) Set() error {
}

func (c *PowerlevelTestNodeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Powerlevel),
        0x05,
        0x25,
    }
}
type PowerlevelTestNodeReport struct {
    *report
    node byte
    TestNodeID byte
    Statusofoperation byte
    TestFrameCount byte
    data []byte
}

func NewPowerlevelTestNodeReport(data []byte) *PowerlevelTestNodeReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &PowerlevelTestNodeReport{
        TestNodeID: data[0],
        Statusofoperation: data[1],
        TestFrameCount: data[2],
        data: data,
    }
}

type PowerlevelTestNodeSet struct {
    node byte
    TestNodeID byte
    Powerlevel byte
    Testframecount byte
}

func (c *PowerlevelTestNodeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *PowerlevelTestNodeSet) Set(TestNodeID byte,Powerlevel byte,Testframecount byte,) error {
    c.TestNodeID = TestNodeID
    c.Powerlevel = Powerlevel
    c.Testframecount = Testframecount
}

func (c *PowerlevelTestNodeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Powerlevel),
        0x04,
        TestNodeID,
        Powerlevel,
        Testframecount,
        0x25,
    }
}
package commands
type CmdEncapsulation struct {
    node byte
    Data byte
}

func (c *CmdEncapsulation) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdEncapsulation) Set(Data byte,) error {
    c.Data = Data
}

func (c *CmdEncapsulation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(PrepaymentEncapsulation),
        0x01,
        Data,
        0x25,
    }
}
package commands
type PrepaymentBalanceGet struct {
    node byte
    Properties1 byte
}

func (c *PrepaymentBalanceGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *PrepaymentBalanceGet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *PrepaymentBalanceGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Prepayment),
        0x01,
        Properties1,
        0x25,
    }
}
type PrepaymentBalanceReport struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    BalanceValue byte
    Properties3 byte
    Debt byte
    Properties4 byte
    EmerCredit byte
    Currency byte
    DebtRecoveryPercentage byte
    data []byte
}

func NewPrepaymentBalanceReport(data []byte) *PrepaymentBalanceReport {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &PrepaymentBalanceReport{
        Properties1: data[0],
        Properties2: data[1],
        BalanceValue: data[2],
        Properties3: data[3],
        Debt: data[4],
        Properties4: data[5],
        EmerCredit: data[6],
        Currency: data[7],
        DebtRecoveryPercentage: data[8],
        data: data,
    }
}

type PrepaymentSupportedGet struct {
    node byte
}

func (c *PrepaymentSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *PrepaymentSupportedGet) Set() error {
}

func (c *PrepaymentSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Prepayment),
        0x03,
        0x25,
    }
}
type PrepaymentSupportedReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewPrepaymentSupportedReport(data []byte) *PrepaymentSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &PrepaymentSupportedReport{
        Properties1: data[0],
        data: data,
    }
}

package commands
type ProprietaryGet struct {
    node byte
    Data byte
}

func (c *ProprietaryGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProprietaryGet) Set(Data byte,) error {
    c.Data = Data
}

func (c *ProprietaryGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Proprietary),
        0x02,
        Data,
        0x25,
    }
}
type ProprietaryReport struct {
    *report
    node byte
    Data byte
    data []byte
}

func NewProprietaryReport(data []byte) *ProprietaryReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ProprietaryReport{
        Data: data[0],
        data: data,
    }
}

type ProprietarySet struct {
    node byte
    Data byte
}

func (c *ProprietarySet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProprietarySet) Set(Data byte,) error {
    c.Data = Data
}

func (c *ProprietarySet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Proprietary),
        0x01,
        Data,
        0x25,
    }
}
package commands
type ProtectionGet struct {
    node byte
}

func (c *ProtectionGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionGet) Set() error {
}

func (c *ProtectionGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Protection),
        0x02,
        0x25,
    }
}
type ProtectionReport struct {
    *report
    node byte
    ProtectionState byte
    data []byte
}

func NewProtectionReport(data []byte) *ProtectionReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ProtectionReport{
        ProtectionState: data[0],
        data: data,
    }
}

type ProtectionSet struct {
    node byte
    ProtectionState byte
}

func (c *ProtectionSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionSet) Set(ProtectionState byte,) error {
    c.ProtectionState = ProtectionState
}

func (c *ProtectionSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Protection),
        0x01,
        ProtectionState,
        0x25,
    }
}
package commands
type ProtectionEcGetV2 struct {
    node byte
}

func (c *ProtectionEcGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionEcGetV2) Set() error {
}

func (c *ProtectionEcGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ProtectionV2),
        0x07,
        0x25,
    }
}
type ProtectionEcReportV2 struct {
    *report
    node byte
    NodeID byte
    data []byte
}

func NewProtectionEcReportV2(data []byte) *ProtectionEcReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ProtectionEcReportV2{
        NodeID: data[0],
        data: data,
    }
}

type ProtectionEcSetV2 struct {
    node byte
    NodeID byte
}

func (c *ProtectionEcSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionEcSetV2) Set(NodeID byte,) error {
    c.NodeID = NodeID
}

func (c *ProtectionEcSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ProtectionV2),
        0x06,
        NodeID,
        0x25,
    }
}
type ProtectionGetV2 struct {
    node byte
}

func (c *ProtectionGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionGetV2) Set() error {
}

func (c *ProtectionGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ProtectionV2),
        0x02,
        0x25,
    }
}
type ProtectionReportV2 struct {
    *report
    node byte
    Level byte
    Level2 byte
    data []byte
}

func NewProtectionReportV2(data []byte) *ProtectionReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ProtectionReportV2{
        Level: data[0],
        Level2: data[1],
        data: data,
    }
}

type ProtectionSetV2 struct {
    node byte
    Level byte
    Level2 byte
}

func (c *ProtectionSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionSetV2) Set(Level byte,Level2 byte,) error {
    c.Level = Level
    c.Level2 = Level2
}

func (c *ProtectionSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ProtectionV2),
        0x01,
        Level,
        Level2,
        0x25,
    }
}
type ProtectionSupportedGetV2 struct {
    node byte
}

func (c *ProtectionSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionSupportedGetV2) Set() error {
}

func (c *ProtectionSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ProtectionV2),
        0x04,
        0x25,
    }
}
type ProtectionSupportedReportV2 struct {
    *report
    node byte
    Level byte
    LocalProtectionState byte
    RFProtectionState byte
    data []byte
}

func NewProtectionSupportedReportV2(data []byte) *ProtectionSupportedReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ProtectionSupportedReportV2{
        Level: data[0],
        LocalProtectionState: data[1],
        RFProtectionState: data[2],
        data: data,
    }
}

type ProtectionTimeoutGetV2 struct {
    node byte
}

func (c *ProtectionTimeoutGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionTimeoutGetV2) Set() error {
}

func (c *ProtectionTimeoutGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ProtectionV2),
        0x0A,
        0x25,
    }
}
type ProtectionTimeoutReportV2 struct {
    *report
    node byte
    Timeout byte
    data []byte
}

func NewProtectionTimeoutReportV2(data []byte) *ProtectionTimeoutReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ProtectionTimeoutReportV2{
        Timeout: data[0],
        data: data,
    }
}

type ProtectionTimeoutSetV2 struct {
    node byte
    Timeout byte
}

func (c *ProtectionTimeoutSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ProtectionTimeoutSetV2) Set(Timeout byte,) error {
    c.Timeout = Timeout
}

func (c *ProtectionTimeoutSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ProtectionV2),
        0x09,
        Timeout,
        0x25,
    }
}
package commands
type RateTblRemove struct {
    node byte
    Properties1 byte
    RateParameterSetID byte
}

func (c *RateTblRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblRemove) Set(Properties1 byte,RateParameterSetID byte,) error {
    c.Properties1 = Properties1
    c.RateParameterSetID = RateParameterSetID
}

func (c *RateTblRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(RateTblConfig),
        0x02,
        Properties1,
        RateParameterSetID,
        0x25,
    }
}
type RateTblSet struct {
    node byte
    RateParameterSetID byte
    Properties1 byte
    RateCharacter byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    DurationMinute byte
    Properties2 byte
    MinConsumptionValue byte
    MaxConsumptionValue byte
    Properties3 byte
    MaxDemandValue byte
    DCPRateID byte
}

func (c *RateTblSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblSet) Set(RateParameterSetID byte,Properties1 byte,RateCharacter byte,StartHourLocalTime byte,StartMinuteLocalTime byte,DurationMinute byte,Properties2 byte,MinConsumptionValue byte,MaxConsumptionValue byte,Properties3 byte,MaxDemandValue byte,DCPRateID byte,) error {
    c.RateParameterSetID = RateParameterSetID
    c.Properties1 = Properties1
    c.RateCharacter = RateCharacter
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.DurationMinute = DurationMinute
    c.Properties2 = Properties2
    c.MinConsumptionValue = MinConsumptionValue
    c.MaxConsumptionValue = MaxConsumptionValue
    c.Properties3 = Properties3
    c.MaxDemandValue = MaxDemandValue
    c.DCPRateID = DCPRateID
}

func (c *RateTblSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(12),
        byte(RateTblConfig),
        0x01,
        RateParameterSetID,
        Properties1,
        RateCharacter,
        StartHourLocalTime,
        StartMinuteLocalTime,
        DurationMinute,
        Properties2,
        MinConsumptionValue,
        MaxConsumptionValue,
        Properties3,
        MaxDemandValue,
        DCPRateID,
        0x25,
    }
}
package commands
type RateTblActiveRateGet struct {
    node byte
}

func (c *RateTblActiveRateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblActiveRateGet) Set() error {
}

func (c *RateTblActiveRateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(RateTblMonitor),
        0x05,
        0x25,
    }
}
type RateTblActiveRateReport struct {
    *report
    node byte
    RateParameterSetID byte
    data []byte
}

func NewRateTblActiveRateReport(data []byte) *RateTblActiveRateReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &RateTblActiveRateReport{
        RateParameterSetID: data[0],
        data: data,
    }
}

type RateTblCurrentDataGet struct {
    node byte
    RateParameterSetID byte
    DatasetRequested byte
}

func (c *RateTblCurrentDataGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblCurrentDataGet) Set(RateParameterSetID byte,DatasetRequested byte,) error {
    c.RateParameterSetID = RateParameterSetID
    c.DatasetRequested = DatasetRequested
}

func (c *RateTblCurrentDataGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(RateTblMonitor),
        0x07,
        RateParameterSetID,
        DatasetRequested,
        0x25,
    }
}
type RateTblCurrentDataReport struct {
    *report
    node byte
    ReportstoFollow byte
    RateParameterSetID byte
    Dataset byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewRateTblCurrentDataReport(data []byte) *RateTblCurrentDataReport {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &RateTblCurrentDataReport{
        ReportstoFollow: data[0],
        RateParameterSetID: data[1],
        Dataset: data[2],
        Year: data[3],
        Month: data[4],
        Day: data[5],
        HourLocalTime: data[6],
        MinuteLocalTime: data[7],
        SecondLocalTime: data[8],
        data: data,
    }
}

type RateTblGet struct {
    node byte
    RateParameterSetID byte
}

func (c *RateTblGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblGet) Set(RateParameterSetID byte,) error {
    c.RateParameterSetID = RateParameterSetID
}

func (c *RateTblGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(RateTblMonitor),
        0x03,
        RateParameterSetID,
        0x25,
    }
}
type RateTblHistoricalDataGet struct {
    node byte
    MaximumReports byte
    RateParameterSetID byte
    DatasetRequested byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StartSecondLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
    StopSecondLocalTime byte
}

func (c *RateTblHistoricalDataGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblHistoricalDataGet) Set(MaximumReports byte,RateParameterSetID byte,DatasetRequested byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StartSecondLocalTime byte,StopYear byte,StopMonth byte,StopDay byte,StopHourLocalTime byte,StopMinuteLocalTime byte,StopSecondLocalTime byte,) error {
    c.MaximumReports = MaximumReports
    c.RateParameterSetID = RateParameterSetID
    c.DatasetRequested = DatasetRequested
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StartSecondLocalTime = StartSecondLocalTime
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHourLocalTime = StopHourLocalTime
    c.StopMinuteLocalTime = StopMinuteLocalTime
    c.StopSecondLocalTime = StopSecondLocalTime
}

func (c *RateTblHistoricalDataGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(15),
        byte(RateTblMonitor),
        0x09,
        MaximumReports,
        RateParameterSetID,
        DatasetRequested,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StartSecondLocalTime,
        StopYear,
        StopMonth,
        StopDay,
        StopHourLocalTime,
        StopMinuteLocalTime,
        StopSecondLocalTime,
        0x25,
    }
}
type RateTblHistoricalDataReport struct {
    *report
    node byte
    ReportstoFollow byte
    RateParameterSetID byte
    Dataset byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewRateTblHistoricalDataReport(data []byte) *RateTblHistoricalDataReport {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &RateTblHistoricalDataReport{
        ReportstoFollow: data[0],
        RateParameterSetID: data[1],
        Dataset: data[2],
        Year: data[3],
        Month: data[4],
        Day: data[5],
        HourLocalTime: data[6],
        MinuteLocalTime: data[7],
        SecondLocalTime: data[8],
        data: data,
    }
}

type RateTblReport struct {
    *report
    node byte
    RateParameterSetID byte
    Properties1 byte
    RateCharacter byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    DurationMinute byte
    Properties2 byte
    MinConsumptionValue byte
    MaxConsumptionValue byte
    Properties3 byte
    MaxDemandValue byte
    DCPRateID byte
    data []byte
}

func NewRateTblReport(data []byte) *RateTblReport {
    if len(data) < 12 {
        for i := len(data); i < 12; i++ {
            data = append(data, 0x00)
        }
    }

    return &RateTblReport{
        RateParameterSetID: data[0],
        Properties1: data[1],
        RateCharacter: data[2],
        StartHourLocalTime: data[3],
        StartMinuteLocalTime: data[4],
        DurationMinute: data[5],
        Properties2: data[6],
        MinConsumptionValue: data[7],
        MaxConsumptionValue: data[8],
        Properties3: data[9],
        MaxDemandValue: data[10],
        DCPRateID: data[11],
        data: data,
    }
}

type RateTblSupportedGet struct {
    node byte
}

func (c *RateTblSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RateTblSupportedGet) Set() error {
}

func (c *RateTblSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(RateTblMonitor),
        0x01,
        0x25,
    }
}
type RateTblSupportedReport struct {
    *report
    node byte
    RatesSupported byte
    ParameterSetSupportedBitMask byte
    data []byte
}

func NewRateTblSupportedReport(data []byte) *RateTblSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &RateTblSupportedReport{
        RatesSupported: data[0],
        ParameterSetSupportedBitMask: data[1],
        data: data,
    }
}

package commands
type RemoteAssociationActivate struct {
    node byte
    Groupingidentifier byte
}

func (c *RemoteAssociationActivate) SetNode(node int) {
    c.node = byte(node)
}

func (c *RemoteAssociationActivate) Set(Groupingidentifier byte,) error {
    c.Groupingidentifier = Groupingidentifier
}

func (c *RemoteAssociationActivate) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(RemoteAssociationActivate),
        0x01,
        Groupingidentifier,
        0x25,
    }
}
package commands
type RemoteAssociationConfigurationGet struct {
    node byte
    LocalGroupingidentifier byte
}

func (c *RemoteAssociationConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RemoteAssociationConfigurationGet) Set(LocalGroupingidentifier byte,) error {
    c.LocalGroupingidentifier = LocalGroupingidentifier
}

func (c *RemoteAssociationConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(RemoteAssociation),
        0x02,
        LocalGroupingidentifier,
        0x25,
    }
}
type RemoteAssociationConfigurationReport struct {
    *report
    node byte
    LocalGroupingidentifier byte
    RemoteNodeID byte
    RemoteGroupingidentifier byte
    data []byte
}

func NewRemoteAssociationConfigurationReport(data []byte) *RemoteAssociationConfigurationReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &RemoteAssociationConfigurationReport{
        LocalGroupingidentifier: data[0],
        RemoteNodeID: data[1],
        RemoteGroupingidentifier: data[2],
        data: data,
    }
}

type RemoteAssociationConfigurationSet struct {
    node byte
    LocalGroupingidentifier byte
    RemoteNodeID byte
    RemoteGroupingidentifier byte
}

func (c *RemoteAssociationConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *RemoteAssociationConfigurationSet) Set(LocalGroupingidentifier byte,RemoteNodeID byte,RemoteGroupingidentifier byte,) error {
    c.LocalGroupingidentifier = LocalGroupingidentifier
    c.RemoteNodeID = RemoteNodeID
    c.RemoteGroupingidentifier = RemoteGroupingidentifier
}

func (c *RemoteAssociationConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(RemoteAssociation),
        0x01,
        LocalGroupingidentifier,
        RemoteNodeID,
        RemoteGroupingidentifier,
        0x25,
    }
}
package commands
type SceneActivationSet struct {
    node byte
    SceneID byte
    DimmingDuration byte
}

func (c *SceneActivationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SceneActivationSet) Set(SceneID byte,DimmingDuration byte,) error {
    c.SceneID = SceneID
    c.DimmingDuration = DimmingDuration
}

func (c *SceneActivationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SceneActivation),
        0x01,
        SceneID,
        DimmingDuration,
        0x25,
    }
}
package commands
type SceneActuatorConfGet struct {
    node byte
    SceneID byte
}

func (c *SceneActuatorConfGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SceneActuatorConfGet) Set(SceneID byte,) error {
    c.SceneID = SceneID
}

func (c *SceneActuatorConfGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SceneActuatorConf),
        0x02,
        SceneID,
        0x25,
    }
}
type SceneActuatorConfReport struct {
    *report
    node byte
    SceneID byte
    Level byte
    DimmingDuration byte
    data []byte
}

func NewSceneActuatorConfReport(data []byte) *SceneActuatorConfReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SceneActuatorConfReport{
        SceneID: data[0],
        Level: data[1],
        DimmingDuration: data[2],
        data: data,
    }
}

type SceneActuatorConfSet struct {
    node byte
    SceneID byte
    DimmingDuration byte
    Level2 byte
    Level byte
}

func (c *SceneActuatorConfSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SceneActuatorConfSet) Set(SceneID byte,DimmingDuration byte,Level2 byte,Level byte,) error {
    c.SceneID = SceneID
    c.DimmingDuration = DimmingDuration
    c.Level2 = Level2
    c.Level = Level
}

func (c *SceneActuatorConfSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(SceneActuatorConf),
        0x01,
        SceneID,
        DimmingDuration,
        Level2,
        Level,
        0x25,
    }
}
package commands
type SceneControllerConfGet struct {
    node byte
    GroupID byte
}

func (c *SceneControllerConfGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SceneControllerConfGet) Set(GroupID byte,) error {
    c.GroupID = GroupID
}

func (c *SceneControllerConfGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SceneControllerConf),
        0x02,
        GroupID,
        0x25,
    }
}
type SceneControllerConfReport struct {
    *report
    node byte
    GroupID byte
    SceneID byte
    DimmingDuration byte
    data []byte
}

func NewSceneControllerConfReport(data []byte) *SceneControllerConfReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SceneControllerConfReport{
        GroupID: data[0],
        SceneID: data[1],
        DimmingDuration: data[2],
        data: data,
    }
}

type SceneControllerConfSet struct {
    node byte
    GroupID byte
    SceneID byte
    DimmingDuration byte
}

func (c *SceneControllerConfSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SceneControllerConfSet) Set(GroupID byte,SceneID byte,DimmingDuration byte,) error {
    c.GroupID = GroupID
    c.SceneID = SceneID
    c.DimmingDuration = DimmingDuration
}

func (c *SceneControllerConfSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(SceneControllerConf),
        0x01,
        GroupID,
        SceneID,
        DimmingDuration,
        0x25,
    }
}
package commands
type ScheduleEntryLockEnableAllSet struct {
    node byte
    Enabled byte
}

func (c *ScheduleEntryLockEnableAllSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockEnableAllSet) Set(Enabled byte,) error {
    c.Enabled = Enabled
}

func (c *ScheduleEntryLockEnableAllSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleEntryLock),
        0x02,
        Enabled,
        0x25,
    }
}
type ScheduleEntryLockEnableSet struct {
    node byte
    UserIdentifier byte
    Enabled byte
}

func (c *ScheduleEntryLockEnableSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockEnableSet) Set(UserIdentifier byte,Enabled byte,) error {
    c.UserIdentifier = UserIdentifier
    c.Enabled = Enabled
}

func (c *ScheduleEntryLockEnableSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLock),
        0x01,
        UserIdentifier,
        Enabled,
        0x25,
    }
}
type ScheduleEntryLockWeekDayGet struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockWeekDayGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockWeekDayGet) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockWeekDayGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLock),
        0x04,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockWeekDayReport struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    DayofWeek byte
    StartHour byte
    StartMinute byte
    StopHour byte
    StopMinute byte
    data []byte
}

func NewScheduleEntryLockWeekDayReport(data []byte) *ScheduleEntryLockWeekDayReport {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockWeekDayReport{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        DayofWeek: data[2],
        StartHour: data[3],
        StartMinute: data[4],
        StopHour: data[5],
        StopMinute: data[6],
        data: data,
    }
}

type ScheduleEntryLockWeekDaySet struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    DayofWeek byte
    StartHour byte
    StartMinute byte
    StopHour byte
    StopMinute byte
}

func (c *ScheduleEntryLockWeekDaySet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockWeekDaySet) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,DayofWeek byte,StartHour byte,StartMinute byte,StopHour byte,StopMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.DayofWeek = DayofWeek
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.StopHour = StopHour
    c.StopMinute = StopMinute
}

func (c *ScheduleEntryLockWeekDaySet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(ScheduleEntryLock),
        0x03,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        DayofWeek,
        StartHour,
        StartMinute,
        StopHour,
        StopMinute,
        0x25,
    }
}
type ScheduleEntryLockYearDayGet struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockYearDayGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockYearDayGet) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockYearDayGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLock),
        0x07,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockYearDayReport struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHour byte
    StartMinute byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHour byte
    StopMinute byte
    data []byte
}

func NewScheduleEntryLockYearDayReport(data []byte) *ScheduleEntryLockYearDayReport {
    if len(data) < 12 {
        for i := len(data); i < 12; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockYearDayReport{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        StartYear: data[2],
        StartMonth: data[3],
        StartDay: data[4],
        StartHour: data[5],
        StartMinute: data[6],
        StopYear: data[7],
        StopMonth: data[8],
        StopDay: data[9],
        StopHour: data[10],
        StopMinute: data[11],
        data: data,
    }
}

type ScheduleEntryLockYearDaySet struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHour byte
    StartMinute byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHour byte
    StopMinute byte
}

func (c *ScheduleEntryLockYearDaySet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockYearDaySet) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,StartYear byte,StartMonth byte,StartDay byte,StartHour byte,StartMinute byte,StopYear byte,StopMonth byte,StopDay byte,StopHour byte,StopMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHour = StopHour
    c.StopMinute = StopMinute
}

func (c *ScheduleEntryLockYearDaySet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(13),
        byte(ScheduleEntryLock),
        0x06,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        StartYear,
        StartMonth,
        StartDay,
        StartHour,
        StartMinute,
        StopYear,
        StopMonth,
        StopDay,
        StopHour,
        StopMinute,
        0x25,
    }
}
type ScheduleEntryTypeSupportedGet struct {
    node byte
}

func (c *ScheduleEntryTypeSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryTypeSupportedGet) Set() error {
}

func (c *ScheduleEntryTypeSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScheduleEntryLock),
        0x09,
        0x25,
    }
}
type ScheduleEntryTypeSupportedReport struct {
    *report
    node byte
    NumberofSlotsWeekDay byte
    NumberofSlotsYearDay byte
    data []byte
}

func NewScheduleEntryTypeSupportedReport(data []byte) *ScheduleEntryTypeSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryTypeSupportedReport{
        NumberofSlotsWeekDay: data[0],
        NumberofSlotsYearDay: data[1],
        data: data,
    }
}

package commands
type ScheduleEntryLockEnableAllSetV2 struct {
    node byte
    Enabled byte
}

func (c *ScheduleEntryLockEnableAllSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockEnableAllSetV2) Set(Enabled byte,) error {
    c.Enabled = Enabled
}

func (c *ScheduleEntryLockEnableAllSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleEntryLockV2),
        0x02,
        Enabled,
        0x25,
    }
}
type ScheduleEntryLockEnableSetV2 struct {
    node byte
    UserIdentifier byte
    Enabled byte
}

func (c *ScheduleEntryLockEnableSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockEnableSetV2) Set(UserIdentifier byte,Enabled byte,) error {
    c.UserIdentifier = UserIdentifier
    c.Enabled = Enabled
}

func (c *ScheduleEntryLockEnableSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV2),
        0x01,
        UserIdentifier,
        Enabled,
        0x25,
    }
}
type ScheduleEntryLockTimeOffsetGetV2 struct {
    node byte
}

func (c *ScheduleEntryLockTimeOffsetGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockTimeOffsetGetV2) Set() error {
}

func (c *ScheduleEntryLockTimeOffsetGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScheduleEntryLockV2),
        0x0B,
        0x25,
    }
}
type ScheduleEntryLockTimeOffsetReportV2 struct {
    *report
    node byte
    Level byte
    MinuteTZO byte
    Level2 byte
    data []byte
}

func NewScheduleEntryLockTimeOffsetReportV2(data []byte) *ScheduleEntryLockTimeOffsetReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockTimeOffsetReportV2{
        Level: data[0],
        MinuteTZO: data[1],
        Level2: data[2],
        data: data,
    }
}

type ScheduleEntryLockTimeOffsetSetV2 struct {
    node byte
    Level byte
    MinuteTZO byte
    Level2 byte
}

func (c *ScheduleEntryLockTimeOffsetSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockTimeOffsetSetV2) Set(Level byte,MinuteTZO byte,Level2 byte,) error {
    c.Level = Level
    c.MinuteTZO = MinuteTZO
    c.Level2 = Level2
}

func (c *ScheduleEntryLockTimeOffsetSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ScheduleEntryLockV2),
        0x0D,
        Level,
        MinuteTZO,
        Level2,
        0x25,
    }
}
type ScheduleEntryLockWeekDayGetV2 struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockWeekDayGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockWeekDayGetV2) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockWeekDayGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV2),
        0x04,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockWeekDayReportV2 struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    DayofWeek byte
    StartHour byte
    StartMinute byte
    StopHour byte
    StopMinute byte
    data []byte
}

func NewScheduleEntryLockWeekDayReportV2(data []byte) *ScheduleEntryLockWeekDayReportV2 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockWeekDayReportV2{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        DayofWeek: data[2],
        StartHour: data[3],
        StartMinute: data[4],
        StopHour: data[5],
        StopMinute: data[6],
        data: data,
    }
}

type ScheduleEntryLockWeekDaySetV2 struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    DayofWeek byte
    StartHour byte
    StartMinute byte
    StopHour byte
    StopMinute byte
}

func (c *ScheduleEntryLockWeekDaySetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockWeekDaySetV2) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,DayofWeek byte,StartHour byte,StartMinute byte,StopHour byte,StopMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.DayofWeek = DayofWeek
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.StopHour = StopHour
    c.StopMinute = StopMinute
}

func (c *ScheduleEntryLockWeekDaySetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(ScheduleEntryLockV2),
        0x03,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        DayofWeek,
        StartHour,
        StartMinute,
        StopHour,
        StopMinute,
        0x25,
    }
}
type ScheduleEntryLockYearDayGetV2 struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockYearDayGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockYearDayGetV2) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockYearDayGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV2),
        0x07,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockYearDayReportV2 struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHour byte
    StartMinute byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHour byte
    StopMinute byte
    data []byte
}

func NewScheduleEntryLockYearDayReportV2(data []byte) *ScheduleEntryLockYearDayReportV2 {
    if len(data) < 12 {
        for i := len(data); i < 12; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockYearDayReportV2{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        StartYear: data[2],
        StartMonth: data[3],
        StartDay: data[4],
        StartHour: data[5],
        StartMinute: data[6],
        StopYear: data[7],
        StopMonth: data[8],
        StopDay: data[9],
        StopHour: data[10],
        StopMinute: data[11],
        data: data,
    }
}

type ScheduleEntryLockYearDaySetV2 struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHour byte
    StartMinute byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHour byte
    StopMinute byte
}

func (c *ScheduleEntryLockYearDaySetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockYearDaySetV2) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,StartYear byte,StartMonth byte,StartDay byte,StartHour byte,StartMinute byte,StopYear byte,StopMonth byte,StopDay byte,StopHour byte,StopMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHour = StopHour
    c.StopMinute = StopMinute
}

func (c *ScheduleEntryLockYearDaySetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(13),
        byte(ScheduleEntryLockV2),
        0x06,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        StartYear,
        StartMonth,
        StartDay,
        StartHour,
        StartMinute,
        StopYear,
        StopMonth,
        StopDay,
        StopHour,
        StopMinute,
        0x25,
    }
}
type ScheduleEntryTypeSupportedGetV2 struct {
    node byte
}

func (c *ScheduleEntryTypeSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryTypeSupportedGetV2) Set() error {
}

func (c *ScheduleEntryTypeSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScheduleEntryLockV2),
        0x09,
        0x25,
    }
}
type ScheduleEntryTypeSupportedReportV2 struct {
    *report
    node byte
    NumberofSlotsWeekDay byte
    NumberofSlotsYearDay byte
    data []byte
}

func NewScheduleEntryTypeSupportedReportV2(data []byte) *ScheduleEntryTypeSupportedReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryTypeSupportedReportV2{
        NumberofSlotsWeekDay: data[0],
        NumberofSlotsYearDay: data[1],
        data: data,
    }
}

package commands
type ScheduleEntryLockEnableAllSetV3 struct {
    node byte
    Enabled byte
}

func (c *ScheduleEntryLockEnableAllSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockEnableAllSetV3) Set(Enabled byte,) error {
    c.Enabled = Enabled
}

func (c *ScheduleEntryLockEnableAllSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleEntryLockV3),
        0x02,
        Enabled,
        0x25,
    }
}
type ScheduleEntryLockEnableSetV3 struct {
    node byte
    UserIdentifier byte
    Enabled byte
}

func (c *ScheduleEntryLockEnableSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockEnableSetV3) Set(UserIdentifier byte,Enabled byte,) error {
    c.UserIdentifier = UserIdentifier
    c.Enabled = Enabled
}

func (c *ScheduleEntryLockEnableSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV3),
        0x01,
        UserIdentifier,
        Enabled,
        0x25,
    }
}
type ScheduleEntryLockTimeOffsetGetV3 struct {
    node byte
}

func (c *ScheduleEntryLockTimeOffsetGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockTimeOffsetGetV3) Set() error {
}

func (c *ScheduleEntryLockTimeOffsetGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScheduleEntryLockV3),
        0x0B,
        0x25,
    }
}
type ScheduleEntryLockTimeOffsetReportV3 struct {
    *report
    node byte
    Level byte
    MinuteTZO byte
    Level2 byte
    data []byte
}

func NewScheduleEntryLockTimeOffsetReportV3(data []byte) *ScheduleEntryLockTimeOffsetReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockTimeOffsetReportV3{
        Level: data[0],
        MinuteTZO: data[1],
        Level2: data[2],
        data: data,
    }
}

type ScheduleEntryLockTimeOffsetSetV3 struct {
    node byte
    Level byte
    MinuteTZO byte
    Level2 byte
}

func (c *ScheduleEntryLockTimeOffsetSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockTimeOffsetSetV3) Set(Level byte,MinuteTZO byte,Level2 byte,) error {
    c.Level = Level
    c.MinuteTZO = MinuteTZO
    c.Level2 = Level2
}

func (c *ScheduleEntryLockTimeOffsetSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ScheduleEntryLockV3),
        0x0D,
        Level,
        MinuteTZO,
        Level2,
        0x25,
    }
}
type ScheduleEntryLockWeekDayGetV3 struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockWeekDayGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockWeekDayGetV3) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockWeekDayGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV3),
        0x04,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockWeekDayReportV3 struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    DayofWeek byte
    StartHour byte
    StartMinute byte
    StopHour byte
    StopMinute byte
    data []byte
}

func NewScheduleEntryLockWeekDayReportV3(data []byte) *ScheduleEntryLockWeekDayReportV3 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockWeekDayReportV3{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        DayofWeek: data[2],
        StartHour: data[3],
        StartMinute: data[4],
        StopHour: data[5],
        StopMinute: data[6],
        data: data,
    }
}

type ScheduleEntryLockWeekDaySetV3 struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    DayofWeek byte
    StartHour byte
    StartMinute byte
    StopHour byte
    StopMinute byte
}

func (c *ScheduleEntryLockWeekDaySetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockWeekDaySetV3) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,DayofWeek byte,StartHour byte,StartMinute byte,StopHour byte,StopMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.DayofWeek = DayofWeek
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.StopHour = StopHour
    c.StopMinute = StopMinute
}

func (c *ScheduleEntryLockWeekDaySetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(ScheduleEntryLockV3),
        0x03,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        DayofWeek,
        StartHour,
        StartMinute,
        StopHour,
        StopMinute,
        0x25,
    }
}
type ScheduleEntryLockYearDayGetV3 struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockYearDayGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockYearDayGetV3) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockYearDayGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV3),
        0x07,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockYearDayReportV3 struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHour byte
    StartMinute byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHour byte
    StopMinute byte
    data []byte
}

func NewScheduleEntryLockYearDayReportV3(data []byte) *ScheduleEntryLockYearDayReportV3 {
    if len(data) < 12 {
        for i := len(data); i < 12; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockYearDayReportV3{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        StartYear: data[2],
        StartMonth: data[3],
        StartDay: data[4],
        StartHour: data[5],
        StartMinute: data[6],
        StopYear: data[7],
        StopMonth: data[8],
        StopDay: data[9],
        StopHour: data[10],
        StopMinute: data[11],
        data: data,
    }
}

type ScheduleEntryLockYearDaySetV3 struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHour byte
    StartMinute byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHour byte
    StopMinute byte
}

func (c *ScheduleEntryLockYearDaySetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockYearDaySetV3) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,StartYear byte,StartMonth byte,StartDay byte,StartHour byte,StartMinute byte,StopYear byte,StopMonth byte,StopDay byte,StopHour byte,StopMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHour = StopHour
    c.StopMinute = StopMinute
}

func (c *ScheduleEntryLockYearDaySetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(13),
        byte(ScheduleEntryLockV3),
        0x06,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        StartYear,
        StartMonth,
        StartDay,
        StartHour,
        StartMinute,
        StopYear,
        StopMonth,
        StopDay,
        StopHour,
        StopMinute,
        0x25,
    }
}
type ScheduleEntryTypeSupportedGetV3 struct {
    node byte
}

func (c *ScheduleEntryTypeSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryTypeSupportedGetV3) Set() error {
}

func (c *ScheduleEntryTypeSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScheduleEntryLockV3),
        0x09,
        0x25,
    }
}
type ScheduleEntryTypeSupportedReportV3 struct {
    *report
    node byte
    NumberofSlotsWeekDay byte
    NumberofSlotsYearDay byte
    NumberofSlotsDailyRepeating byte
    data []byte
}

func NewScheduleEntryTypeSupportedReportV3(data []byte) *ScheduleEntryTypeSupportedReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryTypeSupportedReportV3{
        NumberofSlotsWeekDay: data[0],
        NumberofSlotsYearDay: data[1],
        NumberofSlotsDailyRepeating: data[2],
        data: data,
    }
}

type ScheduleEntryLockDailyRepeatingGetV3 struct {
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
}

func (c *ScheduleEntryLockDailyRepeatingGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockDailyRepeatingGetV3) Set(UserIdentifier byte,ScheduleSlotID byte,) error {
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
}

func (c *ScheduleEntryLockDailyRepeatingGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleEntryLockV3),
        0x0E,
        UserIdentifier,
        ScheduleSlotID,
        0x25,
    }
}
type ScheduleEntryLockDailyRepeatingReportV3 struct {
    *report
    node byte
    UserIdentifier byte
    ScheduleSlotID byte
    WeekDayBitmask byte
    StartHour byte
    StartMinute byte
    DurationHour byte
    DurationMinute byte
    data []byte
}

func NewScheduleEntryLockDailyRepeatingReportV3(data []byte) *ScheduleEntryLockDailyRepeatingReportV3 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleEntryLockDailyRepeatingReportV3{
        UserIdentifier: data[0],
        ScheduleSlotID: data[1],
        WeekDayBitmask: data[2],
        StartHour: data[3],
        StartMinute: data[4],
        DurationHour: data[5],
        DurationMinute: data[6],
        data: data,
    }
}

type ScheduleEntryLockDailyRepeatingSetV3 struct {
    node byte
    SetAction byte
    UserIdentifier byte
    ScheduleSlotID byte
    WeekDayBitmask byte
    StartHour byte
    StartMinute byte
    DurationHour byte
    DurationMinute byte
}

func (c *ScheduleEntryLockDailyRepeatingSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleEntryLockDailyRepeatingSetV3) Set(SetAction byte,UserIdentifier byte,ScheduleSlotID byte,WeekDayBitmask byte,StartHour byte,StartMinute byte,DurationHour byte,DurationMinute byte,) error {
    c.SetAction = SetAction
    c.UserIdentifier = UserIdentifier
    c.ScheduleSlotID = ScheduleSlotID
    c.WeekDayBitmask = WeekDayBitmask
    c.StartHour = StartHour
    c.StartMinute = StartMinute
    c.DurationHour = DurationHour
    c.DurationMinute = DurationMinute
}

func (c *ScheduleEntryLockDailyRepeatingSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(ScheduleEntryLockV3),
        0x10,
        SetAction,
        UserIdentifier,
        ScheduleSlotID,
        WeekDayBitmask,
        StartHour,
        StartMinute,
        DurationHour,
        DurationMinute,
        0x25,
    }
}
package commands
type ScreenAttributesGet struct {
    node byte
}

func (c *ScreenAttributesGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScreenAttributesGet) Set() error {
}

func (c *ScreenAttributesGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScreenAttributes),
        0x01,
        0x25,
    }
}
type ScreenAttributesReport struct {
    *report
    node byte
    Properties1 byte
    NumberofCharactersperLine byte
    SizeofLineBuffer byte
    NumericalPresentationofaCharacter byte
    data []byte
}

func NewScreenAttributesReport(data []byte) *ScreenAttributesReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScreenAttributesReport{
        Properties1: data[0],
        NumberofCharactersperLine: data[1],
        SizeofLineBuffer: data[2],
        NumericalPresentationofaCharacter: data[3],
        data: data,
    }
}

package commands
type ScreenAttributesGetV2 struct {
    node byte
}

func (c *ScreenAttributesGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScreenAttributesGetV2) Set() error {
}

func (c *ScreenAttributesGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ScreenAttributesV2),
        0x01,
        0x25,
    }
}
type ScreenAttributesReportV2 struct {
    *report
    node byte
    Properties1 byte
    NumberofCharactersperLine byte
    SizeofLineBuffer byte
    NumericalPresentationofaCharacter byte
    ScreenTimeout byte
    data []byte
}

func NewScreenAttributesReportV2(data []byte) *ScreenAttributesReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScreenAttributesReportV2{
        Properties1: data[0],
        NumberofCharactersperLine: data[1],
        SizeofLineBuffer: data[2],
        NumericalPresentationofaCharacter: data[3],
        ScreenTimeout: data[4],
        data: data,
    }
}

package commands
type ScreenMdGet struct {
    node byte
    NumberofReports byte
    NodeID byte
}

func (c *ScreenMdGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScreenMdGet) Set(NumberofReports byte,NodeID byte,) error {
    c.NumberofReports = NumberofReports
    c.NodeID = NodeID
}

func (c *ScreenMdGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScreenMd),
        0x01,
        NumberofReports,
        NodeID,
        0x25,
    }
}
type ScreenMdReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewScreenMdReport(data []byte) *ScreenMdReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScreenMdReport{
        Properties1: data[0],
        data: data,
    }
}

package commands
type ScreenMdGetV2 struct {
    node byte
    NumberofReports byte
    NodeID byte
}

func (c *ScreenMdGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScreenMdGetV2) Set(NumberofReports byte,NodeID byte,) error {
    c.NumberofReports = NumberofReports
    c.NodeID = NodeID
}

func (c *ScreenMdGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScreenMdV2),
        0x01,
        NumberofReports,
        NodeID,
        0x25,
    }
}
type ScreenMdReportV2 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    data []byte
}

func NewScreenMdReportV2(data []byte) *ScreenMdReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScreenMdReportV2{
        Properties1: data[0],
        Properties2: data[1],
        data: data,
    }
}

package commands
type SecurityPanelModeGet struct {
    node byte
}

func (c *SecurityPanelModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelModeGet) Set() error {
}

func (c *SecurityPanelModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SecurityPanelMode),
        0x03,
        0x25,
    }
}
type SecurityPanelModeReport struct {
    *report
    node byte
    MODE byte
    data []byte
}

func NewSecurityPanelModeReport(data []byte) *SecurityPanelModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelModeReport{
        MODE: data[0],
        data: data,
    }
}

type SecurityPanelModeSet struct {
    node byte
    MODE byte
}

func (c *SecurityPanelModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelModeSet) Set(MODE byte,) error {
    c.MODE = MODE
}

func (c *SecurityPanelModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SecurityPanelMode),
        0x05,
        MODE,
        0x25,
    }
}
type SecurityPanelModeSupportedGet struct {
    node byte
}

func (c *SecurityPanelModeSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelModeSupportedGet) Set() error {
}

func (c *SecurityPanelModeSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SecurityPanelMode),
        0x01,
        0x25,
    }
}
type SecurityPanelModeSupportedReport struct {
    *report
    node byte
    SupportedModeBitMask byte
    data []byte
}

func NewSecurityPanelModeSupportedReport(data []byte) *SecurityPanelModeSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelModeSupportedReport{
        SupportedModeBitMask: data[0],
        data: data,
    }
}

package commands
type CommandClassSecurityPanelZoneSensorInstalledReport struct {
    *report
    node byte
    Zonenumber byte
    NumberofSensors byte
    data []byte
}

func NewCommandClassSecurityPanelZoneSensorInstalledReport(data []byte) *CommandClassSecurityPanelZoneSensorInstalledReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandClassSecurityPanelZoneSensorInstalledReport{
        Zonenumber: data[0],
        NumberofSensors: data[1],
        data: data,
    }
}

type SecurityPanelZoneSensorTypeGet struct {
    node byte
    ZoneNumber byte
    SensorNumber byte
}

func (c *SecurityPanelZoneSensorTypeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelZoneSensorTypeGet) Set(ZoneNumber byte,SensorNumber byte,) error {
    c.ZoneNumber = ZoneNumber
    c.SensorNumber = SensorNumber
}

func (c *SecurityPanelZoneSensorTypeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SecurityPanelZoneSensor),
        0x03,
        ZoneNumber,
        SensorNumber,
        0x25,
    }
}
type SecurityPanelZoneSensorTypeReport struct {
    *report
    node byte
    ZoneNumber byte
    SensorNumber byte
    ZWaveAlarmType byte
    data []byte
}

func NewSecurityPanelZoneSensorTypeReport(data []byte) *SecurityPanelZoneSensorTypeReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelZoneSensorTypeReport{
        ZoneNumber: data[0],
        SensorNumber: data[1],
        ZWaveAlarmType: data[2],
        data: data,
    }
}

type SecurityPanelZoneSensorInstalledGet struct {
    node byte
    Zonenumber byte
}

func (c *SecurityPanelZoneSensorInstalledGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelZoneSensorInstalledGet) Set(Zonenumber byte,) error {
    c.Zonenumber = Zonenumber
}

func (c *SecurityPanelZoneSensorInstalledGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SecurityPanelZoneSensor),
        0x01,
        Zonenumber,
        0x25,
    }
}
type SecurityPanelZoneSensorStateGet struct {
    node byte
    ZoneNumber byte
    SensorNumber byte
}

func (c *SecurityPanelZoneSensorStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelZoneSensorStateGet) Set(ZoneNumber byte,SensorNumber byte,) error {
    c.ZoneNumber = ZoneNumber
    c.SensorNumber = SensorNumber
}

func (c *SecurityPanelZoneSensorStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SecurityPanelZoneSensor),
        0x05,
        ZoneNumber,
        SensorNumber,
        0x25,
    }
}
type SecurityPanelZoneSensorStateReport struct {
    *report
    node byte
    ZoneNumber byte
    SensorNumber byte
    ZWaveAlarmType byte
    ZWaveAlarmEvent byte
    EventParameters byte
    data []byte
}

func NewSecurityPanelZoneSensorStateReport(data []byte) *SecurityPanelZoneSensorStateReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelZoneSensorStateReport{
        ZoneNumber: data[0],
        SensorNumber: data[1],
        ZWaveAlarmType: data[2],
        ZWaveAlarmEvent: data[3],
        EventParameters: data[4],
        data: data,
    }
}

package commands
type SecurityPanelZoneNumberSupportedGet struct {
    node byte
}

func (c *SecurityPanelZoneNumberSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelZoneNumberSupportedGet) Set() error {
}

func (c *SecurityPanelZoneNumberSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SecurityPanelZone),
        0x01,
        0x25,
    }
}
type SecurityPanelZoneStateGet struct {
    node byte
    ZoneNumber byte
}

func (c *SecurityPanelZoneStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelZoneStateGet) Set(ZoneNumber byte,) error {
    c.ZoneNumber = ZoneNumber
}

func (c *SecurityPanelZoneStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SecurityPanelZone),
        0x05,
        ZoneNumber,
        0x25,
    }
}
type SecurityPanelZoneStateReport struct {
    *report
    node byte
    Zonenumber byte
    ZoneState byte
    data []byte
}

func NewSecurityPanelZoneStateReport(data []byte) *SecurityPanelZoneStateReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelZoneStateReport{
        Zonenumber: data[0],
        ZoneState: data[1],
        data: data,
    }
}

type SecurityPanelZoneSupportedReport struct {
    *report
    node byte
    Parameters1 byte
    data []byte
}

func NewSecurityPanelZoneSupportedReport(data []byte) *SecurityPanelZoneSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelZoneSupportedReport{
        Parameters1: data[0],
        data: data,
    }
}

type SecurityPanelZoneTypeGet struct {
    node byte
    ZoneNumber byte
}

func (c *SecurityPanelZoneTypeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityPanelZoneTypeGet) Set(ZoneNumber byte,) error {
    c.ZoneNumber = ZoneNumber
}

func (c *SecurityPanelZoneTypeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SecurityPanelZone),
        0x03,
        ZoneNumber,
        0x25,
    }
}
type SecurityPanelZoneTypeReport struct {
    *report
    node byte
    ZoneNumber byte
    ZoneType byte
    data []byte
}

func NewSecurityPanelZoneTypeReport(data []byte) *SecurityPanelZoneTypeReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityPanelZoneTypeReport{
        ZoneNumber: data[0],
        ZoneType: data[1],
        data: data,
    }
}

package commands
type NetworkKeySet struct {
    node byte
    NetworkKeybyte byte
}

func (c *NetworkKeySet) SetNode(node int) {
    c.node = byte(node)
}

func (c *NetworkKeySet) Set(NetworkKeybyte byte,) error {
    c.NetworkKeybyte = NetworkKeybyte
}

func (c *NetworkKeySet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security),
        0x06,
        NetworkKeybyte,
        0x25,
    }
}
type NetworkKeyVerify struct {
    node byte
}

func (c *NetworkKeyVerify) SetNode(node int) {
    c.node = byte(node)
}

func (c *NetworkKeyVerify) Set() error {
}

func (c *NetworkKeyVerify) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security),
        0x07,
        0x25,
    }
}
type SecurityCommandsSupportedGet struct {
    node byte
}

func (c *SecurityCommandsSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityCommandsSupportedGet) Set() error {
}

func (c *SecurityCommandsSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security),
        0x02,
        0x25,
    }
}
type SecurityCommandsSupportedReport struct {
    *report
    node byte
    Reportstofollow byte
    CommandClasssupport byte
    COMMAND_CLASS_MARK byte
    CommandClasscontrol byte
    data []byte
}

func NewSecurityCommandsSupportedReport(data []byte) *SecurityCommandsSupportedReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityCommandsSupportedReport{
        Reportstofollow: data[0],
        CommandClasssupport: data[1],
        COMMAND_CLASS_MARK: data[2],
        CommandClasscontrol: data[3],
        data: data,
    }
}

type SecurityMessageEncapsulation struct {
    node byte
    InitializationVectorbyte byte
    Properties1 byte
    Commandbyte byte
    ReceiversnonceIdentifier byte
    MessageAuthenticationCodebyte byte
}

func (c *SecurityMessageEncapsulation) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityMessageEncapsulation) Set(InitializationVectorbyte byte,Properties1 byte,Commandbyte byte,ReceiversnonceIdentifier byte,MessageAuthenticationCodebyte byte,) error {
    c.InitializationVectorbyte = InitializationVectorbyte
    c.Properties1 = Properties1
    c.Commandbyte = Commandbyte
    c.ReceiversnonceIdentifier = ReceiversnonceIdentifier
    c.MessageAuthenticationCodebyte = MessageAuthenticationCodebyte
}

func (c *SecurityMessageEncapsulation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(Security),
        0x81,
        InitializationVectorbyte,
        Properties1,
        Commandbyte,
        ReceiversnonceIdentifier,
        MessageAuthenticationCodebyte,
        0x25,
    }
}
type SecurityMessageEncapsulationNonceGet struct {
    node byte
    InitializationVectorbyte byte
    Properties1 byte
    Commandbyte byte
    ReceiversnonceIdentifier byte
    MessageAuthenticationCodebyte byte
}

func (c *SecurityMessageEncapsulationNonceGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityMessageEncapsulationNonceGet) Set(InitializationVectorbyte byte,Properties1 byte,Commandbyte byte,ReceiversnonceIdentifier byte,MessageAuthenticationCodebyte byte,) error {
    c.InitializationVectorbyte = InitializationVectorbyte
    c.Properties1 = Properties1
    c.Commandbyte = Commandbyte
    c.ReceiversnonceIdentifier = ReceiversnonceIdentifier
    c.MessageAuthenticationCodebyte = MessageAuthenticationCodebyte
}

func (c *SecurityMessageEncapsulationNonceGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(Security),
        0xC1,
        InitializationVectorbyte,
        Properties1,
        Commandbyte,
        ReceiversnonceIdentifier,
        MessageAuthenticationCodebyte,
        0x25,
    }
}
type SecurityNonceGet struct {
    node byte
}

func (c *SecurityNonceGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecurityNonceGet) Set() error {
}

func (c *SecurityNonceGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security),
        0x40,
        0x25,
    }
}
type SecurityNonceReport struct {
    *report
    node byte
    Noncebyte byte
    data []byte
}

func NewSecurityNonceReport(data []byte) *SecurityNonceReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecurityNonceReport{
        Noncebyte: data[0],
        data: data,
    }
}

type SecuritySchemeGet struct {
    node byte
    SupportedSecuritySchemes byte
}

func (c *SecuritySchemeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecuritySchemeGet) Set(SupportedSecuritySchemes byte,) error {
    c.SupportedSecuritySchemes = SupportedSecuritySchemes
}

func (c *SecuritySchemeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security),
        0x04,
        SupportedSecuritySchemes,
        0x25,
    }
}
type SecuritySchemeInherit struct {
    node byte
    SupportedSecuritySchemes byte
}

func (c *SecuritySchemeInherit) SetNode(node int) {
    c.node = byte(node)
}

func (c *SecuritySchemeInherit) Set(SupportedSecuritySchemes byte,) error {
    c.SupportedSecuritySchemes = SupportedSecuritySchemes
}

func (c *SecuritySchemeInherit) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security),
        0x08,
        SupportedSecuritySchemes,
        0x25,
    }
}
type SecuritySchemeReport struct {
    *report
    node byte
    SupportedSecuritySchemes byte
    data []byte
}

func NewSecuritySchemeReport(data []byte) *SecuritySchemeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SecuritySchemeReport{
        SupportedSecuritySchemes: data[0],
        data: data,
    }
}

package commands
type SensorAlarmGet struct {
    node byte
    SensorType byte
}

func (c *SensorAlarmGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorAlarmGet) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorAlarmGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorAlarm),
        0x01,
        SensorType,
        0x25,
    }
}
type SensorAlarmReport struct {
    *report
    node byte
    SourceNodeID byte
    SensorType byte
    SensorState byte
    Seconds byte
    data []byte
}

func NewSensorAlarmReport(data []byte) *SensorAlarmReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorAlarmReport{
        SourceNodeID: data[0],
        SensorType: data[1],
        SensorState: data[2],
        Seconds: data[3],
        data: data,
    }
}

type SensorAlarmSupportedGet struct {
    node byte
}

func (c *SensorAlarmSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorAlarmSupportedGet) Set() error {
}

func (c *SensorAlarmSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorAlarm),
        0x03,
        0x25,
    }
}
type SensorAlarmSupportedReport struct {
    *report
    node byte
    NumberofBitMasks byte
    BitMask byte
    data []byte
}

func NewSensorAlarmSupportedReport(data []byte) *SensorAlarmSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorAlarmSupportedReport{
        NumberofBitMasks: data[0],
        BitMask: data[1],
        data: data,
    }
}

package commands
type SensorBinaryGet struct {
    node byte
}

func (c *SensorBinaryGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorBinaryGet) Set() error {
}

func (c *SensorBinaryGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorBinary),
        0x02,
        0x25,
    }
}
type SensorBinaryReport struct {
    *report
    node byte
    SensorValue byte
    data []byte
}

func NewSensorBinaryReport(data []byte) *SensorBinaryReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorBinaryReport{
        SensorValue: data[0],
        data: data,
    }
}

package commands
type SensorBinaryGetV2 struct {
    node byte
    SensorType byte
}

func (c *SensorBinaryGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorBinaryGetV2) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorBinaryGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorBinaryV2),
        0x02,
        SensorType,
        0x25,
    }
}
type SensorBinaryReportV2 struct {
    *report
    node byte
    SensorValue byte
    SensorType byte
    data []byte
}

func NewSensorBinaryReportV2(data []byte) *SensorBinaryReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorBinaryReportV2{
        SensorValue: data[0],
        SensorType: data[1],
        data: data,
    }
}

type SensorBinarySupportedGetSensorV2 struct {
    node byte
}

func (c *SensorBinarySupportedGetSensorV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorBinarySupportedGetSensorV2) Set() error {
}

func (c *SensorBinarySupportedGetSensorV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorBinaryV2),
        0x01,
        0x25,
    }
}
type SensorBinarySupportedSensorReportV2 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorBinarySupportedSensorReportV2(data []byte) *SensorBinarySupportedSensorReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorBinarySupportedSensorReportV2{
        BitMask: data[0],
        data: data,
    }
}

package commands
type SensorTriggerLevelGet struct {
    node byte
}

func (c *SensorTriggerLevelGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorTriggerLevelGet) Set() error {
}

func (c *SensorTriggerLevelGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorConfiguration),
        0x02,
        0x25,
    }
}
type SensorTriggerLevelReport struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    TriggerValue byte
    data []byte
}

func NewSensorTriggerLevelReport(data []byte) *SensorTriggerLevelReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorTriggerLevelReport{
        SensorType: data[0],
        Properties1: data[1],
        TriggerValue: data[2],
        data: data,
    }
}

type SensorTriggerLevelSet struct {
    node byte
    Properties1 byte
    SensorType byte
    Properties2 byte
    TriggerValue byte
}

func (c *SensorTriggerLevelSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorTriggerLevelSet) Set(Properties1 byte,SensorType byte,Properties2 byte,TriggerValue byte,) error {
    c.Properties1 = Properties1
    c.SensorType = SensorType
    c.Properties2 = Properties2
    c.TriggerValue = TriggerValue
}

func (c *SensorTriggerLevelSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(SensorConfiguration),
        0x01,
        Properties1,
        SensorType,
        Properties2,
        TriggerValue,
        0x25,
    }
}
package commands
type SensorMultilevelGet struct {
    node byte
}

func (c *SensorMultilevelGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGet) Set() error {
}

func (c *SensorMultilevelGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevel),
        0x04,
        0x25,
    }
}
type SensorMultilevelReport struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReport(data []byte) *SensorMultilevelReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReport{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

package commands
type SensorMultilevelGetV2 struct {
    node byte
}

func (c *SensorMultilevelGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV2) Set() error {
}

func (c *SensorMultilevelGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV2),
        0x04,
        0x25,
    }
}
type SensorMultilevelReportV2 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV2(data []byte) *SensorMultilevelReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV2{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

package commands
type SensorMultilevelGetV3 struct {
    node byte
}

func (c *SensorMultilevelGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV3) Set() error {
}

func (c *SensorMultilevelGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV3),
        0x04,
        0x25,
    }
}
type SensorMultilevelReportV3 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV3(data []byte) *SensorMultilevelReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV3{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

package commands
type SensorMultilevelGetV4 struct {
    node byte
}

func (c *SensorMultilevelGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV4) Set() error {
}

func (c *SensorMultilevelGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV4),
        0x04,
        0x25,
    }
}
type SensorMultilevelReportV4 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV4(data []byte) *SensorMultilevelReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV4{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

package commands
type SensorMultilevelGetV5 struct {
    node byte
    SensorType byte
    Properties1 byte
}

func (c *SensorMultilevelGetV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV5) Set(SensorType byte,Properties1 byte,) error {
    c.SensorType = SensorType
    c.Properties1 = Properties1
}

func (c *SensorMultilevelGetV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SensorMultilevelV5),
        0x04,
        SensorType,
        Properties1,
        0x25,
    }
}
type SensorMultilevelReportV5 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV5(data []byte) *SensorMultilevelReportV5 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV5{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

type SensorMultilevelSupportedGetSensorV5 struct {
    node byte
}

func (c *SensorMultilevelSupportedGetSensorV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetSensorV5) Set() error {
}

func (c *SensorMultilevelSupportedGetSensorV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV5),
        0x01,
        0x25,
    }
}
type SensorMultilevelSupportedSensorReportV5 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorMultilevelSupportedSensorReportV5(data []byte) *SensorMultilevelSupportedSensorReportV5 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedSensorReportV5{
        BitMask: data[0],
        data: data,
    }
}

type SensorMultilevelSupportedGetScaleV5 struct {
    node byte
    SensorType byte
}

func (c *SensorMultilevelSupportedGetScaleV5) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetScaleV5) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorMultilevelSupportedGetScaleV5) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorMultilevelV5),
        0x03,
        SensorType,
        0x25,
    }
}
type SensorMultilevelSupportedScaleReportV5 struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    data []byte
}

func NewSensorMultilevelSupportedScaleReportV5(data []byte) *SensorMultilevelSupportedScaleReportV5 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedScaleReportV5{
        SensorType: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type SensorMultilevelGetV6 struct {
    node byte
    SensorType byte
    Properties1 byte
}

func (c *SensorMultilevelGetV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV6) Set(SensorType byte,Properties1 byte,) error {
    c.SensorType = SensorType
    c.Properties1 = Properties1
}

func (c *SensorMultilevelGetV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SensorMultilevelV6),
        0x04,
        SensorType,
        Properties1,
        0x25,
    }
}
type SensorMultilevelReportV6 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV6(data []byte) *SensorMultilevelReportV6 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV6{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

type SensorMultilevelSupportedGetSensorV6 struct {
    node byte
}

func (c *SensorMultilevelSupportedGetSensorV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetSensorV6) Set() error {
}

func (c *SensorMultilevelSupportedGetSensorV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV6),
        0x01,
        0x25,
    }
}
type SensorMultilevelSupportedSensorReportV6 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorMultilevelSupportedSensorReportV6(data []byte) *SensorMultilevelSupportedSensorReportV6 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedSensorReportV6{
        BitMask: data[0],
        data: data,
    }
}

type SensorMultilevelSupportedGetScaleV6 struct {
    node byte
    SensorType byte
}

func (c *SensorMultilevelSupportedGetScaleV6) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetScaleV6) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorMultilevelSupportedGetScaleV6) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorMultilevelV6),
        0x03,
        SensorType,
        0x25,
    }
}
type SensorMultilevelSupportedScaleReportV6 struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    data []byte
}

func NewSensorMultilevelSupportedScaleReportV6(data []byte) *SensorMultilevelSupportedScaleReportV6 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedScaleReportV6{
        SensorType: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type SensorMultilevelGetV7 struct {
    node byte
    SensorType byte
    Properties1 byte
}

func (c *SensorMultilevelGetV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV7) Set(SensorType byte,Properties1 byte,) error {
    c.SensorType = SensorType
    c.Properties1 = Properties1
}

func (c *SensorMultilevelGetV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SensorMultilevelV7),
        0x04,
        SensorType,
        Properties1,
        0x25,
    }
}
type SensorMultilevelReportV7 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV7(data []byte) *SensorMultilevelReportV7 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV7{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

type SensorMultilevelSupportedGetSensorV7 struct {
    node byte
}

func (c *SensorMultilevelSupportedGetSensorV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetSensorV7) Set() error {
}

func (c *SensorMultilevelSupportedGetSensorV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV7),
        0x01,
        0x25,
    }
}
type SensorMultilevelSupportedSensorReportV7 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorMultilevelSupportedSensorReportV7(data []byte) *SensorMultilevelSupportedSensorReportV7 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedSensorReportV7{
        BitMask: data[0],
        data: data,
    }
}

type SensorMultilevelSupportedGetScaleV7 struct {
    node byte
    SensorType byte
}

func (c *SensorMultilevelSupportedGetScaleV7) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetScaleV7) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorMultilevelSupportedGetScaleV7) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorMultilevelV7),
        0x03,
        SensorType,
        0x25,
    }
}
type SensorMultilevelSupportedScaleReportV7 struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    data []byte
}

func NewSensorMultilevelSupportedScaleReportV7(data []byte) *SensorMultilevelSupportedScaleReportV7 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedScaleReportV7{
        SensorType: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type SensorMultilevelGetV8 struct {
    node byte
    SensorType byte
    Properties1 byte
}

func (c *SensorMultilevelGetV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV8) Set(SensorType byte,Properties1 byte,) error {
    c.SensorType = SensorType
    c.Properties1 = Properties1
}

func (c *SensorMultilevelGetV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SensorMultilevelV8),
        0x04,
        SensorType,
        Properties1,
        0x25,
    }
}
type SensorMultilevelReportV8 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV8(data []byte) *SensorMultilevelReportV8 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV8{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

type SensorMultilevelSupportedGetSensorV8 struct {
    node byte
}

func (c *SensorMultilevelSupportedGetSensorV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetSensorV8) Set() error {
}

func (c *SensorMultilevelSupportedGetSensorV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV8),
        0x01,
        0x25,
    }
}
type SensorMultilevelSupportedSensorReportV8 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorMultilevelSupportedSensorReportV8(data []byte) *SensorMultilevelSupportedSensorReportV8 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedSensorReportV8{
        BitMask: data[0],
        data: data,
    }
}

type SensorMultilevelSupportedGetScaleV8 struct {
    node byte
    SensorType byte
}

func (c *SensorMultilevelSupportedGetScaleV8) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetScaleV8) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorMultilevelSupportedGetScaleV8) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorMultilevelV8),
        0x03,
        SensorType,
        0x25,
    }
}
type SensorMultilevelSupportedScaleReportV8 struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    data []byte
}

func NewSensorMultilevelSupportedScaleReportV8(data []byte) *SensorMultilevelSupportedScaleReportV8 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedScaleReportV8{
        SensorType: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type SensorMultilevelGetV9 struct {
    node byte
    SensorType byte
    Properties1 byte
}

func (c *SensorMultilevelGetV9) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV9) Set(SensorType byte,Properties1 byte,) error {
    c.SensorType = SensorType
    c.Properties1 = Properties1
}

func (c *SensorMultilevelGetV9) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SensorMultilevelV9),
        0x04,
        SensorType,
        Properties1,
        0x25,
    }
}
type SensorMultilevelReportV9 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV9(data []byte) *SensorMultilevelReportV9 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV9{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

type SensorMultilevelSupportedGetSensorV9 struct {
    node byte
}

func (c *SensorMultilevelSupportedGetSensorV9) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetSensorV9) Set() error {
}

func (c *SensorMultilevelSupportedGetSensorV9) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV9),
        0x01,
        0x25,
    }
}
type SensorMultilevelSupportedSensorReportV9 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorMultilevelSupportedSensorReportV9(data []byte) *SensorMultilevelSupportedSensorReportV9 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedSensorReportV9{
        BitMask: data[0],
        data: data,
    }
}

type SensorMultilevelSupportedGetScaleV9 struct {
    node byte
    SensorType byte
}

func (c *SensorMultilevelSupportedGetScaleV9) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetScaleV9) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorMultilevelSupportedGetScaleV9) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorMultilevelV9),
        0x03,
        SensorType,
        0x25,
    }
}
type SensorMultilevelSupportedScaleReportV9 struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    data []byte
}

func NewSensorMultilevelSupportedScaleReportV9(data []byte) *SensorMultilevelSupportedScaleReportV9 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedScaleReportV9{
        SensorType: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type SensorMultilevelGetV10 struct {
    node byte
    SensorType byte
    Properties1 byte
}

func (c *SensorMultilevelGetV10) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelGetV10) Set(SensorType byte,Properties1 byte,) error {
    c.SensorType = SensorType
    c.Properties1 = Properties1
}

func (c *SensorMultilevelGetV10) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SensorMultilevelV10),
        0x04,
        SensorType,
        Properties1,
        0x25,
    }
}
type SensorMultilevelReportV10 struct {
    *report
    node byte
    SensorType byte
    Level byte
    SensorValue byte
    data []byte
}

func NewSensorMultilevelReportV10(data []byte) *SensorMultilevelReportV10 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelReportV10{
        SensorType: data[0],
        Level: data[1],
        SensorValue: data[2],
        data: data,
    }
}

type SensorMultilevelSupportedGetSensorV10 struct {
    node byte
}

func (c *SensorMultilevelSupportedGetSensorV10) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetSensorV10) Set() error {
}

func (c *SensorMultilevelSupportedGetSensorV10) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SensorMultilevelV10),
        0x01,
        0x25,
    }
}
type SensorMultilevelSupportedSensorReportV10 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewSensorMultilevelSupportedSensorReportV10(data []byte) *SensorMultilevelSupportedSensorReportV10 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedSensorReportV10{
        BitMask: data[0],
        data: data,
    }
}

type SensorMultilevelSupportedGetScaleV10 struct {
    node byte
    SensorType byte
}

func (c *SensorMultilevelSupportedGetScaleV10) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorMultilevelSupportedGetScaleV10) Set(SensorType byte,) error {
    c.SensorType = SensorType
}

func (c *SensorMultilevelSupportedGetScaleV10) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SensorMultilevelV10),
        0x03,
        SensorType,
        0x25,
    }
}
type SensorMultilevelSupportedScaleReportV10 struct {
    *report
    node byte
    SensorType byte
    Properties1 byte
    data []byte
}

func NewSensorMultilevelSupportedScaleReportV10(data []byte) *SensorMultilevelSupportedScaleReportV10 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SensorMultilevelSupportedScaleReportV10{
        SensorType: data[0],
        Properties1: data[1],
        data: data,
    }
}

package commands
type SensorAlarmSet struct {
    node byte
    Mode byte
    Seconds byte
    NumberofBitMasks byte
    BitMask byte
}

func (c *SensorAlarmSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SensorAlarmSet) Set(Mode byte,Seconds byte,NumberofBitMasks byte,BitMask byte,) error {
    c.Mode = Mode
    c.Seconds = Seconds
    c.NumberofBitMasks = NumberofBitMasks
    c.BitMask = BitMask
}

func (c *SensorAlarmSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(SilenceAlarm),
        0x01,
        Mode,
        Seconds,
        NumberofBitMasks,
        BitMask,
        0x25,
    }
}
package commands
type SimpleAvControlGet struct {
    node byte
}

func (c *SimpleAvControlGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SimpleAvControlGet) Set() error {
}

func (c *SimpleAvControlGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SimpleAvControl),
        0x02,
        0x25,
    }
}
type SimpleAvControlReport struct {
    *report
    node byte
    Numberofreports byte
    data []byte
}

func NewSimpleAvControlReport(data []byte) *SimpleAvControlReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SimpleAvControlReport{
        Numberofreports: data[0],
        data: data,
    }
}

type SimpleAvControlSet struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    ItemID byte
}

func (c *SimpleAvControlSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SimpleAvControlSet) Set(SequenceNumber byte,Properties1 byte,ItemID byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.ItemID = ItemID
}

func (c *SimpleAvControlSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(SimpleAvControl),
        0x01,
        SequenceNumber,
        Properties1,
        ItemID,
        0x25,
    }
}
type SimpleAvControlSupportedGet struct {
    node byte
    ReportNo byte
}

func (c *SimpleAvControlSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SimpleAvControlSupportedGet) Set(ReportNo byte,) error {
    c.ReportNo = ReportNo
}

func (c *SimpleAvControlSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SimpleAvControl),
        0x04,
        ReportNo,
        0x25,
    }
}
type SimpleAvControlSupportedReport struct {
    *report
    node byte
    ReportNo byte
    BitMask byte
    data []byte
}

func NewSimpleAvControlSupportedReport(data []byte) *SimpleAvControlSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SimpleAvControlSupportedReport{
        ReportNo: data[0],
        BitMask: data[1],
        data: data,
    }
}

package commands
type SwitchAllGet struct {
    node byte
}

func (c *SwitchAllGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchAllGet) Set() error {
}

func (c *SwitchAllGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchAll),
        0x02,
        0x25,
    }
}
type SwitchAllOff struct {
    node byte
}

func (c *SwitchAllOff) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchAllOff) Set() error {
}

func (c *SwitchAllOff) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchAll),
        0x05,
        0x25,
    }
}
type SwitchAllOn struct {
    node byte
}

func (c *SwitchAllOn) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchAllOn) Set() error {
}

func (c *SwitchAllOn) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchAll),
        0x04,
        0x25,
    }
}
type SwitchAllReport struct {
    *report
    node byte
    Mode byte
    data []byte
}

func NewSwitchAllReport(data []byte) *SwitchAllReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchAllReport{
        Mode: data[0],
        data: data,
    }
}

type SwitchAllSet struct {
    node byte
    Mode byte
}

func (c *SwitchAllSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchAllSet) Set(Mode byte,) error {
    c.Mode = Mode
}

func (c *SwitchAllSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchAll),
        0x01,
        Mode,
        0x25,
    }
}
package commands
type SwitchBinaryGet struct {
    node byte
}

func (c *SwitchBinaryGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchBinaryGet) Set() error {
}

func (c *SwitchBinaryGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchBinary),
        0x02,
        0x25,
    }
}
type SwitchBinaryReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewSwitchBinaryReport(data []byte) *SwitchBinaryReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchBinaryReport{
        Value: data[0],
        data: data,
    }
}

type SwitchBinarySet struct {
    node byte
    SwitchValue byte
}

func (c *SwitchBinarySet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchBinarySet) Set(SwitchValue byte,) error {
    c.SwitchValue = SwitchValue
}

func (c *SwitchBinarySet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchBinary),
        0x01,
        SwitchValue,
        0x25,
    }
}
package commands
type SwitchBinaryGetV2 struct {
    node byte
}

func (c *SwitchBinaryGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchBinaryGetV2) Set() error {
}

func (c *SwitchBinaryGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchBinaryV2),
        0x02,
        0x25,
    }
}
type SwitchBinaryReportV2 struct {
    *report
    node byte
    CurrentValue byte
    TargetValue byte
    Duration byte
    data []byte
}

func NewSwitchBinaryReportV2(data []byte) *SwitchBinaryReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchBinaryReportV2{
        CurrentValue: data[0],
        TargetValue: data[1],
        Duration: data[2],
        data: data,
    }
}

type SwitchBinarySetV2 struct {
    node byte
    TargetValue byte
    Duration byte
}

func (c *SwitchBinarySetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchBinarySetV2) Set(TargetValue byte,Duration byte,) error {
    c.TargetValue = TargetValue
    c.Duration = Duration
}

func (c *SwitchBinarySetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchBinaryV2),
        0x01,
        TargetValue,
        Duration,
        0x25,
    }
}
package commands
type SwitchMultilevelGet struct {
    node byte
}

func (c *SwitchMultilevelGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelGet) Set() error {
}

func (c *SwitchMultilevelGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevel),
        0x02,
        0x25,
    }
}
type SwitchMultilevelReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewSwitchMultilevelReport(data []byte) *SwitchMultilevelReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchMultilevelReport{
        Value: data[0],
        data: data,
    }
}

type SwitchMultilevelSet struct {
    node byte
    Value byte
}

func (c *SwitchMultilevelSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelSet) Set(Value byte,) error {
    c.Value = Value
}

func (c *SwitchMultilevelSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchMultilevel),
        0x01,
        Value,
        0x25,
    }
}
type SwitchMultilevelStartLevelChange struct {
    node byte
    Level byte
    StartLevel byte
}

func (c *SwitchMultilevelStartLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStartLevelChange) Set(Level byte,StartLevel byte,) error {
    c.Level = Level
    c.StartLevel = StartLevel
}

func (c *SwitchMultilevelStartLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchMultilevel),
        0x04,
        Level,
        StartLevel,
        0x25,
    }
}
type SwitchMultilevelStopLevelChange struct {
    node byte
}

func (c *SwitchMultilevelStopLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStopLevelChange) Set() error {
}

func (c *SwitchMultilevelStopLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevel),
        0x05,
        0x25,
    }
}
package commands
type SwitchMultilevelGetV2 struct {
    node byte
}

func (c *SwitchMultilevelGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelGetV2) Set() error {
}

func (c *SwitchMultilevelGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV2),
        0x02,
        0x25,
    }
}
type SwitchMultilevelReportV2 struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewSwitchMultilevelReportV2(data []byte) *SwitchMultilevelReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchMultilevelReportV2{
        Value: data[0],
        data: data,
    }
}

type SwitchMultilevelSetV2 struct {
    node byte
    Value byte
    DimmingDuration byte
}

func (c *SwitchMultilevelSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelSetV2) Set(Value byte,DimmingDuration byte,) error {
    c.Value = Value
    c.DimmingDuration = DimmingDuration
}

func (c *SwitchMultilevelSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchMultilevelV2),
        0x01,
        Value,
        DimmingDuration,
        0x25,
    }
}
type SwitchMultilevelStartLevelChangeV2 struct {
    node byte
    Properties1 byte
    StartLevel byte
    DimmingDuration byte
}

func (c *SwitchMultilevelStartLevelChangeV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStartLevelChangeV2) Set(Properties1 byte,StartLevel byte,DimmingDuration byte,) error {
    c.Properties1 = Properties1
    c.StartLevel = StartLevel
    c.DimmingDuration = DimmingDuration
}

func (c *SwitchMultilevelStartLevelChangeV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(SwitchMultilevelV2),
        0x04,
        Properties1,
        StartLevel,
        DimmingDuration,
        0x25,
    }
}
type SwitchMultilevelStopLevelChangeV2 struct {
    node byte
}

func (c *SwitchMultilevelStopLevelChangeV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStopLevelChangeV2) Set() error {
}

func (c *SwitchMultilevelStopLevelChangeV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV2),
        0x05,
        0x25,
    }
}
package commands
type SwitchMultilevelGetV3 struct {
    node byte
}

func (c *SwitchMultilevelGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelGetV3) Set() error {
}

func (c *SwitchMultilevelGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV3),
        0x02,
        0x25,
    }
}
type SwitchMultilevelReportV3 struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewSwitchMultilevelReportV3(data []byte) *SwitchMultilevelReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchMultilevelReportV3{
        Value: data[0],
        data: data,
    }
}

type SwitchMultilevelSetV3 struct {
    node byte
    Value byte
    DimmingDuration byte
}

func (c *SwitchMultilevelSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelSetV3) Set(Value byte,DimmingDuration byte,) error {
    c.Value = Value
    c.DimmingDuration = DimmingDuration
}

func (c *SwitchMultilevelSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchMultilevelV3),
        0x01,
        Value,
        DimmingDuration,
        0x25,
    }
}
type SwitchMultilevelStartLevelChangeV3 struct {
    node byte
    Properties1 byte
    StartLevel byte
    DimmingDuration byte
    StepSize byte
}

func (c *SwitchMultilevelStartLevelChangeV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStartLevelChangeV3) Set(Properties1 byte,StartLevel byte,DimmingDuration byte,StepSize byte,) error {
    c.Properties1 = Properties1
    c.StartLevel = StartLevel
    c.DimmingDuration = DimmingDuration
    c.StepSize = StepSize
}

func (c *SwitchMultilevelStartLevelChangeV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(SwitchMultilevelV3),
        0x04,
        Properties1,
        StartLevel,
        DimmingDuration,
        StepSize,
        0x25,
    }
}
type SwitchMultilevelStopLevelChangeV3 struct {
    node byte
}

func (c *SwitchMultilevelStopLevelChangeV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStopLevelChangeV3) Set() error {
}

func (c *SwitchMultilevelStopLevelChangeV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV3),
        0x05,
        0x25,
    }
}
type SwitchMultilevelSupportedGetV3 struct {
    node byte
}

func (c *SwitchMultilevelSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelSupportedGetV3) Set() error {
}

func (c *SwitchMultilevelSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV3),
        0x06,
        0x25,
    }
}
type SwitchMultilevelSupportedReportV3 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    data []byte
}

func NewSwitchMultilevelSupportedReportV3(data []byte) *SwitchMultilevelSupportedReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchMultilevelSupportedReportV3{
        Properties1: data[0],
        Properties2: data[1],
        data: data,
    }
}

package commands
type SwitchMultilevelGetV4 struct {
    node byte
}

func (c *SwitchMultilevelGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelGetV4) Set() error {
}

func (c *SwitchMultilevelGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV4),
        0x02,
        0x25,
    }
}
type SwitchMultilevelReportV4 struct {
    *report
    node byte
    CurrentValue byte
    TargetValue byte
    Duration byte
    data []byte
}

func NewSwitchMultilevelReportV4(data []byte) *SwitchMultilevelReportV4 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchMultilevelReportV4{
        CurrentValue: data[0],
        TargetValue: data[1],
        Duration: data[2],
        data: data,
    }
}

type SwitchMultilevelSetV4 struct {
    node byte
    Value byte
    DimmingDuration byte
}

func (c *SwitchMultilevelSetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelSetV4) Set(Value byte,DimmingDuration byte,) error {
    c.Value = Value
    c.DimmingDuration = DimmingDuration
}

func (c *SwitchMultilevelSetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchMultilevelV4),
        0x01,
        Value,
        DimmingDuration,
        0x25,
    }
}
type SwitchMultilevelStartLevelChangeV4 struct {
    node byte
    Properties1 byte
    StartLevel byte
    DimmingDuration byte
    StepSize byte
}

func (c *SwitchMultilevelStartLevelChangeV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStartLevelChangeV4) Set(Properties1 byte,StartLevel byte,DimmingDuration byte,StepSize byte,) error {
    c.Properties1 = Properties1
    c.StartLevel = StartLevel
    c.DimmingDuration = DimmingDuration
    c.StepSize = StepSize
}

func (c *SwitchMultilevelStartLevelChangeV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(SwitchMultilevelV4),
        0x04,
        Properties1,
        StartLevel,
        DimmingDuration,
        StepSize,
        0x25,
    }
}
type SwitchMultilevelStopLevelChangeV4 struct {
    node byte
}

func (c *SwitchMultilevelStopLevelChangeV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelStopLevelChangeV4) Set() error {
}

func (c *SwitchMultilevelStopLevelChangeV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV4),
        0x05,
        0x25,
    }
}
type SwitchMultilevelSupportedGetV4 struct {
    node byte
}

func (c *SwitchMultilevelSupportedGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchMultilevelSupportedGetV4) Set() error {
}

func (c *SwitchMultilevelSupportedGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchMultilevelV4),
        0x06,
        0x25,
    }
}
type SwitchMultilevelSupportedReportV4 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    data []byte
}

func NewSwitchMultilevelSupportedReportV4(data []byte) *SwitchMultilevelSupportedReportV4 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchMultilevelSupportedReportV4{
        Properties1: data[0],
        Properties2: data[1],
        data: data,
    }
}

package commands
type SwitchToggleBinarySet struct {
    node byte
}

func (c *SwitchToggleBinarySet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchToggleBinarySet) Set() error {
}

func (c *SwitchToggleBinarySet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchToggleBinary),
        0x01,
        0x25,
    }
}
type SwitchToggleBinaryGet struct {
    node byte
}

func (c *SwitchToggleBinaryGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchToggleBinaryGet) Set() error {
}

func (c *SwitchToggleBinaryGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchToggleBinary),
        0x02,
        0x25,
    }
}
type SwitchToggleBinaryReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewSwitchToggleBinaryReport(data []byte) *SwitchToggleBinaryReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchToggleBinaryReport{
        Value: data[0],
        data: data,
    }
}

package commands
type SwitchToggleMultilevelSet struct {
    node byte
}

func (c *SwitchToggleMultilevelSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchToggleMultilevelSet) Set() error {
}

func (c *SwitchToggleMultilevelSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchToggleMultilevel),
        0x01,
        0x25,
    }
}
type SwitchToggleMultilevelGet struct {
    node byte
}

func (c *SwitchToggleMultilevelGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchToggleMultilevelGet) Set() error {
}

func (c *SwitchToggleMultilevelGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchToggleMultilevel),
        0x02,
        0x25,
    }
}
type SwitchToggleMultilevelReport struct {
    *report
    node byte
    Value byte
    data []byte
}

func NewSwitchToggleMultilevelReport(data []byte) *SwitchToggleMultilevelReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchToggleMultilevelReport{
        Value: data[0],
        data: data,
    }
}

type SwitchToggleMultilevelStartLevelChange struct {
    node byte
    Level byte
    StartLevel byte
}

func (c *SwitchToggleMultilevelStartLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchToggleMultilevelStartLevelChange) Set(Level byte,StartLevel byte,) error {
    c.Level = Level
    c.StartLevel = StartLevel
}

func (c *SwitchToggleMultilevelStartLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchToggleMultilevel),
        0x04,
        Level,
        StartLevel,
        0x25,
    }
}
type SwitchToggleMultilevelStopLevelChange struct {
    node byte
}

func (c *SwitchToggleMultilevelStopLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchToggleMultilevelStopLevelChange) Set() error {
}

func (c *SwitchToggleMultilevelStopLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchToggleMultilevel),
        0x05,
        0x25,
    }
}
package commands
type TariffTblRemove struct {
    node byte
    Properties1 byte
    RateParameterSetID byte
}

func (c *TariffTblRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *TariffTblRemove) Set(Properties1 byte,RateParameterSetID byte,) error {
    c.Properties1 = Properties1
    c.RateParameterSetID = RateParameterSetID
}

func (c *TariffTblRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(TariffConfig),
        0x03,
        Properties1,
        RateParameterSetID,
        0x25,
    }
}
type TariffTblSet struct {
    node byte
    RateParameterSetID byte
    Properties1 byte
    TariffValue byte
}

func (c *TariffTblSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TariffTblSet) Set(RateParameterSetID byte,Properties1 byte,TariffValue byte,) error {
    c.RateParameterSetID = RateParameterSetID
    c.Properties1 = Properties1
    c.TariffValue = TariffValue
}

func (c *TariffTblSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(TariffConfig),
        0x02,
        RateParameterSetID,
        Properties1,
        TariffValue,
        0x25,
    }
}
type TariffTblSupplierSet struct {
    node byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    Currency byte
    Properties1 byte
    StandingChargeValue byte
    Properties2 byte
    SupplierCharacter byte
}

func (c *TariffTblSupplierSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TariffTblSupplierSet) Set(Year byte,Month byte,Day byte,HourLocalTime byte,MinuteLocalTime byte,SecondLocalTime byte,Currency byte,Properties1 byte,StandingChargeValue byte,Properties2 byte,SupplierCharacter byte,) error {
    c.Year = Year
    c.Month = Month
    c.Day = Day
    c.HourLocalTime = HourLocalTime
    c.MinuteLocalTime = MinuteLocalTime
    c.SecondLocalTime = SecondLocalTime
    c.Currency = Currency
    c.Properties1 = Properties1
    c.StandingChargeValue = StandingChargeValue
    c.Properties2 = Properties2
    c.SupplierCharacter = SupplierCharacter
}

func (c *TariffTblSupplierSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(TariffConfig),
        0x01,
        Year,
        Month,
        Day,
        HourLocalTime,
        MinuteLocalTime,
        SecondLocalTime,
        Currency,
        Properties1,
        StandingChargeValue,
        Properties2,
        SupplierCharacter,
        0x25,
    }
}
package commands
type TariffTblCostGet struct {
    node byte
    RateParameterSetID byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
}

func (c *TariffTblCostGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TariffTblCostGet) Set(RateParameterSetID byte,StartYear byte,StartMonth byte,StartDay byte,StartHourLocalTime byte,StartMinuteLocalTime byte,StopYear byte,StopMonth byte,StopDay byte,StopHourLocalTime byte,StopMinuteLocalTime byte,) error {
    c.RateParameterSetID = RateParameterSetID
    c.StartYear = StartYear
    c.StartMonth = StartMonth
    c.StartDay = StartDay
    c.StartHourLocalTime = StartHourLocalTime
    c.StartMinuteLocalTime = StartMinuteLocalTime
    c.StopYear = StopYear
    c.StopMonth = StopMonth
    c.StopDay = StopDay
    c.StopHourLocalTime = StopHourLocalTime
    c.StopMinuteLocalTime = StopMinuteLocalTime
}

func (c *TariffTblCostGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(TariffTblMonitor),
        0x05,
        RateParameterSetID,
        StartYear,
        StartMonth,
        StartDay,
        StartHourLocalTime,
        StartMinuteLocalTime,
        StopYear,
        StopMonth,
        StopDay,
        StopHourLocalTime,
        StopMinuteLocalTime,
        0x25,
    }
}
type TariffTblCostReport struct {
    *report
    node byte
    RateParameterSetID byte
    Properties1 byte
    StartYear byte
    StartMonth byte
    StartDay byte
    StartHourLocalTime byte
    StartMinuteLocalTime byte
    StopYear byte
    StopMonth byte
    StopDay byte
    StopHourLocalTime byte
    StopMinuteLocalTime byte
    Currency byte
    Properties2 byte
    CostValue byte
    data []byte
}

func NewTariffTblCostReport(data []byte) *TariffTblCostReport {
    if len(data) < 15 {
        for i := len(data); i < 15; i++ {
            data = append(data, 0x00)
        }
    }

    return &TariffTblCostReport{
        RateParameterSetID: data[0],
        Properties1: data[1],
        StartYear: data[2],
        StartMonth: data[3],
        StartDay: data[4],
        StartHourLocalTime: data[5],
        StartMinuteLocalTime: data[6],
        StopYear: data[7],
        StopMonth: data[8],
        StopDay: data[9],
        StopHourLocalTime: data[10],
        StopMinuteLocalTime: data[11],
        Currency: data[12],
        Properties2: data[13],
        CostValue: data[14],
        data: data,
    }
}

type TariffTblGet struct {
    node byte
    RateParameterSetID byte
}

func (c *TariffTblGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TariffTblGet) Set(RateParameterSetID byte,) error {
    c.RateParameterSetID = RateParameterSetID
}

func (c *TariffTblGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(TariffTblMonitor),
        0x03,
        RateParameterSetID,
        0x25,
    }
}
type TariffTblReport struct {
    *report
    node byte
    RateParameterSetID byte
    Properties1 byte
    TariffValue byte
    data []byte
}

func NewTariffTblReport(data []byte) *TariffTblReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &TariffTblReport{
        RateParameterSetID: data[0],
        Properties1: data[1],
        TariffValue: data[2],
        data: data,
    }
}

type TariffTblSupplierGet struct {
    node byte
}

func (c *TariffTblSupplierGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TariffTblSupplierGet) Set() error {
}

func (c *TariffTblSupplierGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(TariffTblMonitor),
        0x01,
        0x25,
    }
}
type TariffTblSupplierReport struct {
    *report
    node byte
    Year byte
    Month byte
    Day byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    Currency byte
    Properties1 byte
    StandingChargeValue byte
    Properties2 byte
    SupplierCharacter byte
    data []byte
}

func NewTariffTblSupplierReport(data []byte) *TariffTblSupplierReport {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &TariffTblSupplierReport{
        Year: data[0],
        Month: data[1],
        Day: data[2],
        HourLocalTime: data[3],
        MinuteLocalTime: data[4],
        SecondLocalTime: data[5],
        Currency: data[6],
        Properties1: data[7],
        StandingChargeValue: data[8],
        Properties2: data[9],
        SupplierCharacter: data[10],
        data: data,
    }
}

package commands
type ThermostatFanModeGet struct {
    node byte
}

func (c *ThermostatFanModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeGet) Set() error {
}

func (c *ThermostatFanModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanMode),
        0x02,
        0x25,
    }
}
type ThermostatFanModeReport struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatFanModeReport(data []byte) *ThermostatFanModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeReport{
        Level: data[0],
        data: data,
    }
}

type ThermostatFanModeSet struct {
    node byte
    Level byte
}

func (c *ThermostatFanModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSet) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatFanModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatFanMode),
        0x01,
        Level,
        0x25,
    }
}
type ThermostatFanModeSupportedGet struct {
    node byte
}

func (c *ThermostatFanModeSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSupportedGet) Set() error {
}

func (c *ThermostatFanModeSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanMode),
        0x04,
        0x25,
    }
}
type ThermostatFanModeSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatFanModeSupportedReport(data []byte) *ThermostatFanModeSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatFanModeGetV2 struct {
    node byte
}

func (c *ThermostatFanModeGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeGetV2) Set() error {
}

func (c *ThermostatFanModeGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanModeV2),
        0x02,
        0x25,
    }
}
type ThermostatFanModeReportV2 struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatFanModeReportV2(data []byte) *ThermostatFanModeReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeReportV2{
        Level: data[0],
        data: data,
    }
}

type ThermostatFanModeSetV2 struct {
    node byte
    Level byte
}

func (c *ThermostatFanModeSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSetV2) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatFanModeSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatFanModeV2),
        0x01,
        Level,
        0x25,
    }
}
type ThermostatFanModeSupportedGetV2 struct {
    node byte
}

func (c *ThermostatFanModeSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSupportedGetV2) Set() error {
}

func (c *ThermostatFanModeSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanModeV2),
        0x04,
        0x25,
    }
}
type ThermostatFanModeSupportedReportV2 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatFanModeSupportedReportV2(data []byte) *ThermostatFanModeSupportedReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeSupportedReportV2{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatFanModeGetV3 struct {
    node byte
}

func (c *ThermostatFanModeGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeGetV3) Set() error {
}

func (c *ThermostatFanModeGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanModeV3),
        0x02,
        0x25,
    }
}
type ThermostatFanModeReportV3 struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewThermostatFanModeReportV3(data []byte) *ThermostatFanModeReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeReportV3{
        Properties1: data[0],
        data: data,
    }
}

type ThermostatFanModeSetV3 struct {
    node byte
    Properties1 byte
}

func (c *ThermostatFanModeSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSetV3) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *ThermostatFanModeSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatFanModeV3),
        0x01,
        Properties1,
        0x25,
    }
}
type ThermostatFanModeSupportedGetV3 struct {
    node byte
}

func (c *ThermostatFanModeSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSupportedGetV3) Set() error {
}

func (c *ThermostatFanModeSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanModeV3),
        0x04,
        0x25,
    }
}
type ThermostatFanModeSupportedReportV3 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatFanModeSupportedReportV3(data []byte) *ThermostatFanModeSupportedReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeSupportedReportV3{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatFanModeGetV4 struct {
    node byte
}

func (c *ThermostatFanModeGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeGetV4) Set() error {
}

func (c *ThermostatFanModeGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanModeV4),
        0x02,
        0x25,
    }
}
type ThermostatFanModeReportV4 struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewThermostatFanModeReportV4(data []byte) *ThermostatFanModeReportV4 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeReportV4{
        Properties1: data[0],
        data: data,
    }
}

type ThermostatFanModeSetV4 struct {
    node byte
    Properties1 byte
}

func (c *ThermostatFanModeSetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSetV4) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *ThermostatFanModeSetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatFanModeV4),
        0x01,
        Properties1,
        0x25,
    }
}
type ThermostatFanModeSupportedGetV4 struct {
    node byte
}

func (c *ThermostatFanModeSupportedGetV4) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanModeSupportedGetV4) Set() error {
}

func (c *ThermostatFanModeSupportedGetV4) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanModeV4),
        0x04,
        0x25,
    }
}
type ThermostatFanModeSupportedReportV4 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatFanModeSupportedReportV4(data []byte) *ThermostatFanModeSupportedReportV4 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanModeSupportedReportV4{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatFanStateGet struct {
    node byte
}

func (c *ThermostatFanStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanStateGet) Set() error {
}

func (c *ThermostatFanStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanState),
        0x02,
        0x25,
    }
}
type ThermostatFanStateReport struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatFanStateReport(data []byte) *ThermostatFanStateReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanStateReport{
        Level: data[0],
        data: data,
    }
}

package commands
type ThermostatFanStateGetV2 struct {
    node byte
}

func (c *ThermostatFanStateGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatFanStateGetV2) Set() error {
}

func (c *ThermostatFanStateGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatFanStateV2),
        0x02,
        0x25,
    }
}
type ThermostatFanStateReportV2 struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatFanStateReportV2(data []byte) *ThermostatFanStateReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatFanStateReportV2{
        Level: data[0],
        data: data,
    }
}

package commands
type ThermostatHeatingStatusReport struct {
    *report
    node byte
    Status byte
    data []byte
}

func NewThermostatHeatingStatusReport(data []byte) *ThermostatHeatingStatusReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatHeatingStatusReport{
        Status: data[0],
        data: data,
    }
}

type ThermostatHeatingModeGet struct {
    node byte
}

func (c *ThermostatHeatingModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingModeGet) Set() error {
}

func (c *ThermostatHeatingModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatHeating),
        0x02,
        0x25,
    }
}
type ThermostatHeatingModeReport struct {
    *report
    node byte
    Mode byte
    data []byte
}

func NewThermostatHeatingModeReport(data []byte) *ThermostatHeatingModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatHeatingModeReport{
        Mode: data[0],
        data: data,
    }
}

type ThermostatHeatingModeSet struct {
    node byte
    Mode byte
}

func (c *ThermostatHeatingModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingModeSet) Set(Mode byte,) error {
    c.Mode = Mode
}

func (c *ThermostatHeatingModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatHeating),
        0x01,
        Mode,
        0x25,
    }
}
type ThermostatHeatingRelayStatusGet struct {
    node byte
}

func (c *ThermostatHeatingRelayStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingRelayStatusGet) Set() error {
}

func (c *ThermostatHeatingRelayStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatHeating),
        0x09,
        0x25,
    }
}
type ThermostatHeatingRelayStatusReport struct {
    *report
    node byte
    RelayStatus byte
    data []byte
}

func NewThermostatHeatingRelayStatusReport(data []byte) *ThermostatHeatingRelayStatusReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatHeatingRelayStatusReport{
        RelayStatus: data[0],
        data: data,
    }
}

type ThermostatHeatingSetpointGet struct {
    node byte
    SetpointNr byte
}

func (c *ThermostatHeatingSetpointGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingSetpointGet) Set(SetpointNr byte,) error {
    c.SetpointNr = SetpointNr
}

func (c *ThermostatHeatingSetpointGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatHeating),
        0x05,
        SetpointNr,
        0x25,
    }
}
type ThermostatHeatingSetpointReport struct {
    *report
    node byte
    SetpointNr byte
    Properties1 byte
    Value byte
    data []byte
}

func NewThermostatHeatingSetpointReport(data []byte) *ThermostatHeatingSetpointReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatHeatingSetpointReport{
        SetpointNr: data[0],
        Properties1: data[1],
        Value: data[2],
        data: data,
    }
}

type ThermostatHeatingSetpointSet struct {
    node byte
    SetpointNr byte
    Properties1 byte
    Value byte
}

func (c *ThermostatHeatingSetpointSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingSetpointSet) Set(SetpointNr byte,Properties1 byte,Value byte,) error {
    c.SetpointNr = SetpointNr
    c.Properties1 = Properties1
    c.Value = Value
}

func (c *ThermostatHeatingSetpointSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ThermostatHeating),
        0x04,
        SetpointNr,
        Properties1,
        Value,
        0x25,
    }
}
type ThermostatHeatingStatusGet struct {
    node byte
}

func (c *ThermostatHeatingStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingStatusGet) Set() error {
}

func (c *ThermostatHeatingStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatHeating),
        0x0C,
        0x25,
    }
}
type ThermostatHeatingStatusSet struct {
    node byte
    Status byte
}

func (c *ThermostatHeatingStatusSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingStatusSet) Set(Status byte,) error {
    c.Status = Status
}

func (c *ThermostatHeatingStatusSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatHeating),
        0x0B,
        Status,
        0x25,
    }
}
type ThermostatHeatingTimedOffSet struct {
    node byte
    Minutes byte
    Hours byte
}

func (c *ThermostatHeatingTimedOffSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatHeatingTimedOffSet) Set(Minutes byte,Hours byte,) error {
    c.Minutes = Minutes
    c.Hours = Hours
}

func (c *ThermostatHeatingTimedOffSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ThermostatHeating),
        0x11,
        Minutes,
        Hours,
        0x25,
    }
}
package commands
type ThermostatModeGet struct {
    node byte
}

func (c *ThermostatModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeGet) Set() error {
}

func (c *ThermostatModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatMode),
        0x02,
        0x25,
    }
}
type ThermostatModeReport struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatModeReport(data []byte) *ThermostatModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatModeReport{
        Level: data[0],
        data: data,
    }
}

type ThermostatModeSet struct {
    node byte
    Level byte
}

func (c *ThermostatModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeSet) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatMode),
        0x01,
        Level,
        0x25,
    }
}
type ThermostatModeSupportedGet struct {
    node byte
}

func (c *ThermostatModeSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeSupportedGet) Set() error {
}

func (c *ThermostatModeSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatMode),
        0x04,
        0x25,
    }
}
type ThermostatModeSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatModeSupportedReport(data []byte) *ThermostatModeSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatModeSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatModeGetV2 struct {
    node byte
}

func (c *ThermostatModeGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeGetV2) Set() error {
}

func (c *ThermostatModeGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatModeV2),
        0x02,
        0x25,
    }
}
type ThermostatModeReportV2 struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatModeReportV2(data []byte) *ThermostatModeReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatModeReportV2{
        Level: data[0],
        data: data,
    }
}

type ThermostatModeSetV2 struct {
    node byte
    Level byte
}

func (c *ThermostatModeSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeSetV2) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatModeSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatModeV2),
        0x01,
        Level,
        0x25,
    }
}
type ThermostatModeSupportedGetV2 struct {
    node byte
}

func (c *ThermostatModeSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeSupportedGetV2) Set() error {
}

func (c *ThermostatModeSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatModeV2),
        0x04,
        0x25,
    }
}
type ThermostatModeSupportedReportV2 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatModeSupportedReportV2(data []byte) *ThermostatModeSupportedReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatModeSupportedReportV2{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatModeGetV3 struct {
    node byte
}

func (c *ThermostatModeGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeGetV3) Set() error {
}

func (c *ThermostatModeGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatModeV3),
        0x02,
        0x25,
    }
}
type ThermostatModeReportV3 struct {
    *report
    node byte
    Level byte
    ManufacturerData byte
    data []byte
}

func NewThermostatModeReportV3(data []byte) *ThermostatModeReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatModeReportV3{
        Level: data[0],
        ManufacturerData: data[1],
        data: data,
    }
}

type ThermostatModeSetV3 struct {
    node byte
    Level byte
    ManufacturerData byte
}

func (c *ThermostatModeSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeSetV3) Set(Level byte,ManufacturerData byte,) error {
    c.Level = Level
    c.ManufacturerData = ManufacturerData
}

func (c *ThermostatModeSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ThermostatModeV3),
        0x01,
        Level,
        ManufacturerData,
        0x25,
    }
}
type ThermostatModeSupportedGetV3 struct {
    node byte
}

func (c *ThermostatModeSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatModeSupportedGetV3) Set() error {
}

func (c *ThermostatModeSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatModeV3),
        0x04,
        0x25,
    }
}
type ThermostatModeSupportedReportV3 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatModeSupportedReportV3(data []byte) *ThermostatModeSupportedReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatModeSupportedReportV3{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatOperatingStateGet struct {
    node byte
}

func (c *ThermostatOperatingStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatOperatingStateGet) Set() error {
}

func (c *ThermostatOperatingStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatOperatingState),
        0x02,
        0x25,
    }
}
type ThermostatOperatingStateReport struct {
    *report
    node byte
    Level byte
    data []byte
}

func NewThermostatOperatingStateReport(data []byte) *ThermostatOperatingStateReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatOperatingStateReport{
        Level: data[0],
        data: data,
    }
}

package commands
type ThermostatOperatingStateGetV2 struct {
    node byte
}

func (c *ThermostatOperatingStateGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatOperatingStateGetV2) Set() error {
}

func (c *ThermostatOperatingStateGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatOperatingStateV2),
        0x02,
        0x25,
    }
}
type ThermostatOperatingStateReportV2 struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewThermostatOperatingStateReportV2(data []byte) *ThermostatOperatingStateReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatOperatingStateReportV2{
        Properties1: data[0],
        data: data,
    }
}

type ThermostatOperatingStateLoggingSupportedGetV2 struct {
    node byte
}

func (c *ThermostatOperatingStateLoggingSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatOperatingStateLoggingSupportedGetV2) Set() error {
}

func (c *ThermostatOperatingStateLoggingSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatOperatingStateV2),
        0x01,
        0x25,
    }
}
type ThermostatOperatingLoggingSupportedReportV2 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatOperatingLoggingSupportedReportV2(data []byte) *ThermostatOperatingLoggingSupportedReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatOperatingLoggingSupportedReportV2{
        BitMask: data[0],
        data: data,
    }
}

type ThermostatOperatingStateLoggingGetV2 struct {
    node byte
    BitMask byte
}

func (c *ThermostatOperatingStateLoggingGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatOperatingStateLoggingGetV2) Set(BitMask byte,) error {
    c.BitMask = BitMask
}

func (c *ThermostatOperatingStateLoggingGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatOperatingStateV2),
        0x05,
        BitMask,
        0x25,
    }
}
type ThermostatOperatingStateLoggingReportV2 struct {
    *report
    node byte
    ReportstoFollow byte
    data []byte
}

func NewThermostatOperatingStateLoggingReportV2(data []byte) *ThermostatOperatingStateLoggingReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatOperatingStateLoggingReportV2{
        ReportstoFollow: data[0],
        data: data,
    }
}

package commands
type ThermostatSetbackGet struct {
    node byte
}

func (c *ThermostatSetbackGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetbackGet) Set() error {
}

func (c *ThermostatSetbackGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatSetback),
        0x02,
        0x25,
    }
}
type ThermostatSetbackReport struct {
    *report
    node byte
    Properties1 byte
    SetbackState byte
    data []byte
}

func NewThermostatSetbackReport(data []byte) *ThermostatSetbackReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetbackReport{
        Properties1: data[0],
        SetbackState: data[1],
        data: data,
    }
}

type ThermostatSetbackSet struct {
    node byte
    Properties1 byte
    SetbackState byte
}

func (c *ThermostatSetbackSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetbackSet) Set(Properties1 byte,SetbackState byte,) error {
    c.Properties1 = Properties1
    c.SetbackState = SetbackState
}

func (c *ThermostatSetbackSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ThermostatSetback),
        0x01,
        Properties1,
        SetbackState,
        0x25,
    }
}
package commands
type ThermostatSetpointGet struct {
    node byte
    Level byte
}

func (c *ThermostatSetpointGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointGet) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatSetpointGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatSetpoint),
        0x02,
        Level,
        0x25,
    }
}
type ThermostatSetpointReport struct {
    *report
    node byte
    Level byte
    Level2 byte
    Value byte
    data []byte
}

func NewThermostatSetpointReport(data []byte) *ThermostatSetpointReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointReport{
        Level: data[0],
        Level2: data[1],
        Value: data[2],
        data: data,
    }
}

type ThermostatSetpointSet struct {
    node byte
    Level byte
    Level2 byte
    Value byte
}

func (c *ThermostatSetpointSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointSet) Set(Level byte,Level2 byte,Value byte,) error {
    c.Level = Level
    c.Level2 = Level2
    c.Value = Value
}

func (c *ThermostatSetpointSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ThermostatSetpoint),
        0x01,
        Level,
        Level2,
        Value,
        0x25,
    }
}
type ThermostatSetpointSupportedGet struct {
    node byte
}

func (c *ThermostatSetpointSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointSupportedGet) Set() error {
}

func (c *ThermostatSetpointSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatSetpoint),
        0x04,
        0x25,
    }
}
type ThermostatSetpointSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatSetpointSupportedReport(data []byte) *ThermostatSetpointSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatSetpointGetV2 struct {
    node byte
    Level byte
}

func (c *ThermostatSetpointGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointGetV2) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatSetpointGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatSetpointV2),
        0x02,
        Level,
        0x25,
    }
}
type ThermostatSetpointReportV2 struct {
    *report
    node byte
    Level byte
    Level2 byte
    Value byte
    data []byte
}

func NewThermostatSetpointReportV2(data []byte) *ThermostatSetpointReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointReportV2{
        Level: data[0],
        Level2: data[1],
        Value: data[2],
        data: data,
    }
}

type ThermostatSetpointSetV2 struct {
    node byte
    Level byte
    Level2 byte
    Value byte
}

func (c *ThermostatSetpointSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointSetV2) Set(Level byte,Level2 byte,Value byte,) error {
    c.Level = Level
    c.Level2 = Level2
    c.Value = Value
}

func (c *ThermostatSetpointSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ThermostatSetpointV2),
        0x01,
        Level,
        Level2,
        Value,
        0x25,
    }
}
type ThermostatSetpointSupportedGetV2 struct {
    node byte
}

func (c *ThermostatSetpointSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointSupportedGetV2) Set() error {
}

func (c *ThermostatSetpointSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatSetpointV2),
        0x04,
        0x25,
    }
}
type ThermostatSetpointSupportedReportV2 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatSetpointSupportedReportV2(data []byte) *ThermostatSetpointSupportedReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointSupportedReportV2{
        BitMask: data[0],
        data: data,
    }
}

package commands
type ThermostatSetpointGetV3 struct {
    node byte
    Level byte
}

func (c *ThermostatSetpointGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointGetV3) Set(Level byte,) error {
    c.Level = Level
}

func (c *ThermostatSetpointGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatSetpointV3),
        0x02,
        Level,
        0x25,
    }
}
type ThermostatSetpointReportV3 struct {
    *report
    node byte
    Level byte
    Level2 byte
    Value byte
    data []byte
}

func NewThermostatSetpointReportV3(data []byte) *ThermostatSetpointReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointReportV3{
        Level: data[0],
        Level2: data[1],
        Value: data[2],
        data: data,
    }
}

type ThermostatSetpointSetV3 struct {
    node byte
    Level byte
    Level2 byte
    Value byte
}

func (c *ThermostatSetpointSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointSetV3) Set(Level byte,Level2 byte,Value byte,) error {
    c.Level = Level
    c.Level2 = Level2
    c.Value = Value
}

func (c *ThermostatSetpointSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ThermostatSetpointV3),
        0x01,
        Level,
        Level2,
        Value,
        0x25,
    }
}
type ThermostatSetpointSupportedGetV3 struct {
    node byte
}

func (c *ThermostatSetpointSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointSupportedGetV3) Set() error {
}

func (c *ThermostatSetpointSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ThermostatSetpointV3),
        0x04,
        0x25,
    }
}
type ThermostatSetpointSupportedReportV3 struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewThermostatSetpointSupportedReportV3(data []byte) *ThermostatSetpointSupportedReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointSupportedReportV3{
        BitMask: data[0],
        data: data,
    }
}

type ThermostatSetpointCapabilitiesGetV3 struct {
    node byte
    Properties1 byte
}

func (c *ThermostatSetpointCapabilitiesGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ThermostatSetpointCapabilitiesGetV3) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *ThermostatSetpointCapabilitiesGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ThermostatSetpointV3),
        0x09,
        Properties1,
        0x25,
    }
}
type ThermostatSetpointCapabilitiesReportV3 struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    MinValue byte
    Properties3 byte
    MaxValue byte
    data []byte
}

func NewThermostatSetpointCapabilitiesReportV3(data []byte) *ThermostatSetpointCapabilitiesReportV3 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ThermostatSetpointCapabilitiesReportV3{
        Properties1: data[0],
        Properties2: data[1],
        MinValue: data[2],
        Properties3: data[3],
        MaxValue: data[4],
        data: data,
    }
}

package commands
type TimeParametersGet struct {
    node byte
}

func (c *TimeParametersGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TimeParametersGet) Set() error {
}

func (c *TimeParametersGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(TimeParameters),
        0x02,
        0x25,
    }
}
type TimeParametersReport struct {
    *report
    node byte
    Year byte
    Month byte
    Day byte
    HourUTC byte
    MinuteUTC byte
    SecondUTC byte
    data []byte
}

func NewTimeParametersReport(data []byte) *TimeParametersReport {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &TimeParametersReport{
        Year: data[0],
        Month: data[1],
        Day: data[2],
        HourUTC: data[3],
        MinuteUTC: data[4],
        SecondUTC: data[5],
        data: data,
    }
}

type TimeParametersSet struct {
    node byte
    Year byte
    Month byte
    Day byte
    HourUTC byte
    MinuteUTC byte
    SecondUTC byte
}

func (c *TimeParametersSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TimeParametersSet) Set(Year byte,Month byte,Day byte,HourUTC byte,MinuteUTC byte,SecondUTC byte,) error {
    c.Year = Year
    c.Month = Month
    c.Day = Day
    c.HourUTC = HourUTC
    c.MinuteUTC = MinuteUTC
    c.SecondUTC = SecondUTC
}

func (c *TimeParametersSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(TimeParameters),
        0x01,
        Year,
        Month,
        Day,
        HourUTC,
        MinuteUTC,
        SecondUTC,
        0x25,
    }
}
package commands
type DateGet struct {
    node byte
}

func (c *DateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DateGet) Set() error {
}

func (c *DateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Time),
        0x03,
        0x25,
    }
}
type DateReport struct {
    *report
    node byte
    Year byte
    Month byte
    Day byte
    data []byte
}

func NewDateReport(data []byte) *DateReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &DateReport{
        Year: data[0],
        Month: data[1],
        Day: data[2],
        data: data,
    }
}

type TimeGet struct {
    node byte
}

func (c *TimeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *TimeGet) Set() error {
}

func (c *TimeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Time),
        0x01,
        0x25,
    }
}
type TimeReport struct {
    *report
    node byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewTimeReport(data []byte) *TimeReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &TimeReport{
        HourLocalTime: data[0],
        MinuteLocalTime: data[1],
        SecondLocalTime: data[2],
        data: data,
    }
}

package commands
type DateGetV2 struct {
    node byte
}

func (c *DateGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *DateGetV2) Set() error {
}

func (c *DateGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(TimeV2),
        0x03,
        0x25,
    }
}
type DateReportV2 struct {
    *report
    node byte
    Year byte
    Month byte
    Day byte
    data []byte
}

func NewDateReportV2(data []byte) *DateReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &DateReportV2{
        Year: data[0],
        Month: data[1],
        Day: data[2],
        data: data,
    }
}

type TimeGetV2 struct {
    node byte
}

func (c *TimeGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *TimeGetV2) Set() error {
}

func (c *TimeGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(TimeV2),
        0x01,
        0x25,
    }
}
type TimeOffsetGetV2 struct {
    node byte
}

func (c *TimeOffsetGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *TimeOffsetGetV2) Set() error {
}

func (c *TimeOffsetGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(TimeV2),
        0x06,
        0x25,
    }
}
type TimeOffsetReportV2 struct {
    *report
    node byte
    Level byte
    MinuteTZO byte
    Level2 byte
    MonthStartDST byte
    DayStartDST byte
    HourStartDST byte
    MonthEndDST byte
    DayEndDST byte
    HourEndDST byte
    data []byte
}

func NewTimeOffsetReportV2(data []byte) *TimeOffsetReportV2 {
    if len(data) < 9 {
        for i := len(data); i < 9; i++ {
            data = append(data, 0x00)
        }
    }

    return &TimeOffsetReportV2{
        Level: data[0],
        MinuteTZO: data[1],
        Level2: data[2],
        MonthStartDST: data[3],
        DayStartDST: data[4],
        HourStartDST: data[5],
        MonthEndDST: data[6],
        DayEndDST: data[7],
        HourEndDST: data[8],
        data: data,
    }
}

type TimeOffsetSetV2 struct {
    node byte
    Level byte
    MinuteTZO byte
    Level2 byte
    MonthStartDST byte
    DayStartDST byte
    HourStartDST byte
    MonthEndDST byte
    DayEndDST byte
    HourEndDST byte
}

func (c *TimeOffsetSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *TimeOffsetSetV2) Set(Level byte,MinuteTZO byte,Level2 byte,MonthStartDST byte,DayStartDST byte,HourStartDST byte,MonthEndDST byte,DayEndDST byte,HourEndDST byte,) error {
    c.Level = Level
    c.MinuteTZO = MinuteTZO
    c.Level2 = Level2
    c.MonthStartDST = MonthStartDST
    c.DayStartDST = DayStartDST
    c.HourStartDST = HourStartDST
    c.MonthEndDST = MonthEndDST
    c.DayEndDST = DayEndDST
    c.HourEndDST = HourEndDST
}

func (c *TimeOffsetSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(9),
        byte(TimeV2),
        0x05,
        Level,
        MinuteTZO,
        Level2,
        MonthStartDST,
        DayStartDST,
        HourStartDST,
        MonthEndDST,
        DayEndDST,
        HourEndDST,
        0x25,
    }
}
type TimeReportV2 struct {
    *report
    node byte
    HourLocalTime byte
    MinuteLocalTime byte
    SecondLocalTime byte
    data []byte
}

func NewTimeReportV2(data []byte) *TimeReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &TimeReportV2{
        HourLocalTime: data[0],
        MinuteLocalTime: data[1],
        SecondLocalTime: data[2],
        data: data,
    }
}

package commands
type CommandFirstSegmentV2 struct {
    node byte
    Properties1 byte
    datagram_size_2 byte
    Properties2 byte
    HeaderExtensionLength byte
    HeaderExtension byte
    Payload byte
    FrameCheckSequence byte
}

func (c *CommandFirstSegmentV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandFirstSegmentV2) Set(Properties1 byte,datagram_size_2 byte,Properties2 byte,HeaderExtensionLength byte,HeaderExtension byte,Payload byte,FrameCheckSequence byte,) error {
    c.Properties1 = Properties1
    c.datagram_size_2 = datagram_size_2
    c.Properties2 = Properties2
    c.HeaderExtensionLength = HeaderExtensionLength
    c.HeaderExtension = HeaderExtension
    c.Payload = Payload
    c.FrameCheckSequence = FrameCheckSequence
}

func (c *CommandFirstSegmentV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(7),
        byte(TransportServiceV2),
        0xC0,
        Properties1,
        datagram_size_2,
        Properties2,
        HeaderExtensionLength,
        HeaderExtension,
        Payload,
        FrameCheckSequence,
        0x25,
    }
}
type CommandSegmentCompleteV2 struct {
    node byte
    Properties1 byte
    Properties2 byte
}

func (c *CommandSegmentCompleteV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandSegmentCompleteV2) Set(Properties1 byte,Properties2 byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
}

func (c *CommandSegmentCompleteV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(TransportServiceV2),
        0xE8,
        Properties1,
        Properties2,
        0x25,
    }
}
type CommandSegmentRequestV2 struct {
    node byte
    Properties1 byte
    Properties2 byte
    datagram_offset_2 byte
}

func (c *CommandSegmentRequestV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandSegmentRequestV2) Set(Properties1 byte,Properties2 byte,datagram_offset_2 byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.datagram_offset_2 = datagram_offset_2
}

func (c *CommandSegmentRequestV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(TransportServiceV2),
        0xC8,
        Properties1,
        Properties2,
        datagram_offset_2,
        0x25,
    }
}
type CommandSegmentWaitV2 struct {
    node byte
    Properties1 byte
    pending_fragments byte
}

func (c *CommandSegmentWaitV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandSegmentWaitV2) Set(Properties1 byte,pending_fragments byte,) error {
    c.Properties1 = Properties1
    c.pending_fragments = pending_fragments
}

func (c *CommandSegmentWaitV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(TransportServiceV2),
        0xF0,
        Properties1,
        pending_fragments,
        0x25,
    }
}
type CommandSubsequentSegmentV2 struct {
    node byte
    Properties1 byte
    datagram_size_2 byte
    Properties2 byte
    datagram_offset_2 byte
    HeaderExtensionLength byte
    HeaderExtension byte
    Payload byte
    FrameCheckSequence byte
}

func (c *CommandSubsequentSegmentV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandSubsequentSegmentV2) Set(Properties1 byte,datagram_size_2 byte,Properties2 byte,datagram_offset_2 byte,HeaderExtensionLength byte,HeaderExtension byte,Payload byte,FrameCheckSequence byte,) error {
    c.Properties1 = Properties1
    c.datagram_size_2 = datagram_size_2
    c.Properties2 = Properties2
    c.datagram_offset_2 = datagram_offset_2
    c.HeaderExtensionLength = HeaderExtensionLength
    c.HeaderExtension = HeaderExtension
    c.Payload = Payload
    c.FrameCheckSequence = FrameCheckSequence
}

func (c *CommandSubsequentSegmentV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(TransportServiceV2),
        0xE0,
        Properties1,
        datagram_size_2,
        Properties2,
        datagram_offset_2,
        HeaderExtensionLength,
        HeaderExtension,
        Payload,
        FrameCheckSequence,
        0x25,
    }
}
package commands
type CommandFirstFragment struct {
    node byte
    Properties1 byte
    datagram_size_2 byte
    Properties2 byte
    Payload byte
    Checksum byte
}

func (c *CommandFirstFragment) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandFirstFragment) Set(Properties1 byte,datagram_size_2 byte,Properties2 byte,Payload byte,Checksum byte,) error {
    c.Properties1 = Properties1
    c.datagram_size_2 = datagram_size_2
    c.Properties2 = Properties2
    c.Payload = Payload
    c.Checksum = Checksum
}

func (c *CommandFirstFragment) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(TransportService),
        0xC0,
        Properties1,
        datagram_size_2,
        Properties2,
        Payload,
        Checksum,
        0x25,
    }
}
type CommandSubsequentFragment struct {
    node byte
    Properties1 byte
    datagram_size_2 byte
    Properties2 byte
    datagram_offset_2 byte
    Payload byte
    Checksum byte
}

func (c *CommandSubsequentFragment) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandSubsequentFragment) Set(Properties1 byte,datagram_size_2 byte,Properties2 byte,datagram_offset_2 byte,Payload byte,Checksum byte,) error {
    c.Properties1 = Properties1
    c.datagram_size_2 = datagram_size_2
    c.Properties2 = Properties2
    c.datagram_offset_2 = datagram_offset_2
    c.Payload = Payload
    c.Checksum = Checksum
}

func (c *CommandSubsequentFragment) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(TransportService),
        0xE0,
        Properties1,
        datagram_size_2,
        Properties2,
        datagram_offset_2,
        Payload,
        Checksum,
        0x25,
    }
}
package commands
type UserCodeGet struct {
    node byte
    UserIdentifier byte
}

func (c *UserCodeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *UserCodeGet) Set(UserIdentifier byte,) error {
    c.UserIdentifier = UserIdentifier
}

func (c *UserCodeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(UserCode),
        0x02,
        UserIdentifier,
        0x25,
    }
}
type UserCodeReport struct {
    *report
    node byte
    UserIdentifier byte
    UserIDStatus byte
    USER_CODE byte
    data []byte
}

func NewUserCodeReport(data []byte) *UserCodeReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &UserCodeReport{
        UserIdentifier: data[0],
        UserIDStatus: data[1],
        USER_CODE: data[2],
        data: data,
    }
}

type UserCodeSet struct {
    node byte
    UserIdentifier byte
    UserIDStatus byte
    USER_CODE byte
}

func (c *UserCodeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *UserCodeSet) Set(UserIdentifier byte,UserIDStatus byte,USER_CODE byte,) error {
    c.UserIdentifier = UserIdentifier
    c.UserIDStatus = UserIDStatus
    c.USER_CODE = USER_CODE
}

func (c *UserCodeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(UserCode),
        0x01,
        UserIdentifier,
        UserIDStatus,
        USER_CODE,
        0x25,
    }
}
type UsersNumberGet struct {
    node byte
}

func (c *UsersNumberGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *UsersNumberGet) Set() error {
}

func (c *UsersNumberGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(UserCode),
        0x04,
        0x25,
    }
}
type UsersNumberReport struct {
    *report
    node byte
    SupportedUsers byte
    data []byte
}

func NewUsersNumberReport(data []byte) *UsersNumberReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &UsersNumberReport{
        SupportedUsers: data[0],
        data: data,
    }
}

package commands
type VersionCommandClassGet struct {
    node byte
    RequestedCommandClass byte
}

func (c *VersionCommandClassGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *VersionCommandClassGet) Set(RequestedCommandClass byte,) error {
    c.RequestedCommandClass = RequestedCommandClass
}

func (c *VersionCommandClassGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Version),
        0x13,
        RequestedCommandClass,
        0x25,
    }
}
type VersionCommandClassReport struct {
    *report
    node byte
    RequestedCommandClass byte
    CommandClassVersion byte
    data []byte
}

func NewVersionCommandClassReport(data []byte) *VersionCommandClassReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &VersionCommandClassReport{
        RequestedCommandClass: data[0],
        CommandClassVersion: data[1],
        data: data,
    }
}

type VersionGet struct {
    node byte
}

func (c *VersionGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *VersionGet) Set() error {
}

func (c *VersionGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Version),
        0x11,
        0x25,
    }
}
type VersionReport struct {
    *report
    node byte
    Z-WaveLibraryType byte
    Z-WaveProtocolVersion byte
    Z-WaveProtocolSubVersion byte
    ApplicationVersion byte
    ApplicationSubVersion byte
    data []byte
}

func NewVersionReport(data []byte) *VersionReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &VersionReport{
        Z-WaveLibraryType: data[0],
        Z-WaveProtocolVersion: data[1],
        Z-WaveProtocolSubVersion: data[2],
        ApplicationVersion: data[3],
        ApplicationSubVersion: data[4],
        data: data,
    }
}

package commands
type VersionCommandClassGetV2 struct {
    node byte
    RequestedCommandClass byte
}

func (c *VersionCommandClassGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *VersionCommandClassGetV2) Set(RequestedCommandClass byte,) error {
    c.RequestedCommandClass = RequestedCommandClass
}

func (c *VersionCommandClassGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(VersionV2),
        0x13,
        RequestedCommandClass,
        0x25,
    }
}
type VersionCommandClassReportV2 struct {
    *report
    node byte
    RequestedCommandClass byte
    CommandClassVersion byte
    data []byte
}

func NewVersionCommandClassReportV2(data []byte) *VersionCommandClassReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &VersionCommandClassReportV2{
        RequestedCommandClass: data[0],
        CommandClassVersion: data[1],
        data: data,
    }
}

type VersionGetV2 struct {
    node byte
}

func (c *VersionGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *VersionGetV2) Set() error {
}

func (c *VersionGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(VersionV2),
        0x11,
        0x25,
    }
}
type VersionReportV2 struct {
    *report
    node byte
    Z-WaveLibraryType byte
    Z-WaveProtocolVersion byte
    Z-WaveProtocolSubVersion byte
    Firmware0Version byte
    Firmware0SubVersion byte
    HardwareVersion byte
    Numberoffirmwaretargets byte
    data []byte
}

func NewVersionReportV2(data []byte) *VersionReportV2 {
    if len(data) < 7 {
        for i := len(data); i < 7; i++ {
            data = append(data, 0x00)
        }
    }

    return &VersionReportV2{
        Z-WaveLibraryType: data[0],
        Z-WaveProtocolVersion: data[1],
        Z-WaveProtocolSubVersion: data[2],
        Firmware0Version: data[3],
        Firmware0SubVersion: data[4],
        HardwareVersion: data[5],
        Numberoffirmwaretargets: data[6],
        data: data,
    }
}

package commands
type WakeUpIntervalGet struct {
    node byte
}

func (c *WakeUpIntervalGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpIntervalGet) Set() error {
}

func (c *WakeUpIntervalGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUp),
        0x05,
        0x25,
    }
}
type WakeUpIntervalReport struct {
    *report
    node byte
    Seconds byte
    NodeID byte
    data []byte
}

func NewWakeUpIntervalReport(data []byte) *WakeUpIntervalReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &WakeUpIntervalReport{
        Seconds: data[0],
        NodeID: data[1],
        data: data,
    }
}

type WakeUpIntervalSet struct {
    node byte
    Seconds byte
    NodeID byte
}

func (c *WakeUpIntervalSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpIntervalSet) Set(Seconds byte,NodeID byte,) error {
    c.Seconds = Seconds
    c.NodeID = NodeID
}

func (c *WakeUpIntervalSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(WakeUp),
        0x04,
        Seconds,
        NodeID,
        0x25,
    }
}
type WakeUpNoMoreInformation struct {
    node byte
}

func (c *WakeUpNoMoreInformation) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpNoMoreInformation) Set() error {
}

func (c *WakeUpNoMoreInformation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUp),
        0x08,
        0x25,
    }
}
type WakeUpNotification struct {
    node byte
}

func (c *WakeUpNotification) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpNotification) Set() error {
}

func (c *WakeUpNotification) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUp),
        0x07,
        0x25,
    }
}
package commands
type WakeUpIntervalCapabilitiesGetV2 struct {
    node byte
}

func (c *WakeUpIntervalCapabilitiesGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpIntervalCapabilitiesGetV2) Set() error {
}

func (c *WakeUpIntervalCapabilitiesGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUpV2),
        0x09,
        0x25,
    }
}
type WakeUpIntervalCapabilitiesReportV2 struct {
    *report
    node byte
    MinimumWakeUpIntervalSeconds byte
    MaximumWakeUpIntervalSeconds byte
    DefaultWakeUpIntervalSeconds byte
    WakeUpIntervalStepSeconds byte
    data []byte
}

func NewWakeUpIntervalCapabilitiesReportV2(data []byte) *WakeUpIntervalCapabilitiesReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &WakeUpIntervalCapabilitiesReportV2{
        MinimumWakeUpIntervalSeconds: data[0],
        MaximumWakeUpIntervalSeconds: data[1],
        DefaultWakeUpIntervalSeconds: data[2],
        WakeUpIntervalStepSeconds: data[3],
        data: data,
    }
}

type WakeUpIntervalGetV2 struct {
    node byte
}

func (c *WakeUpIntervalGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpIntervalGetV2) Set() error {
}

func (c *WakeUpIntervalGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUpV2),
        0x05,
        0x25,
    }
}
type WakeUpIntervalReportV2 struct {
    *report
    node byte
    Seconds byte
    NodeID byte
    data []byte
}

func NewWakeUpIntervalReportV2(data []byte) *WakeUpIntervalReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &WakeUpIntervalReportV2{
        Seconds: data[0],
        NodeID: data[1],
        data: data,
    }
}

type WakeUpIntervalSetV2 struct {
    node byte
    Seconds byte
    NodeID byte
}

func (c *WakeUpIntervalSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpIntervalSetV2) Set(Seconds byte,NodeID byte,) error {
    c.Seconds = Seconds
    c.NodeID = NodeID
}

func (c *WakeUpIntervalSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(WakeUpV2),
        0x04,
        Seconds,
        NodeID,
        0x25,
    }
}
type WakeUpNoMoreInformationV2 struct {
    node byte
}

func (c *WakeUpNoMoreInformationV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpNoMoreInformationV2) Set() error {
}

func (c *WakeUpNoMoreInformationV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUpV2),
        0x08,
        0x25,
    }
}
type WakeUpNotificationV2 struct {
    node byte
}

func (c *WakeUpNotificationV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *WakeUpNotificationV2) Set() error {
}

func (c *WakeUpNotificationV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WakeUpV2),
        0x07,
        0x25,
    }
}
package commands
type BindAccept struct {
    node byte
}

func (c *BindAccept) SetNode(node int) {
    c.node = byte(node)
}

func (c *BindAccept) Set() error {
}

func (c *BindAccept) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZensorNet),
        0x02,
        0x25,
    }
}
type BindComplete struct {
    node byte
}

func (c *BindComplete) SetNode(node int) {
    c.node = byte(node)
}

func (c *BindComplete) Set() error {
}

func (c *BindComplete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZensorNet),
        0x03,
        0x25,
    }
}
type BindRequest struct {
    node byte
}

func (c *BindRequest) SetNode(node int) {
    c.node = byte(node)
}

func (c *BindRequest) Set() error {
}

func (c *BindRequest) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZensorNet),
        0x01,
        0x25,
    }
}
package commands
type LowpanFirstFragment struct {
    node byte
    Properties1 byte
    DatagramSize2 byte
    DatagramTag byte
    Payload byte
}

func (c *LowpanFirstFragment) SetNode(node int) {
    c.node = byte(node)
}

func (c *LowpanFirstFragment) Set(Properties1 byte,DatagramSize2 byte,DatagramTag byte,Payload byte,) error {
    c.Properties1 = Properties1
    c.DatagramSize2 = DatagramSize2
    c.DatagramTag = DatagramTag
    c.Payload = Payload
}

func (c *LowpanFirstFragment) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(Zip6lowpan),
        0xC0,
        Properties1,
        DatagramSize2,
        DatagramTag,
        Payload,
        0x25,
    }
}
type LowpanSubsequentFragment struct {
    node byte
    Properties1 byte
    DatagramSize2 byte
    DatagramTag byte
    DatagramOffset byte
    Payload byte
}

func (c *LowpanSubsequentFragment) SetNode(node int) {
    c.node = byte(node)
}

func (c *LowpanSubsequentFragment) Set(Properties1 byte,DatagramSize2 byte,DatagramTag byte,DatagramOffset byte,Payload byte,) error {
    c.Properties1 = Properties1
    c.DatagramSize2 = DatagramSize2
    c.DatagramTag = DatagramTag
    c.DatagramOffset = DatagramOffset
    c.Payload = Payload
}

func (c *LowpanSubsequentFragment) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(Zip6lowpan),
        0xE0,
        Properties1,
        DatagramSize2,
        DatagramTag,
        DatagramOffset,
        Payload,
        0x25,
    }
}
package commands
type CommandZipPacket struct {
    node byte
    Properties1 byte
    Properties2 byte
    SeqNo byte
    Properties3 byte
    Properties4 byte
    Headerextension byte
    Z-Wavecommand byte
}

func (c *CommandZipPacket) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandZipPacket) Set(Properties1 byte,Properties2 byte,SeqNo byte,Properties3 byte,Properties4 byte,Headerextension byte,Z-Wavecommand byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.SeqNo = SeqNo
    c.Properties3 = Properties3
    c.Properties4 = Properties4
    c.Headerextension = Headerextension
    c.Z-Wavecommand = Z-Wavecommand
}

func (c *CommandZipPacket) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(7),
        byte(Zip),
        0x02,
        Properties1,
        Properties2,
        SeqNo,
        Properties3,
        Properties4,
        Headerextension,
        Z-Wavecommand,
        0x25,
    }
}
package commands
type CommandZipPacketV2 struct {
    node byte
    Properties1 byte
    Properties2 byte
    SeqNo byte
    Properties3 byte
    Properties4 byte
    HeaderLength byte
    Headerextension byte
    Z-Wavecommand byte
}

func (c *CommandZipPacketV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandZipPacketV2) Set(Properties1 byte,Properties2 byte,SeqNo byte,Properties3 byte,Properties4 byte,HeaderLength byte,Headerextension byte,Z-Wavecommand byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.SeqNo = SeqNo
    c.Properties3 = Properties3
    c.Properties4 = Properties4
    c.HeaderLength = HeaderLength
    c.Headerextension = Headerextension
    c.Z-Wavecommand = Z-Wavecommand
}

func (c *CommandZipPacketV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(ZipV2),
        0x02,
        Properties1,
        Properties2,
        SeqNo,
        Properties3,
        Properties4,
        HeaderLength,
        Headerextension,
        Z-Wavecommand,
        0x25,
    }
}
package commands
type CommandZipPacketV3 struct {
    node byte
    Properties1 byte
    Properties2 byte
    SeqNo byte
    Properties3 byte
    Properties4 byte
    HeaderLength byte
    Headerextension byte
    Z-Wavecommand byte
}

func (c *CommandZipPacketV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandZipPacketV3) Set(Properties1 byte,Properties2 byte,SeqNo byte,Properties3 byte,Properties4 byte,HeaderLength byte,Headerextension byte,Z-Wavecommand byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.SeqNo = SeqNo
    c.Properties3 = Properties3
    c.Properties4 = Properties4
    c.HeaderLength = HeaderLength
    c.Headerextension = Headerextension
    c.Z-Wavecommand = Z-Wavecommand
}

func (c *CommandZipPacketV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(8),
        byte(ZipV3),
        0x02,
        Properties1,
        Properties2,
        SeqNo,
        Properties3,
        Properties4,
        HeaderLength,
        Headerextension,
        Z-Wavecommand,
        0x25,
    }
}
package commands
type AcceptLost struct {
    node byte
}

func (c *AcceptLost) SetNode(node int) {
    c.node = byte(node)
}

func (c *AcceptLost) Set() error {
}

func (c *AcceptLost) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x17,
        0x25,
    }
}
type AssignId struct {
    node byte
}

func (c *AssignId) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssignId) Set() error {
}

func (c *AssignId) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x03,
        0x25,
    }
}
type AssignReturnRoute struct {
    node byte
}

func (c *AssignReturnRoute) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssignReturnRoute) Set() error {
}

func (c *AssignReturnRoute) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x0C,
        0x25,
    }
}
type CmdAssignSucReturnRoute struct {
    node byte
}

func (c *CmdAssignSucReturnRoute) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdAssignSucReturnRoute) Set() error {
}

func (c *CmdAssignSucReturnRoute) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x14,
        0x25,
    }
}
type CmdAutomaticControllerUpdateStart struct {
    node byte
}

func (c *CmdAutomaticControllerUpdateStart) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdAutomaticControllerUpdateStart) Set() error {
}

func (c *CmdAutomaticControllerUpdateStart) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x10,
        0x25,
    }
}
type CmdNodesExist struct {
    node byte
}

func (c *CmdNodesExist) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdNodesExist) Set() error {
}

func (c *CmdNodesExist) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x1F,
        0x25,
    }
}
type CmdNodesExistReply struct {
    node byte
}

func (c *CmdNodesExistReply) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdNodesExistReply) Set() error {
}

func (c *CmdNodesExistReply) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x20,
        0x25,
    }
}
type CmdSetNwiMode struct {
    node byte
}

func (c *CmdSetNwiMode) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdSetNwiMode) Set() error {
}

func (c *CmdSetNwiMode) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x22,
        0x25,
    }
}
type CommandComplete struct {
    node byte
}

func (c *CommandComplete) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandComplete) Set() error {
}

func (c *CommandComplete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x07,
        0x25,
    }
}
type FindNodesInRange struct {
    node byte
}

func (c *FindNodesInRange) SetNode(node int) {
    c.node = byte(node)
}

func (c *FindNodesInRange) Set() error {
}

func (c *FindNodesInRange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x04,
        0x25,
    }
}
type GetNodesInRange struct {
    node byte
}

func (c *GetNodesInRange) SetNode(node int) {
    c.node = byte(node)
}

func (c *GetNodesInRange) Set() error {
}

func (c *GetNodesInRange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x05,
        0x25,
    }
}
type Lost struct {
    node byte
}

func (c *Lost) SetNode(node int) {
    c.node = byte(node)
}

func (c *Lost) Set() error {
}

func (c *Lost) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x16,
        0x25,
    }
}
type NewNodeRegistered struct {
    node byte
}

func (c *NewNodeRegistered) SetNode(node int) {
    c.node = byte(node)
}

func (c *NewNodeRegistered) Set() error {
}

func (c *NewNodeRegistered) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x0D,
        0x25,
    }
}
type NewRangeRegistered struct {
    node byte
}

func (c *NewRangeRegistered) SetNode(node int) {
    c.node = byte(node)
}

func (c *NewRangeRegistered) Set() error {
}

func (c *NewRangeRegistered) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x0E,
        0x25,
    }
}
type NodeInfo struct {
    node byte
    Capability byte
    Security byte
    Properties1 byte
    BasicDeviceClass byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    CommandClasses byte
}

func (c *NodeInfo) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeInfo) Set(Capability byte,Security byte,Properties1 byte,BasicDeviceClass byte,GenericDeviceClass byte,SpecificDeviceClass byte,CommandClasses byte,) error {
    c.Capability = Capability
    c.Security = Security
    c.Properties1 = Properties1
    c.BasicDeviceClass = BasicDeviceClass
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
    c.CommandClasses = CommandClasses
}

func (c *NodeInfo) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(7),
        byte(Class),
        0x01,
        Capability,
        Security,
        Properties1,
        BasicDeviceClass,
        GenericDeviceClass,
        SpecificDeviceClass,
        CommandClasses,
        0x25,
    }
}
type NodeRangeInfo struct {
    node byte
}

func (c *NodeRangeInfo) SetNode(node int) {
    c.node = byte(node)
}

func (c *NodeRangeInfo) Set() error {
}

func (c *NodeRangeInfo) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x06,
        0x25,
    }
}
type ZwaveCmdNop struct {
    node byte
}

func (c *ZwaveCmdNop) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZwaveCmdNop) Set() error {
}

func (c *ZwaveCmdNop) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x00,
        0x25,
    }
}
type CmdNopPower struct {
    node byte
}

func (c *CmdNopPower) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdNopPower) Set() error {
}

func (c *CmdNopPower) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x18,
        0x25,
    }
}
type RequestNodeInfo struct {
    node byte
}

func (c *RequestNodeInfo) SetNode(node int) {
    c.node = byte(node)
}

func (c *RequestNodeInfo) Set() error {
}

func (c *RequestNodeInfo) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x02,
        0x25,
    }
}
type ZwaveCmdReserveNodeIds struct {
    node byte
}

func (c *ZwaveCmdReserveNodeIds) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZwaveCmdReserveNodeIds) Set() error {
}

func (c *ZwaveCmdReserveNodeIds) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x19,
        0x25,
    }
}
type CmdReservedIds struct {
    node byte
}

func (c *CmdReservedIds) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdReservedIds) Set() error {
}

func (c *CmdReservedIds) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x1A,
        0x25,
    }
}
type CmdSetSuc struct {
    node byte
}

func (c *CmdSetSuc) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdSetSuc) Set() error {
}

func (c *CmdSetSuc) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x12,
        0x25,
    }
}
type CmdSetSucAck struct {
    node byte
}

func (c *CmdSetSucAck) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdSetSucAck) Set() error {
}

func (c *CmdSetSucAck) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x13,
        0x25,
    }
}
type CmdStaticRouteRequest struct {
    node byte
}

func (c *CmdStaticRouteRequest) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdStaticRouteRequest) Set() error {
}

func (c *CmdStaticRouteRequest) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x15,
        0x25,
    }
}
type CmdSucNodeId struct {
    node byte
}

func (c *CmdSucNodeId) SetNode(node int) {
    c.node = byte(node)
}

func (c *CmdSucNodeId) Set() error {
}

func (c *CmdSucNodeId) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x11,
        0x25,
    }
}
type TransferEnd struct {
    node byte
}

func (c *TransferEnd) SetNode(node int) {
    c.node = byte(node)
}

func (c *TransferEnd) Set() error {
}

func (c *TransferEnd) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x0B,
        0x25,
    }
}
type TransferNewPrimaryComplete struct {
    node byte
}

func (c *TransferNewPrimaryComplete) SetNode(node int) {
    c.node = byte(node)
}

func (c *TransferNewPrimaryComplete) Set() error {
}

func (c *TransferNewPrimaryComplete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x0F,
        0x25,
    }
}
type TransferNodeInfo struct {
    node byte
}

func (c *TransferNodeInfo) SetNode(node int) {
    c.node = byte(node)
}

func (c *TransferNodeInfo) Set() error {
}

func (c *TransferNodeInfo) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x09,
        0x25,
    }
}
type TransferPresentation struct {
    node byte
}

func (c *TransferPresentation) SetNode(node int) {
    c.node = byte(node)
}

func (c *TransferPresentation) Set() error {
}

func (c *TransferPresentation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x08,
        0x25,
    }
}
type TransferRangeInfo struct {
    node byte
}

func (c *TransferRangeInfo) SetNode(node int) {
    c.node = byte(node)
}

func (c *TransferRangeInfo) Set() error {
}

func (c *TransferRangeInfo) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x0A,
        0x25,
    }
}
type ExcludeRequest struct {
    node byte
}

func (c *ExcludeRequest) SetNode(node int) {
    c.node = byte(node)
}

func (c *ExcludeRequest) Set() error {
}

func (c *ExcludeRequest) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x23,
        0x25,
    }
}
type AssignReturnRoutePriority struct {
    node byte
}

func (c *AssignReturnRoutePriority) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssignReturnRoutePriority) Set() error {
}

func (c *AssignReturnRoutePriority) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x24,
        0x25,
    }
}
type AssignSucReturnRoutePriority struct {
    node byte
}

func (c *AssignSucReturnRoutePriority) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssignSucReturnRoutePriority) Set() error {
}

func (c *AssignSucReturnRoutePriority) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Class),
        0x25,
        0x25,
    }
}
package commands
type CommandCommandClassNotSupported struct {
    node byte
    Properties1 byte
    OffendingCommandClass byte
    OffendingCommand byte
}

func (c *CommandCommandClassNotSupported) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandCommandClassNotSupported) Set(Properties1 byte,OffendingCommandClass byte,OffendingCommand byte,) error {
    c.Properties1 = Properties1
    c.OffendingCommandClass = OffendingCommandClass
    c.OffendingCommand = OffendingCommand
}

func (c *CommandCommandClassNotSupported) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ApplicationCapability),
        0x01,
        Properties1,
        OffendingCommandClass,
        OffendingCommand,
        0x25,
    }
}
package commands
type SwitchColorSupportedGet struct {
    node byte
}

func (c *SwitchColorSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorSupportedGet) Set() error {
}

func (c *SwitchColorSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchColor),
        0x01,
        0x25,
    }
}
type SwitchColorSupportedReport struct {
    *report
    node byte
    ColorComponentmask byte
    data []byte
}

func NewSwitchColorSupportedReport(data []byte) *SwitchColorSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchColorSupportedReport{
        ColorComponentmask: data[0],
        data: data,
    }
}

type SwitchColorGet struct {
    node byte
    ColorComponentID byte
}

func (c *SwitchColorGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorGet) Set(ColorComponentID byte,) error {
    c.ColorComponentID = ColorComponentID
}

func (c *SwitchColorGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColor),
        0x03,
        ColorComponentID,
        0x25,
    }
}
type SwitchColorReport struct {
    *report
    node byte
    ColorComponentID byte
    Value byte
    data []byte
}

func NewSwitchColorReport(data []byte) *SwitchColorReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchColorReport{
        ColorComponentID: data[0],
        Value: data[1],
        data: data,
    }
}

type SwitchColorSet struct {
    node byte
    Properties1 byte
}

func (c *SwitchColorSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorSet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *SwitchColorSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColor),
        0x05,
        Properties1,
        0x25,
    }
}
type SwitchColorStartLevelChange struct {
    node byte
    Properties1 byte
    ColorComponentID byte
    StartLevel byte
}

func (c *SwitchColorStartLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorStartLevelChange) Set(Properties1 byte,ColorComponentID byte,StartLevel byte,) error {
    c.Properties1 = Properties1
    c.ColorComponentID = ColorComponentID
    c.StartLevel = StartLevel
}

func (c *SwitchColorStartLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(SwitchColor),
        0x06,
        Properties1,
        ColorComponentID,
        StartLevel,
        0x25,
    }
}
type SwitchColorStopLevelChange struct {
    node byte
    ColorComponentID byte
}

func (c *SwitchColorStopLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorStopLevelChange) Set(ColorComponentID byte,) error {
    c.ColorComponentID = ColorComponentID
}

func (c *SwitchColorStopLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColor),
        0x07,
        ColorComponentID,
        0x25,
    }
}
package commands
type SwitchColorSupportedGetV2 struct {
    node byte
}

func (c *SwitchColorSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorSupportedGetV2) Set() error {
}

func (c *SwitchColorSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchColorV2),
        0x01,
        0x25,
    }
}
type SwitchColorSupportedReportV2 struct {
    *report
    node byte
    ColorComponentmask byte
    data []byte
}

func NewSwitchColorSupportedReportV2(data []byte) *SwitchColorSupportedReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchColorSupportedReportV2{
        ColorComponentmask: data[0],
        data: data,
    }
}

type SwitchColorGetV2 struct {
    node byte
    ColorComponentID byte
}

func (c *SwitchColorGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorGetV2) Set(ColorComponentID byte,) error {
    c.ColorComponentID = ColorComponentID
}

func (c *SwitchColorGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColorV2),
        0x03,
        ColorComponentID,
        0x25,
    }
}
type SwitchColorReportV2 struct {
    *report
    node byte
    ColorComponentID byte
    Value byte
    data []byte
}

func NewSwitchColorReportV2(data []byte) *SwitchColorReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchColorReportV2{
        ColorComponentID: data[0],
        Value: data[1],
        data: data,
    }
}

type SwitchColorSetV2 struct {
    node byte
    Properties1 byte
    Duration byte
}

func (c *SwitchColorSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorSetV2) Set(Properties1 byte,Duration byte,) error {
    c.Properties1 = Properties1
    c.Duration = Duration
}

func (c *SwitchColorSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchColorV2),
        0x05,
        Properties1,
        Duration,
        0x25,
    }
}
type SwitchColorStartLevelChangeV2 struct {
    node byte
    Properties1 byte
    ColorComponentID byte
    StartLevel byte
}

func (c *SwitchColorStartLevelChangeV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorStartLevelChangeV2) Set(Properties1 byte,ColorComponentID byte,StartLevel byte,) error {
    c.Properties1 = Properties1
    c.ColorComponentID = ColorComponentID
    c.StartLevel = StartLevel
}

func (c *SwitchColorStartLevelChangeV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(SwitchColorV2),
        0x06,
        Properties1,
        ColorComponentID,
        StartLevel,
        0x25,
    }
}
type SwitchColorStopLevelChangeV2 struct {
    node byte
    ColorComponentID byte
}

func (c *SwitchColorStopLevelChangeV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorStopLevelChangeV2) Set(ColorComponentID byte,) error {
    c.ColorComponentID = ColorComponentID
}

func (c *SwitchColorStopLevelChangeV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColorV2),
        0x07,
        ColorComponentID,
        0x25,
    }
}
package commands
type SwitchColorSupportedGetV3 struct {
    node byte
}

func (c *SwitchColorSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorSupportedGetV3) Set() error {
}

func (c *SwitchColorSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(SwitchColorV3),
        0x01,
        0x25,
    }
}
type SwitchColorSupportedReportV3 struct {
    *report
    node byte
    ColorComponentmask byte
    data []byte
}

func NewSwitchColorSupportedReportV3(data []byte) *SwitchColorSupportedReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchColorSupportedReportV3{
        ColorComponentmask: data[0],
        data: data,
    }
}

type SwitchColorGetV3 struct {
    node byte
    ColorComponentID byte
}

func (c *SwitchColorGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorGetV3) Set(ColorComponentID byte,) error {
    c.ColorComponentID = ColorComponentID
}

func (c *SwitchColorGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColorV3),
        0x03,
        ColorComponentID,
        0x25,
    }
}
type SwitchColorReportV3 struct {
    *report
    node byte
    ColorComponentID byte
    CurrentValue byte
    TargetValue byte
    Duration byte
    data []byte
}

func NewSwitchColorReportV3(data []byte) *SwitchColorReportV3 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &SwitchColorReportV3{
        ColorComponentID: data[0],
        CurrentValue: data[1],
        TargetValue: data[2],
        Duration: data[3],
        data: data,
    }
}

type SwitchColorSetV3 struct {
    node byte
    Properties1 byte
    Duration byte
}

func (c *SwitchColorSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorSetV3) Set(Properties1 byte,Duration byte,) error {
    c.Properties1 = Properties1
    c.Duration = Duration
}

func (c *SwitchColorSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(SwitchColorV3),
        0x05,
        Properties1,
        Duration,
        0x25,
    }
}
type SwitchColorStartLevelChangeV3 struct {
    node byte
    Properties1 byte
    ColorComponentID byte
    StartLevel byte
    Duration byte
}

func (c *SwitchColorStartLevelChangeV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorStartLevelChangeV3) Set(Properties1 byte,ColorComponentID byte,StartLevel byte,Duration byte,) error {
    c.Properties1 = Properties1
    c.ColorComponentID = ColorComponentID
    c.StartLevel = StartLevel
    c.Duration = Duration
}

func (c *SwitchColorStartLevelChangeV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(SwitchColorV3),
        0x06,
        Properties1,
        ColorComponentID,
        StartLevel,
        Duration,
        0x25,
    }
}
type SwitchColorStopLevelChangeV3 struct {
    node byte
    ColorComponentID byte
}

func (c *SwitchColorStopLevelChangeV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *SwitchColorStopLevelChangeV3) Set(ColorComponentID byte,) error {
    c.ColorComponentID = ColorComponentID
}

func (c *SwitchColorStopLevelChangeV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(SwitchColorV3),
        0x07,
        ColorComponentID,
        0x25,
    }
}
package commands
type ScheduleSupportedGet struct {
    node byte
}

func (c *ScheduleSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleSupportedGet) Set() error {
}

func (c *ScheduleSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Schedule),
        0x01,
        0x25,
    }
}
type ScheduleSupportedReport struct {
    *report
    node byte
    NumberofSupportedScheduleID byte
    Properties1 byte
    NumberofsupportedCC byte
    Properties3 byte
    data []byte
}

func NewScheduleSupportedReport(data []byte) *ScheduleSupportedReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleSupportedReport{
        NumberofSupportedScheduleID: data[0],
        Properties1: data[1],
        NumberofsupportedCC: data[2],
        Properties3: data[3],
        data: data,
    }
}

type CommandScheduleSet struct {
    node byte
    ScheduleID byte
    UserIdentifier byte
    StartYear byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Properties4 byte
    Properties5 byte
    DurationByte byte
    ReportstoFollow byte
    NumberofCmdtoFollow byte
}

func (c *CommandScheduleSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandScheduleSet) Set(ScheduleID byte,UserIdentifier byte,StartYear byte,Properties1 byte,Properties2 byte,Properties3 byte,Properties4 byte,Properties5 byte,DurationByte byte,ReportstoFollow byte,NumberofCmdtoFollow byte,) error {
    c.ScheduleID = ScheduleID
    c.UserIdentifier = UserIdentifier
    c.StartYear = StartYear
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.Properties3 = Properties3
    c.Properties4 = Properties4
    c.Properties5 = Properties5
    c.DurationByte = DurationByte
    c.ReportstoFollow = ReportstoFollow
    c.NumberofCmdtoFollow = NumberofCmdtoFollow
}

func (c *CommandScheduleSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(Schedule),
        0x03,
        ScheduleID,
        UserIdentifier,
        StartYear,
        Properties1,
        Properties2,
        Properties3,
        Properties4,
        Properties5,
        DurationByte,
        ReportstoFollow,
        NumberofCmdtoFollow,
        0x25,
    }
}
type CommandScheduleGet struct {
    node byte
    ScheduleID byte
}

func (c *CommandScheduleGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandScheduleGet) Set(ScheduleID byte,) error {
    c.ScheduleID = ScheduleID
}

func (c *CommandScheduleGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Schedule),
        0x04,
        ScheduleID,
        0x25,
    }
}
type CommandScheduleReport struct {
    *report
    node byte
    ScheduleID byte
    UserIdentifier byte
    StartYear byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Properties4 byte
    Properties5 byte
    DurationByte byte
    ReportstoFollow byte
    NumberofCmdtoFollow byte
    data []byte
}

func NewCommandScheduleReport(data []byte) *CommandScheduleReport {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandScheduleReport{
        ScheduleID: data[0],
        UserIdentifier: data[1],
        StartYear: data[2],
        Properties1: data[3],
        Properties2: data[4],
        Properties3: data[5],
        Properties4: data[6],
        Properties5: data[7],
        DurationByte: data[8],
        ReportstoFollow: data[9],
        NumberofCmdtoFollow: data[10],
        data: data,
    }
}

type ScheduleRemove struct {
    node byte
    ScheduleID byte
}

func (c *ScheduleRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleRemove) Set(ScheduleID byte,) error {
    c.ScheduleID = ScheduleID
}

func (c *ScheduleRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Schedule),
        0x06,
        ScheduleID,
        0x25,
    }
}
type ScheduleStateSet struct {
    node byte
    ScheduleID byte
    ScheduleState byte
}

func (c *ScheduleStateSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleStateSet) Set(ScheduleID byte,ScheduleState byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleState = ScheduleState
}

func (c *ScheduleStateSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Schedule),
        0x07,
        ScheduleID,
        ScheduleState,
        0x25,
    }
}
type ScheduleStateGet struct {
    node byte
}

func (c *ScheduleStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleStateGet) Set() error {
}

func (c *ScheduleStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Schedule),
        0x08,
        0x25,
    }
}
type ScheduleStateReport struct {
    *report
    node byte
    NumberofSupportedScheduleID byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    data []byte
}

func NewScheduleStateReport(data []byte) *ScheduleStateReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleStateReport{
        NumberofSupportedScheduleID: data[0],
        Properties1: data[1],
        Properties2: data[2],
        Properties3: data[3],
        data: data,
    }
}

package commands
type ScheduleSupportedGetV2 struct {
    node byte
    ScheduleIDBlock byte
}

func (c *ScheduleSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleSupportedGetV2) Set(ScheduleIDBlock byte,) error {
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleV2),
        0x01,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleSupportedReportV2 struct {
    *report
    node byte
    NumberofSupportedScheduleID byte
    Properties1 byte
    NumberofsupportedCC byte
    Properties3 byte
    ScheduleIDBlock byte
    NumberofSupportedScheduleBlocks byte
    data []byte
}

func NewScheduleSupportedReportV2(data []byte) *ScheduleSupportedReportV2 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleSupportedReportV2{
        NumberofSupportedScheduleID: data[0],
        Properties1: data[1],
        NumberofsupportedCC: data[2],
        Properties3: data[3],
        ScheduleIDBlock: data[4],
        NumberofSupportedScheduleBlocks: data[5],
        data: data,
    }
}

type CommandScheduleSetV2 struct {
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
    StartYear byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Properties4 byte
    Properties5 byte
    DurationByte byte
    ReportstoFollow byte
    NumberofCmdtoFollow byte
}

func (c *CommandScheduleSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandScheduleSetV2) Set(ScheduleID byte,ScheduleIDBlock byte,StartYear byte,Properties1 byte,Properties2 byte,Properties3 byte,Properties4 byte,Properties5 byte,DurationByte byte,ReportstoFollow byte,NumberofCmdtoFollow byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleIDBlock = ScheduleIDBlock
    c.StartYear = StartYear
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.Properties3 = Properties3
    c.Properties4 = Properties4
    c.Properties5 = Properties5
    c.DurationByte = DurationByte
    c.ReportstoFollow = ReportstoFollow
    c.NumberofCmdtoFollow = NumberofCmdtoFollow
}

func (c *CommandScheduleSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(ScheduleV2),
        0x03,
        ScheduleID,
        ScheduleIDBlock,
        StartYear,
        Properties1,
        Properties2,
        Properties3,
        Properties4,
        Properties5,
        DurationByte,
        ReportstoFollow,
        NumberofCmdtoFollow,
        0x25,
    }
}
type CommandScheduleGetV2 struct {
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
}

func (c *CommandScheduleGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandScheduleGetV2) Set(ScheduleID byte,ScheduleIDBlock byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *CommandScheduleGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleV2),
        0x04,
        ScheduleID,
        ScheduleIDBlock,
        0x25,
    }
}
type CommandScheduleReportV2 struct {
    *report
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
    StartYear byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Properties4 byte
    Properties5 byte
    DurationByte byte
    ReportstoFollow byte
    NumberofCmdtoFollow byte
    data []byte
}

func NewCommandScheduleReportV2(data []byte) *CommandScheduleReportV2 {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandScheduleReportV2{
        ScheduleID: data[0],
        ScheduleIDBlock: data[1],
        StartYear: data[2],
        Properties1: data[3],
        Properties2: data[4],
        Properties3: data[5],
        Properties4: data[6],
        Properties5: data[7],
        DurationByte: data[8],
        ReportstoFollow: data[9],
        NumberofCmdtoFollow: data[10],
        data: data,
    }
}

type ScheduleRemoveV2 struct {
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
}

func (c *ScheduleRemoveV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleRemoveV2) Set(ScheduleID byte,ScheduleIDBlock byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleRemoveV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleV2),
        0x06,
        ScheduleID,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleStateSetV2 struct {
    node byte
    ScheduleID byte
    ScheduleState byte
    ScheduleIDBlock byte
}

func (c *ScheduleStateSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleStateSetV2) Set(ScheduleID byte,ScheduleState byte,ScheduleIDBlock byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleState = ScheduleState
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleStateSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ScheduleV2),
        0x07,
        ScheduleID,
        ScheduleState,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleStateGetV2 struct {
    node byte
    ScheduleIDBlock byte
}

func (c *ScheduleStateGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleStateGetV2) Set(ScheduleIDBlock byte,) error {
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleStateGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleV2),
        0x08,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleStateReportV2 struct {
    *report
    node byte
    NumberofSupportedScheduleID byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    ScheduleIDBlock byte
    data []byte
}

func NewScheduleStateReportV2(data []byte) *ScheduleStateReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleStateReportV2{
        NumberofSupportedScheduleID: data[0],
        Properties1: data[1],
        Properties2: data[2],
        Properties3: data[3],
        ScheduleIDBlock: data[4],
        data: data,
    }
}

package commands
type ScheduleSupportedGetV3 struct {
    node byte
    ScheduleIDBlock byte
}

func (c *ScheduleSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleSupportedGetV3) Set(ScheduleIDBlock byte,) error {
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleV3),
        0x01,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleSupportedReportV3 struct {
    *report
    node byte
    NumberofSupportedScheduleID byte
    Properties1 byte
    NumberofsupportedCC byte
    Properties3 byte
    ScheduleIDBlock byte
    NumberofSupportedScheduleBlocks byte
    data []byte
}

func NewScheduleSupportedReportV3(data []byte) *ScheduleSupportedReportV3 {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleSupportedReportV3{
        NumberofSupportedScheduleID: data[0],
        Properties1: data[1],
        NumberofsupportedCC: data[2],
        Properties3: data[3],
        ScheduleIDBlock: data[4],
        NumberofSupportedScheduleBlocks: data[5],
        data: data,
    }
}

type CommandScheduleSetV3 struct {
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
    StartYear byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Properties4 byte
    Properties5 byte
    DurationByte byte
    ReportstoFollow byte
    NumberofCmdtoFollow byte
}

func (c *CommandScheduleSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandScheduleSetV3) Set(ScheduleID byte,ScheduleIDBlock byte,StartYear byte,Properties1 byte,Properties2 byte,Properties3 byte,Properties4 byte,Properties5 byte,DurationByte byte,ReportstoFollow byte,NumberofCmdtoFollow byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleIDBlock = ScheduleIDBlock
    c.StartYear = StartYear
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.Properties3 = Properties3
    c.Properties4 = Properties4
    c.Properties5 = Properties5
    c.DurationByte = DurationByte
    c.ReportstoFollow = ReportstoFollow
    c.NumberofCmdtoFollow = NumberofCmdtoFollow
}

func (c *CommandScheduleSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(ScheduleV3),
        0x03,
        ScheduleID,
        ScheduleIDBlock,
        StartYear,
        Properties1,
        Properties2,
        Properties3,
        Properties4,
        Properties5,
        DurationByte,
        ReportstoFollow,
        NumberofCmdtoFollow,
        0x25,
    }
}
type CommandScheduleGetV3 struct {
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
    Properties1 byte
}

func (c *CommandScheduleGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandScheduleGetV3) Set(ScheduleID byte,ScheduleIDBlock byte,Properties1 byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleIDBlock = ScheduleIDBlock
    c.Properties1 = Properties1
}

func (c *CommandScheduleGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ScheduleV3),
        0x04,
        ScheduleID,
        ScheduleIDBlock,
        Properties1,
        0x25,
    }
}
type CommandScheduleReportV3 struct {
    *report
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
    StartYear byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    Properties4 byte
    Properties5 byte
    DurationByte byte
    ReportstoFollow byte
    NumberofCmdtoFollow byte
    data []byte
}

func NewCommandScheduleReportV3(data []byte) *CommandScheduleReportV3 {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandScheduleReportV3{
        ScheduleID: data[0],
        ScheduleIDBlock: data[1],
        StartYear: data[2],
        Properties1: data[3],
        Properties2: data[4],
        Properties3: data[5],
        Properties4: data[6],
        Properties5: data[7],
        DurationByte: data[8],
        ReportstoFollow: data[9],
        NumberofCmdtoFollow: data[10],
        data: data,
    }
}

type ScheduleRemoveV3 struct {
    node byte
    ScheduleID byte
    ScheduleIDBlock byte
}

func (c *ScheduleRemoveV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleRemoveV3) Set(ScheduleID byte,ScheduleIDBlock byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleRemoveV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ScheduleV3),
        0x06,
        ScheduleID,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleStateSetV3 struct {
    node byte
    ScheduleID byte
    ScheduleState byte
    ScheduleIDBlock byte
}

func (c *ScheduleStateSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleStateSetV3) Set(ScheduleID byte,ScheduleState byte,ScheduleIDBlock byte,) error {
    c.ScheduleID = ScheduleID
    c.ScheduleState = ScheduleState
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleStateSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ScheduleV3),
        0x07,
        ScheduleID,
        ScheduleState,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleStateGetV3 struct {
    node byte
    ScheduleIDBlock byte
}

func (c *ScheduleStateGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *ScheduleStateGetV3) Set(ScheduleIDBlock byte,) error {
    c.ScheduleIDBlock = ScheduleIDBlock
}

func (c *ScheduleStateGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ScheduleV3),
        0x08,
        ScheduleIDBlock,
        0x25,
    }
}
type ScheduleStateReportV3 struct {
    *report
    node byte
    NumberofSupportedScheduleID byte
    Properties1 byte
    Properties2 byte
    Properties3 byte
    ScheduleIDBlock byte
    data []byte
}

func NewScheduleStateReportV3(data []byte) *ScheduleStateReportV3 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ScheduleStateReportV3{
        NumberofSupportedScheduleID: data[0],
        Properties1: data[1],
        Properties2: data[2],
        Properties3: data[3],
        ScheduleIDBlock: data[4],
        data: data,
    }
}

package commands
type ControllerChange struct {
    node byte
    Seq.No byte
    Reserved byte
    Mode byte
    txOptions byte
}

func (c *ControllerChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *ControllerChange) Set(Seq.No byte,Reserved byte,Mode byte,txOptions byte,) error {
    c.Seq.No = Seq.No
    c.Reserved = Reserved
    c.Mode = Mode
    c.txOptions = txOptions
}

func (c *ControllerChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(NetworkManagementPrimary),
        0x01,
        Seq.No,
        Reserved,
        Mode,
        txOptions,
        0x25,
    }
}
type ControllerChangeStatus struct {
    node byte
    Seq.No byte
    Status byte
    Reserved byte
    NewNodeID byte
    NodeInfoLength byte
    Properties1 byte
    Properties2 byte
    BasicDeviceClass byte
    GenericDeviceClass byte
    SpecificDeviceClass byte
    CommandClass byte
}

func (c *ControllerChangeStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *ControllerChangeStatus) Set(Seq.No byte,Status byte,Reserved byte,NewNodeID byte,NodeInfoLength byte,Properties1 byte,Properties2 byte,BasicDeviceClass byte,GenericDeviceClass byte,SpecificDeviceClass byte,CommandClass byte,) error {
    c.Seq.No = Seq.No
    c.Status = Status
    c.Reserved = Reserved
    c.NewNodeID = NewNodeID
    c.NodeInfoLength = NodeInfoLength
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.BasicDeviceClass = BasicDeviceClass
    c.GenericDeviceClass = GenericDeviceClass
    c.SpecificDeviceClass = SpecificDeviceClass
    c.CommandClass = CommandClass
}

func (c *ControllerChangeStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(NetworkManagementPrimary),
        0x02,
        Seq.No,
        Status,
        Reserved,
        NewNodeID,
        NodeInfoLength,
        Properties1,
        Properties2,
        BasicDeviceClass,
        GenericDeviceClass,
        SpecificDeviceClass,
        CommandClass,
        0x25,
    }
}
package commands
type ZipNodeSolicitation struct {
    node byte
    Reserved byte
    NodeID byte
    IPv6Address byte
}

func (c *ZipNodeSolicitation) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipNodeSolicitation) Set(Reserved byte,NodeID byte,IPv6Address byte,) error {
    c.Reserved = Reserved
    c.NodeID = NodeID
    c.IPv6Address = IPv6Address
}

func (c *ZipNodeSolicitation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ZipNd),
        0x03,
        Reserved,
        NodeID,
        IPv6Address,
        0x25,
    }
}
type ZipInvNodeSolicitation struct {
    node byte
    Properties1 byte
    NodeID byte
}

func (c *ZipInvNodeSolicitation) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipInvNodeSolicitation) Set(Properties1 byte,NodeID byte,) error {
    c.Properties1 = Properties1
    c.NodeID = NodeID
}

func (c *ZipInvNodeSolicitation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ZipNd),
        0x04,
        Properties1,
        NodeID,
        0x25,
    }
}
type ZipNodeAdvertisement struct {
    node byte
    Properties1 byte
    NodeID byte
    IPv6Address byte
    HomeID byte
}

func (c *ZipNodeAdvertisement) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipNodeAdvertisement) Set(Properties1 byte,NodeID byte,IPv6Address byte,HomeID byte,) error {
    c.Properties1 = Properties1
    c.NodeID = NodeID
    c.IPv6Address = IPv6Address
    c.HomeID = HomeID
}

func (c *ZipNodeAdvertisement) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(ZipNd),
        0x01,
        Properties1,
        NodeID,
        IPv6Address,
        HomeID,
        0x25,
    }
}
package commands
type AssociationGroupNameGet struct {
    node byte
    GroupingIdentifier byte
}

func (c *AssociationGroupNameGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupNameGet) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupNameGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(AssociationGrpInfo),
        0x01,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupNameReport struct {
    *report
    node byte
    GroupingIdentifier byte
    LengthofName byte
    Name byte
    data []byte
}

func NewAssociationGroupNameReport(data []byte) *AssociationGroupNameReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupNameReport{
        GroupingIdentifier: data[0],
        LengthofName: data[1],
        Name: data[2],
        data: data,
    }
}

type AssociationGroupInfoGet struct {
    node byte
    Properties1 byte
    GroupingIdentifier byte
}

func (c *AssociationGroupInfoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupInfoGet) Set(Properties1 byte,GroupingIdentifier byte,) error {
    c.Properties1 = Properties1
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupInfoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationGrpInfo),
        0x03,
        Properties1,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupInfoReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewAssociationGroupInfoReport(data []byte) *AssociationGroupInfoReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupInfoReport{
        Properties1: data[0],
        data: data,
    }
}

type AssociationGroupCommandListGet struct {
    node byte
    Properties1 byte
    GroupingIdentifier byte
}

func (c *AssociationGroupCommandListGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupCommandListGet) Set(Properties1 byte,GroupingIdentifier byte,) error {
    c.Properties1 = Properties1
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupCommandListGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationGrpInfo),
        0x05,
        Properties1,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupCommandListReport struct {
    *report
    node byte
    GroupingIdentifier byte
    ListLength byte
    Command byte
    data []byte
}

func NewAssociationGroupCommandListReport(data []byte) *AssociationGroupCommandListReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupCommandListReport{
        GroupingIdentifier: data[0],
        ListLength: data[1],
        Command: data[2],
        data: data,
    }
}

package commands
type AssociationGroupNameGetV2 struct {
    node byte
    GroupingIdentifier byte
}

func (c *AssociationGroupNameGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupNameGetV2) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupNameGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(AssociationGrpInfoV2),
        0x01,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupNameReportV2 struct {
    *report
    node byte
    GroupingIdentifier byte
    LengthofName byte
    Name byte
    data []byte
}

func NewAssociationGroupNameReportV2(data []byte) *AssociationGroupNameReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupNameReportV2{
        GroupingIdentifier: data[0],
        LengthofName: data[1],
        Name: data[2],
        data: data,
    }
}

type AssociationGroupInfoGetV2 struct {
    node byte
    Properties1 byte
    GroupingIdentifier byte
}

func (c *AssociationGroupInfoGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupInfoGetV2) Set(Properties1 byte,GroupingIdentifier byte,) error {
    c.Properties1 = Properties1
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupInfoGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationGrpInfoV2),
        0x03,
        Properties1,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupInfoReportV2 struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewAssociationGroupInfoReportV2(data []byte) *AssociationGroupInfoReportV2 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupInfoReportV2{
        Properties1: data[0],
        data: data,
    }
}

type AssociationGroupCommandListGetV2 struct {
    node byte
    Properties1 byte
    GroupingIdentifier byte
}

func (c *AssociationGroupCommandListGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupCommandListGetV2) Set(Properties1 byte,GroupingIdentifier byte,) error {
    c.Properties1 = Properties1
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupCommandListGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationGrpInfoV2),
        0x05,
        Properties1,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupCommandListReportV2 struct {
    *report
    node byte
    GroupingIdentifier byte
    ListLength byte
    Command byte
    data []byte
}

func NewAssociationGroupCommandListReportV2(data []byte) *AssociationGroupCommandListReportV2 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupCommandListReportV2{
        GroupingIdentifier: data[0],
        ListLength: data[1],
        Command: data[2],
        data: data,
    }
}

package commands
type AssociationGroupNameGetV3 struct {
    node byte
    GroupingIdentifier byte
}

func (c *AssociationGroupNameGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupNameGetV3) Set(GroupingIdentifier byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupNameGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(AssociationGrpInfoV3),
        0x01,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupNameReportV3 struct {
    *report
    node byte
    GroupingIdentifier byte
    LengthofName byte
    Name byte
    data []byte
}

func NewAssociationGroupNameReportV3(data []byte) *AssociationGroupNameReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupNameReportV3{
        GroupingIdentifier: data[0],
        LengthofName: data[1],
        Name: data[2],
        data: data,
    }
}

type AssociationGroupInfoGetV3 struct {
    node byte
    Properties1 byte
    GroupingIdentifier byte
}

func (c *AssociationGroupInfoGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupInfoGetV3) Set(Properties1 byte,GroupingIdentifier byte,) error {
    c.Properties1 = Properties1
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupInfoGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationGrpInfoV3),
        0x03,
        Properties1,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupInfoReportV3 struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewAssociationGroupInfoReportV3(data []byte) *AssociationGroupInfoReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupInfoReportV3{
        Properties1: data[0],
        data: data,
    }
}

type AssociationGroupCommandListGetV3 struct {
    node byte
    Properties1 byte
    GroupingIdentifier byte
}

func (c *AssociationGroupCommandListGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *AssociationGroupCommandListGetV3) Set(Properties1 byte,GroupingIdentifier byte,) error {
    c.Properties1 = Properties1
    c.GroupingIdentifier = GroupingIdentifier
}

func (c *AssociationGroupCommandListGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(AssociationGrpInfoV3),
        0x05,
        Properties1,
        GroupingIdentifier,
        0x25,
    }
}
type AssociationGroupCommandListReportV3 struct {
    *report
    node byte
    GroupingIdentifier byte
    ListLength byte
    Command byte
    data []byte
}

func NewAssociationGroupCommandListReportV3(data []byte) *AssociationGroupCommandListReportV3 {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &AssociationGroupCommandListReportV3{
        GroupingIdentifier: data[0],
        ListLength: data[1],
        Command: data[2],
        data: data,
    }
}

package commands
type DeviceResetLocallyNotification struct {
    node byte
}

func (c *DeviceResetLocallyNotification) SetNode(node int) {
    c.node = byte(node)
}

func (c *DeviceResetLocallyNotification) Set() error {
}

func (c *DeviceResetLocallyNotification) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(DeviceResetLocally),
        0x01,
        0x25,
    }
}
package commands
type CentralSceneSupportedGet struct {
    node byte
}

func (c *CentralSceneSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneSupportedGet) Set() error {
}

func (c *CentralSceneSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(CentralScene),
        0x01,
        0x25,
    }
}
type CentralSceneSupportedReport struct {
    *report
    node byte
    SupportedScenes byte
    data []byte
}

func NewCentralSceneSupportedReport(data []byte) *CentralSceneSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &CentralSceneSupportedReport{
        SupportedScenes: data[0],
        data: data,
    }
}

type CentralSceneNotification struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    SceneNumber byte
}

func (c *CentralSceneNotification) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneNotification) Set(SequenceNumber byte,Properties1 byte,SceneNumber byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.SceneNumber = SceneNumber
}

func (c *CentralSceneNotification) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(CentralScene),
        0x03,
        SequenceNumber,
        Properties1,
        SceneNumber,
        0x25,
    }
}
package commands
type CentralSceneSupportedGetV2 struct {
    node byte
}

func (c *CentralSceneSupportedGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneSupportedGetV2) Set() error {
}

func (c *CentralSceneSupportedGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(CentralSceneV2),
        0x01,
        0x25,
    }
}
type CentralSceneSupportedReportV2 struct {
    *report
    node byte
    SupportedScenes byte
    Properties1 byte
    data []byte
}

func NewCentralSceneSupportedReportV2(data []byte) *CentralSceneSupportedReportV2 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &CentralSceneSupportedReportV2{
        SupportedScenes: data[0],
        Properties1: data[1],
        data: data,
    }
}

type CentralSceneNotificationV2 struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    SceneNumber byte
}

func (c *CentralSceneNotificationV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneNotificationV2) Set(SequenceNumber byte,Properties1 byte,SceneNumber byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.SceneNumber = SceneNumber
}

func (c *CentralSceneNotificationV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(CentralSceneV2),
        0x03,
        SequenceNumber,
        Properties1,
        SceneNumber,
        0x25,
    }
}
package commands
type CentralSceneSupportedGetV3 struct {
    node byte
}

func (c *CentralSceneSupportedGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneSupportedGetV3) Set() error {
}

func (c *CentralSceneSupportedGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(CentralSceneV3),
        0x01,
        0x25,
    }
}
type CentralSceneSupportedReportV3 struct {
    *report
    node byte
    SupportedScenes byte
    Properties1 byte
    data []byte
}

func NewCentralSceneSupportedReportV3(data []byte) *CentralSceneSupportedReportV3 {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &CentralSceneSupportedReportV3{
        SupportedScenes: data[0],
        Properties1: data[1],
        data: data,
    }
}

type CentralSceneNotificationV3 struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    SceneNumber byte
}

func (c *CentralSceneNotificationV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneNotificationV3) Set(SequenceNumber byte,Properties1 byte,SceneNumber byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.SceneNumber = SceneNumber
}

func (c *CentralSceneNotificationV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(CentralSceneV3),
        0x03,
        SequenceNumber,
        Properties1,
        SceneNumber,
        0x25,
    }
}
type CentralSceneConfigurationSetV3 struct {
    node byte
    Properties1 byte
}

func (c *CentralSceneConfigurationSetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneConfigurationSetV3) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *CentralSceneConfigurationSetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(CentralSceneV3),
        0x04,
        Properties1,
        0x25,
    }
}
type CentralSceneConfigurationGetV3 struct {
    node byte
}

func (c *CentralSceneConfigurationGetV3) SetNode(node int) {
    c.node = byte(node)
}

func (c *CentralSceneConfigurationGetV3) Set() error {
}

func (c *CentralSceneConfigurationGetV3) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(CentralSceneV3),
        0x05,
        0x25,
    }
}
type CentralSceneConfigurationReportV3 struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewCentralSceneConfigurationReportV3(data []byte) *CentralSceneConfigurationReportV3 {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &CentralSceneConfigurationReportV3{
        Properties1: data[0],
        data: data,
    }
}

package commands
type IpAssociationSet struct {
    node byte
    GroupingIdentifier byte
    IPv6Address byte
    EndPoint byte
}

func (c *IpAssociationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpAssociationSet) Set(GroupingIdentifier byte,IPv6Address byte,EndPoint byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.IPv6Address = IPv6Address
    c.EndPoint = EndPoint
}

func (c *IpAssociationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(IpAssociation),
        0x01,
        GroupingIdentifier,
        IPv6Address,
        EndPoint,
        0x25,
    }
}
type IpAssociationGet struct {
    node byte
    GroupingIdentifier byte
    Index byte
}

func (c *IpAssociationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpAssociationGet) Set(GroupingIdentifier byte,Index byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.Index = Index
}

func (c *IpAssociationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(IpAssociation),
        0x02,
        GroupingIdentifier,
        Index,
        0x25,
    }
}
type IpAssociationReport struct {
    *report
    node byte
    GroupingIdentifier byte
    Index byte
    ActualNodes byte
    IPv6Address byte
    EndPoint byte
    data []byte
}

func NewIpAssociationReport(data []byte) *IpAssociationReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &IpAssociationReport{
        GroupingIdentifier: data[0],
        Index: data[1],
        ActualNodes: data[2],
        IPv6Address: data[3],
        EndPoint: data[4],
        data: data,
    }
}

type IpAssociationRemove struct {
    node byte
    GroupingIdentifier byte
    IPv6Address byte
    EndPoint byte
}

func (c *IpAssociationRemove) SetNode(node int) {
    c.node = byte(node)
}

func (c *IpAssociationRemove) Set(GroupingIdentifier byte,IPv6Address byte,EndPoint byte,) error {
    c.GroupingIdentifier = GroupingIdentifier
    c.IPv6Address = IPv6Address
    c.EndPoint = EndPoint
}

func (c *IpAssociationRemove) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(IpAssociation),
        0x04,
        GroupingIdentifier,
        IPv6Address,
        EndPoint,
        0x25,
    }
}
package commands
type AntitheftSet struct {
    node byte
    Properties1 byte
    MagicCode byte
    ManufacturerID byte
    Anti-theftHintNumberBytes byte
    Anti-theftHintByte byte
}

func (c *AntitheftSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AntitheftSet) Set(Properties1 byte,MagicCode byte,ManufacturerID byte,Anti-theftHintNumberBytes byte,Anti-theftHintByte byte,) error {
    c.Properties1 = Properties1
    c.MagicCode = MagicCode
    c.ManufacturerID = ManufacturerID
    c.Anti-theftHintNumberBytes = Anti-theftHintNumberBytes
    c.Anti-theftHintByte = Anti-theftHintByte
}

func (c *AntitheftSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(Antitheft),
        0x01,
        Properties1,
        MagicCode,
        ManufacturerID,
        Anti-theftHintNumberBytes,
        Anti-theftHintByte,
        0x25,
    }
}
type AntitheftGet struct {
    node byte
}

func (c *AntitheftGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *AntitheftGet) Set() error {
}

func (c *AntitheftGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Antitheft),
        0x02,
        0x25,
    }
}
type AntitheftReport struct {
    *report
    node byte
    Anti-theftProtectionStatus byte
    ManufacturerID byte
    Anti-theftHintNumberBytes byte
    Anti-theftHintByte byte
    data []byte
}

func NewAntitheftReport(data []byte) *AntitheftReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &AntitheftReport{
        Anti-theftProtectionStatus: data[0],
        ManufacturerID: data[1],
        Anti-theftHintNumberBytes: data[2],
        Anti-theftHintByte: data[3],
        data: data,
    }
}

package commands
type AntitheftSetV2 struct {
    node byte
    Properties1 byte
    MagicCode byte
    ManufacturerID byte
    Anti-theftHintNumberBytes byte
    Anti-theftHintByte byte
}

func (c *AntitheftSetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AntitheftSetV2) Set(Properties1 byte,MagicCode byte,ManufacturerID byte,Anti-theftHintNumberBytes byte,Anti-theftHintByte byte,) error {
    c.Properties1 = Properties1
    c.MagicCode = MagicCode
    c.ManufacturerID = ManufacturerID
    c.Anti-theftHintNumberBytes = Anti-theftHintNumberBytes
    c.Anti-theftHintByte = Anti-theftHintByte
}

func (c *AntitheftSetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(AntitheftV2),
        0x01,
        Properties1,
        MagicCode,
        ManufacturerID,
        Anti-theftHintNumberBytes,
        Anti-theftHintByte,
        0x25,
    }
}
type AntitheftGetV2 struct {
    node byte
}

func (c *AntitheftGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *AntitheftGetV2) Set() error {
}

func (c *AntitheftGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(AntitheftV2),
        0x02,
        0x25,
    }
}
type AntitheftReportV2 struct {
    *report
    node byte
    Anti-theftProtectionStatus byte
    ManufacturerID byte
    Anti-theftHintNumberBytes byte
    Anti-theftHintByte byte
    data []byte
}

func NewAntitheftReportV2(data []byte) *AntitheftReportV2 {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &AntitheftReportV2{
        Anti-theftProtectionStatus: data[0],
        ManufacturerID: data[1],
        Anti-theftHintNumberBytes: data[2],
        Anti-theftHintByte: data[3],
        data: data,
    }
}

package commands
type ZwaveplusInfoGet struct {
    node byte
}

func (c *ZwaveplusInfoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZwaveplusInfoGet) Set() error {
}

func (c *ZwaveplusInfoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZwaveplusInfo),
        0x01,
        0x25,
    }
}
type ZwaveplusInfoReport struct {
    *report
    node byte
    Z-Wave+Version byte
    RoleType byte
    NodeType byte
    data []byte
}

func NewZwaveplusInfoReport(data []byte) *ZwaveplusInfoReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &ZwaveplusInfoReport{
        Z-Wave+Version: data[0],
        RoleType: data[1],
        NodeType: data[2],
        data: data,
    }
}

package commands
type ZwaveplusInfoGetV2 struct {
    node byte
}

func (c *ZwaveplusInfoGetV2) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZwaveplusInfoGetV2) Set() error {
}

func (c *ZwaveplusInfoGetV2) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZwaveplusInfoV2),
        0x01,
        0x25,
    }
}
type ZwaveplusInfoReportV2 struct {
    *report
    node byte
    Z-Wave+Version byte
    RoleType byte
    NodeType byte
    InstallerIconType byte
    UserIconType byte
    data []byte
}

func NewZwaveplusInfoReportV2(data []byte) *ZwaveplusInfoReportV2 {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &ZwaveplusInfoReportV2{
        Z-Wave+Version: data[0],
        RoleType: data[1],
        NodeType: data[2],
        InstallerIconType: data[3],
        UserIconType: data[4],
        data: data,
    }
}

package commands
type GatewayModeSet struct {
    node byte
    Mode byte
}

func (c *GatewayModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayModeSet) Set(Mode byte,) error {
    c.Mode = Mode
}

func (c *GatewayModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ZipGateway),
        0x01,
        Mode,
        0x25,
    }
}
type GatewayModeGet struct {
    node byte
}

func (c *GatewayModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayModeGet) Set() error {
}

func (c *GatewayModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZipGateway),
        0x02,
        0x25,
    }
}
type GatewayModeReport struct {
    *report
    node byte
    Mode byte
    data []byte
}

func NewGatewayModeReport(data []byte) *GatewayModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &GatewayModeReport{
        Mode: data[0],
        data: data,
    }
}

type GatewayPeerSet struct {
    node byte
    PeerProfile byte
    IPv6Address byte
    Port byte
    Properties1 byte
    PeerName byte
}

func (c *GatewayPeerSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayPeerSet) Set(PeerProfile byte,IPv6Address byte,Port byte,Properties1 byte,PeerName byte,) error {
    c.PeerProfile = PeerProfile
    c.IPv6Address = IPv6Address
    c.Port = Port
    c.Properties1 = Properties1
    c.PeerName = PeerName
}

func (c *GatewayPeerSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(ZipGateway),
        0x04,
        PeerProfile,
        IPv6Address,
        Port,
        Properties1,
        PeerName,
        0x25,
    }
}
type GatewayPeerGet struct {
    node byte
    PeerProfile byte
}

func (c *GatewayPeerGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayPeerGet) Set(PeerProfile byte,) error {
    c.PeerProfile = PeerProfile
}

func (c *GatewayPeerGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ZipGateway),
        0x05,
        PeerProfile,
        0x25,
    }
}
type GatewayPeerReport struct {
    *report
    node byte
    PeerProfile byte
    PeerCount byte
    IPv6Address byte
    Port byte
    Properties1 byte
    PeerName byte
    data []byte
}

func NewGatewayPeerReport(data []byte) *GatewayPeerReport {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &GatewayPeerReport{
        PeerProfile: data[0],
        PeerCount: data[1],
        IPv6Address: data[2],
        Port: data[3],
        Properties1: data[4],
        PeerName: data[5],
        data: data,
    }
}

type GatewayLockSet struct {
    node byte
    Properties1 byte
}

func (c *GatewayLockSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayLockSet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *GatewayLockSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ZipGateway),
        0x07,
        Properties1,
        0x25,
    }
}
type UnsolicitedDestinationSet struct {
    node byte
    UnsolicitedIPv6Destination byte
    UnsolicitedDestinationPort byte
}

func (c *UnsolicitedDestinationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *UnsolicitedDestinationSet) Set(UnsolicitedIPv6Destination byte,UnsolicitedDestinationPort byte,) error {
    c.UnsolicitedIPv6Destination = UnsolicitedIPv6Destination
    c.UnsolicitedDestinationPort = UnsolicitedDestinationPort
}

func (c *UnsolicitedDestinationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(ZipGateway),
        0x08,
        UnsolicitedIPv6Destination,
        UnsolicitedDestinationPort,
        0x25,
    }
}
type UnsolicitedDestinationGet struct {
    node byte
}

func (c *UnsolicitedDestinationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *UnsolicitedDestinationGet) Set() error {
}

func (c *UnsolicitedDestinationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZipGateway),
        0x09,
        0x25,
    }
}
type UnsolicitedDestinationReport struct {
    *report
    node byte
    UnsolicitedIPv6Destination byte
    UnsolicitedDestinationPort byte
    data []byte
}

func NewUnsolicitedDestinationReport(data []byte) *UnsolicitedDestinationReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &UnsolicitedDestinationReport{
        UnsolicitedIPv6Destination: data[0],
        UnsolicitedDestinationPort: data[1],
        data: data,
    }
}

type CommandApplicationNodeInfoSet struct {
    node byte
    Non-SecureCommandClass byte
    SecurityScheme0MARK byte
    SecurityScheme0CommandClass byte
}

func (c *CommandApplicationNodeInfoSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandApplicationNodeInfoSet) Set(Non-SecureCommandClass byte,SecurityScheme0MARK byte,SecurityScheme0CommandClass byte,) error {
    c.Non-SecureCommandClass = Non-SecureCommandClass
    c.SecurityScheme0MARK = SecurityScheme0MARK
    c.SecurityScheme0CommandClass = SecurityScheme0CommandClass
}

func (c *CommandApplicationNodeInfoSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(ZipGateway),
        0x0B,
        Non-SecureCommandClass,
        SecurityScheme0MARK,
        SecurityScheme0CommandClass,
        0x25,
    }
}
type CommandApplicationNodeInfoGet struct {
    node byte
}

func (c *CommandApplicationNodeInfoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *CommandApplicationNodeInfoGet) Set() error {
}

func (c *CommandApplicationNodeInfoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZipGateway),
        0x0C,
        0x25,
    }
}
type CommandApplicationNodeInfoReport struct {
    *report
    node byte
    Non-SecureCommandClass byte
    SecurityScheme0MARK byte
    SecurityScheme0CommandClass byte
    data []byte
}

func NewCommandApplicationNodeInfoReport(data []byte) *CommandApplicationNodeInfoReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &CommandApplicationNodeInfoReport{
        Non-SecureCommandClass: data[0],
        SecurityScheme0MARK: data[1],
        SecurityScheme0CommandClass: data[2],
        data: data,
    }
}

package commands
type GatewayConfigurationSet struct {
    node byte
    LANIPv6Address byte
    LANIPv6PrefixLength byte
    PortalIPv6Prefix byte
    PortalIPv6PrefixLength byte
    DefaultGatewayIPv6Address byte
    PANIPv6Prefix byte
}

func (c *GatewayConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayConfigurationSet) Set(LANIPv6Address byte,LANIPv6PrefixLength byte,PortalIPv6Prefix byte,PortalIPv6PrefixLength byte,DefaultGatewayIPv6Address byte,PANIPv6Prefix byte,) error {
    c.LANIPv6Address = LANIPv6Address
    c.LANIPv6PrefixLength = LANIPv6PrefixLength
    c.PortalIPv6Prefix = PortalIPv6Prefix
    c.PortalIPv6PrefixLength = PortalIPv6PrefixLength
    c.DefaultGatewayIPv6Address = DefaultGatewayIPv6Address
    c.PANIPv6Prefix = PANIPv6Prefix
}

func (c *GatewayConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(ZipPortal),
        0x01,
        LANIPv6Address,
        LANIPv6PrefixLength,
        PortalIPv6Prefix,
        PortalIPv6PrefixLength,
        DefaultGatewayIPv6Address,
        PANIPv6Prefix,
        0x25,
    }
}
type GatewayConfigurationStatus struct {
    node byte
    Status byte
}

func (c *GatewayConfigurationStatus) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayConfigurationStatus) Set(Status byte,) error {
    c.Status = Status
}

func (c *GatewayConfigurationStatus) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ZipPortal),
        0x02,
        Status,
        0x25,
    }
}
type GatewayConfigurationGet struct {
    node byte
}

func (c *GatewayConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *GatewayConfigurationGet) Set() error {
}

func (c *GatewayConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZipPortal),
        0x03,
        0x25,
    }
}
type GatewayConfigurationReport struct {
    *report
    node byte
    LANIPv6Address byte
    LANIPv6PrefixLength byte
    PortalIPv6Prefix byte
    PortalIPv6PrefixLength byte
    DefaultGatewayIPv6Address byte
    PANIPv6Prefix byte
    data []byte
}

func NewGatewayConfigurationReport(data []byte) *GatewayConfigurationReport {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &GatewayConfigurationReport{
        LANIPv6Address: data[0],
        LANIPv6PrefixLength: data[1],
        PortalIPv6Prefix: data[2],
        PortalIPv6PrefixLength: data[3],
        DefaultGatewayIPv6Address: data[4],
        PANIPv6Prefix: data[5],
        data: data,
    }
}

package commands
type DmxAddressSet struct {
    node byte
    Properties1 byte
    ChannelID byte
}

func (c *DmxAddressSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DmxAddressSet) Set(Properties1 byte,ChannelID byte,) error {
    c.Properties1 = Properties1
    c.ChannelID = ChannelID
}

func (c *DmxAddressSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Dmx),
        0x01,
        Properties1,
        ChannelID,
        0x25,
    }
}
type DmxAddressGet struct {
    node byte
}

func (c *DmxAddressGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DmxAddressGet) Set() error {
}

func (c *DmxAddressGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Dmx),
        0x02,
        0x25,
    }
}
type DmxAddressReport struct {
    *report
    node byte
    Properties1 byte
    ChannelID byte
    data []byte
}

func NewDmxAddressReport(data []byte) *DmxAddressReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &DmxAddressReport{
        Properties1: data[0],
        ChannelID: data[1],
        data: data,
    }
}

type DmxCapabilityGet struct {
    node byte
    ChannelID byte
}

func (c *DmxCapabilityGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *DmxCapabilityGet) Set(ChannelID byte,) error {
    c.ChannelID = ChannelID
}

func (c *DmxCapabilityGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Dmx),
        0x04,
        ChannelID,
        0x25,
    }
}
type DmxCapabilityReport struct {
    *report
    node byte
    ChannelID byte
    PropertyID byte
    DeviceChannels byte
    MaxChannels byte
    data []byte
}

func NewDmxCapabilityReport(data []byte) *DmxCapabilityReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &DmxCapabilityReport{
        ChannelID: data[0],
        PropertyID: data[1],
        DeviceChannels: data[2],
        MaxChannels: data[3],
        data: data,
    }
}

type DmxData struct {
    node byte
    Source byte
    Properties1 byte
    DMXchannel byte
}

func (c *DmxData) SetNode(node int) {
    c.node = byte(node)
}

func (c *DmxData) Set(Source byte,Properties1 byte,DMXchannel byte,) error {
    c.Source = Source
    c.Properties1 = Properties1
    c.DMXchannel = DMXchannel
}

func (c *DmxData) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Dmx),
        0x06,
        Source,
        Properties1,
        DMXchannel,
        0x25,
    }
}
package commands
type BarrierOperatorSet struct {
    node byte
    TargetValue byte
}

func (c *BarrierOperatorSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BarrierOperatorSet) Set(TargetValue byte,) error {
    c.TargetValue = TargetValue
}

func (c *BarrierOperatorSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(BarrierOperator),
        0x01,
        TargetValue,
        0x25,
    }
}
type BarrierOperatorGet struct {
    node byte
}

func (c *BarrierOperatorGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BarrierOperatorGet) Set() error {
}

func (c *BarrierOperatorGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(BarrierOperator),
        0x02,
        0x25,
    }
}
type BarrierOperatorReport struct {
    *report
    node byte
    State byte
    data []byte
}

func NewBarrierOperatorReport(data []byte) *BarrierOperatorReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &BarrierOperatorReport{
        State: data[0],
        data: data,
    }
}

type BarrierOperatorSignalSupportedGet struct {
    node byte
}

func (c *BarrierOperatorSignalSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BarrierOperatorSignalSupportedGet) Set() error {
}

func (c *BarrierOperatorSignalSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(BarrierOperator),
        0x04,
        0x25,
    }
}
type BarrierOperatorSignalSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewBarrierOperatorSignalSupportedReport(data []byte) *BarrierOperatorSignalSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &BarrierOperatorSignalSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

type BarrierOperatorSignalSet struct {
    node byte
    SubsystemType byte
    SubsystemState byte
}

func (c *BarrierOperatorSignalSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BarrierOperatorSignalSet) Set(SubsystemType byte,SubsystemState byte,) error {
    c.SubsystemType = SubsystemType
    c.SubsystemState = SubsystemState
}

func (c *BarrierOperatorSignalSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(BarrierOperator),
        0x06,
        SubsystemType,
        SubsystemState,
        0x25,
    }
}
type BarrierOperatorSignalGet struct {
    node byte
    SubsystemType byte
}

func (c *BarrierOperatorSignalGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *BarrierOperatorSignalGet) Set(SubsystemType byte,) error {
    c.SubsystemType = SubsystemType
}

func (c *BarrierOperatorSignalGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(BarrierOperator),
        0x07,
        SubsystemType,
        0x25,
    }
}
type BarrierOperatorSignalReport struct {
    *report
    node byte
    SubsystemType byte
    SubsystemState byte
    data []byte
}

func NewBarrierOperatorSignalReport(data []byte) *BarrierOperatorSignalReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &BarrierOperatorSignalReport{
        SubsystemType: data[0],
        SubsystemState: data[1],
        data: data,
    }
}

package commands
type LastWorkingRouteSet struct {
    node byte
    NodeID byte
    Repeater1 byte
    Repeater2 byte
    Repeater3 byte
    Repeater4 byte
    Speed byte
}

func (c *LastWorkingRouteSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LastWorkingRouteSet) Set(NodeID byte,Repeater1 byte,Repeater2 byte,Repeater3 byte,Repeater4 byte,Speed byte,) error {
    c.NodeID = NodeID
    c.Repeater1 = Repeater1
    c.Repeater2 = Repeater2
    c.Repeater3 = Repeater3
    c.Repeater4 = Repeater4
    c.Speed = Speed
}

func (c *LastWorkingRouteSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(NetworkManagementInstallationMaintenance),
        0x01,
        NodeID,
        Repeater1,
        Repeater2,
        Repeater3,
        Repeater4,
        Speed,
        0x25,
    }
}
type LastWorkingRouteGet struct {
    node byte
    NodeID byte
}

func (c *LastWorkingRouteGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *LastWorkingRouteGet) Set(NodeID byte,) error {
    c.NodeID = NodeID
}

func (c *LastWorkingRouteGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementInstallationMaintenance),
        0x02,
        NodeID,
        0x25,
    }
}
type LastWorkingRouteReport struct {
    *report
    node byte
    NodeID byte
    Repeater1 byte
    Repeater2 byte
    Repeater3 byte
    Repeater4 byte
    Speed byte
    data []byte
}

func NewLastWorkingRouteReport(data []byte) *LastWorkingRouteReport {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &LastWorkingRouteReport{
        NodeID: data[0],
        Repeater1: data[1],
        Repeater2: data[2],
        Repeater3: data[3],
        Repeater4: data[4],
        Speed: data[5],
        data: data,
    }
}

type StatisticsGet struct {
    node byte
    NodeID byte
}

func (c *StatisticsGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *StatisticsGet) Set(NodeID byte,) error {
    c.NodeID = NodeID
}

func (c *StatisticsGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(NetworkManagementInstallationMaintenance),
        0x04,
        NodeID,
        0x25,
    }
}
type StatisticsReport struct {
    *report
    node byte
    NodeID byte
    data []byte
}

func NewStatisticsReport(data []byte) *StatisticsReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &StatisticsReport{
        NodeID: data[0],
        data: data,
    }
}

type StatisticsClear struct {
    node byte
}

func (c *StatisticsClear) SetNode(node int) {
    c.node = byte(node)
}

func (c *StatisticsClear) Set() error {
}

func (c *StatisticsClear) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(NetworkManagementInstallationMaintenance),
        0x06,
        0x25,
    }
}
package commands
type ZipNamingNameSet struct {
    node byte
    Name byte
}

func (c *ZipNamingNameSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipNamingNameSet) Set(Name byte,) error {
    c.Name = Name
}

func (c *ZipNamingNameSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ZipNaming),
        0x01,
        Name,
        0x25,
    }
}
type ZipNamingNameGet struct {
    node byte
}

func (c *ZipNamingNameGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipNamingNameGet) Set() error {
}

func (c *ZipNamingNameGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZipNaming),
        0x02,
        0x25,
    }
}
type ZipNamingNameReport struct {
    *report
    node byte
    Name byte
    data []byte
}

func NewZipNamingNameReport(data []byte) *ZipNamingNameReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ZipNamingNameReport{
        Name: data[0],
        data: data,
    }
}

type ZipNamingLocationSet struct {
    node byte
    Location byte
}

func (c *ZipNamingLocationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipNamingLocationSet) Set(Location byte,) error {
    c.Location = Location
}

func (c *ZipNamingLocationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(ZipNaming),
        0x04,
        Location,
        0x25,
    }
}
type ZipNamingLocationGet struct {
    node byte
}

func (c *ZipNamingLocationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *ZipNamingLocationGet) Set() error {
}

func (c *ZipNamingLocationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(ZipNaming),
        0x05,
        0x25,
    }
}
type ZipNamingLocationReport struct {
    *report
    node byte
    Location byte
    data []byte
}

func NewZipNamingLocationReport(data []byte) *ZipNamingLocationReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &ZipNamingLocationReport{
        Location: data[0],
        data: data,
    }
}

package commands
type MailboxConfigurationGet struct {
    node byte
}

func (c *MailboxConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MailboxConfigurationGet) Set() error {
}

func (c *MailboxConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Mailbox),
        0x01,
        0x25,
    }
}
type MailboxConfigurationSet struct {
    node byte
    Properties1 byte
    ForwardingDestinationIPv6Address byte
    UDPPortNumber byte
}

func (c *MailboxConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *MailboxConfigurationSet) Set(Properties1 byte,ForwardingDestinationIPv6Address byte,UDPPortNumber byte,) error {
    c.Properties1 = Properties1
    c.ForwardingDestinationIPv6Address = ForwardingDestinationIPv6Address
    c.UDPPortNumber = UDPPortNumber
}

func (c *MailboxConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Mailbox),
        0x02,
        Properties1,
        ForwardingDestinationIPv6Address,
        UDPPortNumber,
        0x25,
    }
}
type MailboxConfigurationReport struct {
    *report
    node byte
    Properties1 byte
    MailboxCapacity byte
    ForwardingDestinationIPv6Address byte
    UDPPortNumber byte
    data []byte
}

func NewMailboxConfigurationReport(data []byte) *MailboxConfigurationReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &MailboxConfigurationReport{
        Properties1: data[0],
        MailboxCapacity: data[1],
        ForwardingDestinationIPv6Address: data[2],
        UDPPortNumber: data[3],
        data: data,
    }
}

type MailboxQueue struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    QueueHandle byte
    MailboxEntry byte
}

func (c *MailboxQueue) SetNode(node int) {
    c.node = byte(node)
}

func (c *MailboxQueue) Set(SequenceNumber byte,Properties1 byte,QueueHandle byte,MailboxEntry byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.QueueHandle = QueueHandle
    c.MailboxEntry = MailboxEntry
}

func (c *MailboxQueue) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(Mailbox),
        0x04,
        SequenceNumber,
        Properties1,
        QueueHandle,
        MailboxEntry,
        0x25,
    }
}
type MailboxWakeupNotification struct {
    node byte
    QueueHandle byte
}

func (c *MailboxWakeupNotification) SetNode(node int) {
    c.node = byte(node)
}

func (c *MailboxWakeupNotification) Set(QueueHandle byte,) error {
    c.QueueHandle = QueueHandle
}

func (c *MailboxWakeupNotification) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Mailbox),
        0x05,
        QueueHandle,
        0x25,
    }
}
type MailboxNodeFailing struct {
    node byte
    QueueHandle byte
}

func (c *MailboxNodeFailing) SetNode(node int) {
    c.node = byte(node)
}

func (c *MailboxNodeFailing) Set(QueueHandle byte,) error {
    c.QueueHandle = QueueHandle
}

func (c *MailboxNodeFailing) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Mailbox),
        0x06,
        QueueHandle,
        0x25,
    }
}
package commands
type WindowCoveringSupportedGet struct {
    node byte
}

func (c *WindowCoveringSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *WindowCoveringSupportedGet) Set() error {
}

func (c *WindowCoveringSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(WindowCovering),
        0x01,
        0x25,
    }
}
type WindowCoveringSupportedReport struct {
    *report
    node byte
    Properties1 byte
    ParameterMask byte
    data []byte
}

func NewWindowCoveringSupportedReport(data []byte) *WindowCoveringSupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &WindowCoveringSupportedReport{
        Properties1: data[0],
        ParameterMask: data[1],
        data: data,
    }
}

type WindowCoveringGet struct {
    node byte
    ParameterID byte
}

func (c *WindowCoveringGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *WindowCoveringGet) Set(ParameterID byte,) error {
    c.ParameterID = ParameterID
}

func (c *WindowCoveringGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(WindowCovering),
        0x03,
        ParameterID,
        0x25,
    }
}
type WindowCoveringReport struct {
    *report
    node byte
    ParameterID byte
    CurrentValue byte
    TargetValue byte
    Duration byte
    data []byte
}

func NewWindowCoveringReport(data []byte) *WindowCoveringReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &WindowCoveringReport{
        ParameterID: data[0],
        CurrentValue: data[1],
        TargetValue: data[2],
        Duration: data[3],
        data: data,
    }
}

type WindowCoveringSet struct {
    node byte
    Properties1 byte
    Duration byte
}

func (c *WindowCoveringSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *WindowCoveringSet) Set(Properties1 byte,Duration byte,) error {
    c.Properties1 = Properties1
    c.Duration = Duration
}

func (c *WindowCoveringSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(WindowCovering),
        0x05,
        Properties1,
        Duration,
        0x25,
    }
}
type WindowCoveringStartLevelChange struct {
    node byte
    Properties1 byte
    ParameterID byte
    Duration byte
}

func (c *WindowCoveringStartLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *WindowCoveringStartLevelChange) Set(Properties1 byte,ParameterID byte,Duration byte,) error {
    c.Properties1 = Properties1
    c.ParameterID = ParameterID
    c.Duration = Duration
}

func (c *WindowCoveringStartLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(WindowCovering),
        0x06,
        Properties1,
        ParameterID,
        Duration,
        0x25,
    }
}
type WindowCoveringStopLevelChange struct {
    node byte
    ParameterID byte
}

func (c *WindowCoveringStopLevelChange) SetNode(node int) {
    c.node = byte(node)
}

func (c *WindowCoveringStopLevelChange) Set(ParameterID byte,) error {
    c.ParameterID = ParameterID
}

func (c *WindowCoveringStopLevelChange) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(WindowCovering),
        0x07,
        ParameterID,
        0x25,
    }
}
package commands
type Security2NonceGet struct {
    node byte
    SequenceNumber byte
}

func (c *Security2NonceGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2NonceGet) Set(SequenceNumber byte,) error {
    c.SequenceNumber = SequenceNumber
}

func (c *Security2NonceGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security2),
        0x01,
        SequenceNumber,
        0x25,
    }
}
type Security2NonceReport struct {
    *report
    node byte
    SequenceNumber byte
    Properties1 byte
    ReceiversEntropyInput byte
    data []byte
}

func NewSecurity2NonceReport(data []byte) *Security2NonceReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &Security2NonceReport{
        SequenceNumber: data[0],
        Properties1: data[1],
        ReceiversEntropyInput: data[2],
        data: data,
    }
}

type Security2MessageEncapsulation struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    CCMCiphertextObject byte
}

func (c *Security2MessageEncapsulation) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2MessageEncapsulation) Set(SequenceNumber byte,Properties1 byte,CCMCiphertextObject byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.CCMCiphertextObject = CCMCiphertextObject
}

func (c *Security2MessageEncapsulation) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Security2),
        0x03,
        SequenceNumber,
        Properties1,
        CCMCiphertextObject,
        0x25,
    }
}
type KexGet struct {
    node byte
}

func (c *KexGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *KexGet) Set() error {
}

func (c *KexGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security2),
        0x04,
        0x25,
    }
}
type KexReport struct {
    *report
    node byte
    Properties1 byte
    SupportedKEXSchemes byte
    SupportedECDHProfiles byte
    RequestedKeys byte
    data []byte
}

func NewKexReport(data []byte) *KexReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &KexReport{
        Properties1: data[0],
        SupportedKEXSchemes: data[1],
        SupportedECDHProfiles: data[2],
        RequestedKeys: data[3],
        data: data,
    }
}

type KexSet struct {
    node byte
    Properties1 byte
    SelectedKEXScheme byte
    SelectedECDHProfile byte
    GrantedKeys byte
}

func (c *KexSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *KexSet) Set(Properties1 byte,SelectedKEXScheme byte,SelectedECDHProfile byte,GrantedKeys byte,) error {
    c.Properties1 = Properties1
    c.SelectedKEXScheme = SelectedKEXScheme
    c.SelectedECDHProfile = SelectedECDHProfile
    c.GrantedKeys = GrantedKeys
}

func (c *KexSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(4),
        byte(Security2),
        0x06,
        Properties1,
        SelectedKEXScheme,
        SelectedECDHProfile,
        GrantedKeys,
        0x25,
    }
}
type KexFail struct {
    node byte
    KEXFailType byte
}

func (c *KexFail) SetNode(node int) {
    c.node = byte(node)
}

func (c *KexFail) Set(KEXFailType byte,) error {
    c.KEXFailType = KEXFailType
}

func (c *KexFail) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security2),
        0x07,
        KEXFailType,
        0x25,
    }
}
type PublicKeyReport struct {
    *report
    node byte
    Properties1 byte
    ECDHPublicKey byte
    data []byte
}

func NewPublicKeyReport(data []byte) *PublicKeyReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &PublicKeyReport{
        Properties1: data[0],
        ECDHPublicKey: data[1],
        data: data,
    }
}

type Security2NetworkKeyGet struct {
    node byte
    RequestedKey byte
}

func (c *Security2NetworkKeyGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2NetworkKeyGet) Set(RequestedKey byte,) error {
    c.RequestedKey = RequestedKey
}

func (c *Security2NetworkKeyGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security2),
        0x09,
        RequestedKey,
        0x25,
    }
}
type Security2NetworkKeyReport struct {
    *report
    node byte
    GrantedKey byte
    NetworkKey byte
    data []byte
}

func NewSecurity2NetworkKeyReport(data []byte) *Security2NetworkKeyReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &Security2NetworkKeyReport{
        GrantedKey: data[0],
        NetworkKey: data[1],
        data: data,
    }
}

type Security2NetworkKeyVerify struct {
    node byte
}

func (c *Security2NetworkKeyVerify) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2NetworkKeyVerify) Set() error {
}

func (c *Security2NetworkKeyVerify) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security2),
        0x0B,
        0x25,
    }
}
type Security2TransferEnd struct {
    node byte
    Properties1 byte
}

func (c *Security2TransferEnd) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2TransferEnd) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *Security2TransferEnd) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Security2),
        0x0C,
        Properties1,
        0x25,
    }
}
type Security2CommandsSupportedGet struct {
    node byte
}

func (c *Security2CommandsSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2CommandsSupportedGet) Set() error {
}

func (c *Security2CommandsSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security2),
        0x0D,
        0x25,
    }
}
type Security2CommandsSupportedReport struct {
    *report
    node byte
    CommandClass byte
    data []byte
}

func NewSecurity2CommandsSupportedReport(data []byte) *Security2CommandsSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &Security2CommandsSupportedReport{
        CommandClass: data[0],
        data: data,
    }
}

type Security2CapabilitiesGet struct {
    node byte
}

func (c *Security2CapabilitiesGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *Security2CapabilitiesGet) Set() error {
}

func (c *Security2CapabilitiesGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Security2),
        0x0F,
        0x25,
    }
}
type Security2CapabilitiesReport struct {
    *report
    node byte
    SupportedSPANs byte
    SupportedMPANs byte
    data []byte
}

func NewSecurity2CapabilitiesReport(data []byte) *Security2CapabilitiesReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &Security2CapabilitiesReport{
        SupportedSPANs: data[0],
        SupportedMPANs: data[1],
        data: data,
    }
}

package commands
type IrrigationSystemInfoGet struct {
    node byte
}

func (c *IrrigationSystemInfoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationSystemInfoGet) Set() error {
}

func (c *IrrigationSystemInfoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Irrigation),
        0x01,
        0x25,
    }
}
type IrrigationSystemInfoReport struct {
    *report
    node byte
    Properties1 byte
    TotalNumberofValves byte
    TotalNumberofValveTables byte
    Properties2 byte
    data []byte
}

func NewIrrigationSystemInfoReport(data []byte) *IrrigationSystemInfoReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &IrrigationSystemInfoReport{
        Properties1: data[0],
        TotalNumberofValves: data[1],
        TotalNumberofValveTables: data[2],
        Properties2: data[3],
        data: data,
    }
}

type IrrigationSystemStatusGet struct {
    node byte
}

func (c *IrrigationSystemStatusGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationSystemStatusGet) Set() error {
}

func (c *IrrigationSystemStatusGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Irrigation),
        0x03,
        0x25,
    }
}
type IrrigationSystemStatusReport struct {
    *report
    node byte
    SystemVoltage byte
    SensorStatus byte
    Properties1 byte
    FlowValue byte
    Properties2 byte
    PressureValue byte
    ShutoffDuration byte
    SystemErrorStatus byte
    Properties3 byte
    ValveID byte
    data []byte
}

func NewIrrigationSystemStatusReport(data []byte) *IrrigationSystemStatusReport {
    if len(data) < 10 {
        for i := len(data); i < 10; i++ {
            data = append(data, 0x00)
        }
    }

    return &IrrigationSystemStatusReport{
        SystemVoltage: data[0],
        SensorStatus: data[1],
        Properties1: data[2],
        FlowValue: data[3],
        Properties2: data[4],
        PressureValue: data[5],
        ShutoffDuration: data[6],
        SystemErrorStatus: data[7],
        Properties3: data[8],
        ValveID: data[9],
        data: data,
    }
}

type IrrigationSystemConfigSet struct {
    node byte
    MasterValveDelay byte
    Properties1 byte
    HighPressureThresholdValue byte
    Properties2 byte
    LowPressureThresholdValue byte
    SensorPolarity byte
}

func (c *IrrigationSystemConfigSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationSystemConfigSet) Set(MasterValveDelay byte,Properties1 byte,HighPressureThresholdValue byte,Properties2 byte,LowPressureThresholdValue byte,SensorPolarity byte,) error {
    c.MasterValveDelay = MasterValveDelay
    c.Properties1 = Properties1
    c.HighPressureThresholdValue = HighPressureThresholdValue
    c.Properties2 = Properties2
    c.LowPressureThresholdValue = LowPressureThresholdValue
    c.SensorPolarity = SensorPolarity
}

func (c *IrrigationSystemConfigSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(6),
        byte(Irrigation),
        0x05,
        MasterValveDelay,
        Properties1,
        HighPressureThresholdValue,
        Properties2,
        LowPressureThresholdValue,
        SensorPolarity,
        0x25,
    }
}
type IrrigationSystemConfigGet struct {
    node byte
}

func (c *IrrigationSystemConfigGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationSystemConfigGet) Set() error {
}

func (c *IrrigationSystemConfigGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(Irrigation),
        0x06,
        0x25,
    }
}
type IrrigationSystemConfigReport struct {
    *report
    node byte
    MasterValveDelay byte
    Properties1 byte
    HighPressureThresholdValue byte
    Properties2 byte
    LowPressureThresholdValue byte
    SensorPolarity byte
    data []byte
}

func NewIrrigationSystemConfigReport(data []byte) *IrrigationSystemConfigReport {
    if len(data) < 6 {
        for i := len(data); i < 6; i++ {
            data = append(data, 0x00)
        }
    }

    return &IrrigationSystemConfigReport{
        MasterValveDelay: data[0],
        Properties1: data[1],
        HighPressureThresholdValue: data[2],
        Properties2: data[3],
        LowPressureThresholdValue: data[4],
        SensorPolarity: data[5],
        data: data,
    }
}

type IrrigationValveInfoGet struct {
    node byte
    Properties1 byte
    ValveID byte
}

func (c *IrrigationValveInfoGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveInfoGet) Set(Properties1 byte,ValveID byte,) error {
    c.Properties1 = Properties1
    c.ValveID = ValveID
}

func (c *IrrigationValveInfoGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Irrigation),
        0x08,
        Properties1,
        ValveID,
        0x25,
    }
}
type IrrigationValveInfoReport struct {
    *report
    node byte
    Properties1 byte
    ValveID byte
    NominalCurrent byte
    ValveErrorStatus byte
    data []byte
}

func NewIrrigationValveInfoReport(data []byte) *IrrigationValveInfoReport {
    if len(data) < 4 {
        for i := len(data); i < 4; i++ {
            data = append(data, 0x00)
        }
    }

    return &IrrigationValveInfoReport{
        Properties1: data[0],
        ValveID: data[1],
        NominalCurrent: data[2],
        ValveErrorStatus: data[3],
        data: data,
    }
}

type IrrigationValveConfigSet struct {
    node byte
    Properties1 byte
    ValveID byte
    NominalCurrentHighThreshold byte
    NominalCurrentLowThreshold byte
    Properties2 byte
    MaximumFlowValue byte
    Properties3 byte
    FlowHighThresholdValue byte
    Properties4 byte
    FlowLowThresholdValue byte
    SensorUsage byte
}

func (c *IrrigationValveConfigSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveConfigSet) Set(Properties1 byte,ValveID byte,NominalCurrentHighThreshold byte,NominalCurrentLowThreshold byte,Properties2 byte,MaximumFlowValue byte,Properties3 byte,FlowHighThresholdValue byte,Properties4 byte,FlowLowThresholdValue byte,SensorUsage byte,) error {
    c.Properties1 = Properties1
    c.ValveID = ValveID
    c.NominalCurrentHighThreshold = NominalCurrentHighThreshold
    c.NominalCurrentLowThreshold = NominalCurrentLowThreshold
    c.Properties2 = Properties2
    c.MaximumFlowValue = MaximumFlowValue
    c.Properties3 = Properties3
    c.FlowHighThresholdValue = FlowHighThresholdValue
    c.Properties4 = Properties4
    c.FlowLowThresholdValue = FlowLowThresholdValue
    c.SensorUsage = SensorUsage
}

func (c *IrrigationValveConfigSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(11),
        byte(Irrigation),
        0x0A,
        Properties1,
        ValveID,
        NominalCurrentHighThreshold,
        NominalCurrentLowThreshold,
        Properties2,
        MaximumFlowValue,
        Properties3,
        FlowHighThresholdValue,
        Properties4,
        FlowLowThresholdValue,
        SensorUsage,
        0x25,
    }
}
type IrrigationValveConfigGet struct {
    node byte
    Properties1 byte
    ValveID byte
}

func (c *IrrigationValveConfigGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveConfigGet) Set(Properties1 byte,ValveID byte,) error {
    c.Properties1 = Properties1
    c.ValveID = ValveID
}

func (c *IrrigationValveConfigGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(Irrigation),
        0x0B,
        Properties1,
        ValveID,
        0x25,
    }
}
type IrrigationValveConfigReport struct {
    *report
    node byte
    Properties1 byte
    ValveID byte
    NominalCurrentHighThreshold byte
    NominalCurrentLowThreshold byte
    Properties2 byte
    MaximumFlowValue byte
    Properties3 byte
    FlowHighThresholdValue byte
    Properties4 byte
    FlowLowThresholdValue byte
    SensorUsage byte
    data []byte
}

func NewIrrigationValveConfigReport(data []byte) *IrrigationValveConfigReport {
    if len(data) < 11 {
        for i := len(data); i < 11; i++ {
            data = append(data, 0x00)
        }
    }

    return &IrrigationValveConfigReport{
        Properties1: data[0],
        ValveID: data[1],
        NominalCurrentHighThreshold: data[2],
        NominalCurrentLowThreshold: data[3],
        Properties2: data[4],
        MaximumFlowValue: data[5],
        Properties3: data[6],
        FlowHighThresholdValue: data[7],
        Properties4: data[8],
        FlowLowThresholdValue: data[9],
        SensorUsage: data[10],
        data: data,
    }
}

type IrrigationValveRun struct {
    node byte
    Properties1 byte
    ValveID byte
    Duration byte
}

func (c *IrrigationValveRun) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveRun) Set(Properties1 byte,ValveID byte,Duration byte,) error {
    c.Properties1 = Properties1
    c.ValveID = ValveID
    c.Duration = Duration
}

func (c *IrrigationValveRun) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Irrigation),
        0x0D,
        Properties1,
        ValveID,
        Duration,
        0x25,
    }
}
type IrrigationValveTableSet struct {
    node byte
    ValveTableID byte
}

func (c *IrrigationValveTableSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveTableSet) Set(ValveTableID byte,) error {
    c.ValveTableID = ValveTableID
}

func (c *IrrigationValveTableSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Irrigation),
        0x0E,
        ValveTableID,
        0x25,
    }
}
type IrrigationValveTableGet struct {
    node byte
    ValveTableID byte
}

func (c *IrrigationValveTableGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveTableGet) Set(ValveTableID byte,) error {
    c.ValveTableID = ValveTableID
}

func (c *IrrigationValveTableGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Irrigation),
        0x0F,
        ValveTableID,
        0x25,
    }
}
type IrrigationValveTableReport struct {
    *report
    node byte
    ValveTableID byte
    data []byte
}

func NewIrrigationValveTableReport(data []byte) *IrrigationValveTableReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &IrrigationValveTableReport{
        ValveTableID: data[0],
        data: data,
    }
}

type IrrigationValveTableRun struct {
    node byte
    ValveTableID byte
}

func (c *IrrigationValveTableRun) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationValveTableRun) Set(ValveTableID byte,) error {
    c.ValveTableID = ValveTableID
}

func (c *IrrigationValveTableRun) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Irrigation),
        0x11,
        ValveTableID,
        0x25,
    }
}
type IrrigationSystemShutoff struct {
    node byte
    Duration byte
}

func (c *IrrigationSystemShutoff) SetNode(node int) {
    c.node = byte(node)
}

func (c *IrrigationSystemShutoff) Set(Duration byte,) error {
    c.Duration = Duration
}

func (c *IrrigationSystemShutoff) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(Irrigation),
        0x12,
        Duration,
        0x25,
    }
}
package commands
type SupervisionGet struct {
    node byte
    Properties1 byte
    EncapsulatedCommandLength byte
    EncapsulatedCommand byte
}

func (c *SupervisionGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *SupervisionGet) Set(Properties1 byte,EncapsulatedCommandLength byte,EncapsulatedCommand byte,) error {
    c.Properties1 = Properties1
    c.EncapsulatedCommandLength = EncapsulatedCommandLength
    c.EncapsulatedCommand = EncapsulatedCommand
}

func (c *SupervisionGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(Supervision),
        0x01,
        Properties1,
        EncapsulatedCommandLength,
        EncapsulatedCommand,
        0x25,
    }
}
type SupervisionReport struct {
    *report
    node byte
    Properties1 byte
    Status byte
    Duration byte
    data []byte
}

func NewSupervisionReport(data []byte) *SupervisionReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &SupervisionReport{
        Properties1: data[0],
        Status: data[1],
        Duration: data[2],
        data: data,
    }
}

package commands
type HumidityControlSetpointSet struct {
    node byte
    Properties1 byte
    Properties2 byte
    Value byte
}

func (c *HumidityControlSetpointSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlSetpointSet) Set(Properties1 byte,Properties2 byte,Value byte,) error {
    c.Properties1 = Properties1
    c.Properties2 = Properties2
    c.Value = Value
}

func (c *HumidityControlSetpointSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(3),
        byte(HumidityControlSetpoint),
        0x01,
        Properties1,
        Properties2,
        Value,
        0x25,
    }
}
type HumidityControlSetpointGet struct {
    node byte
    Properties1 byte
}

func (c *HumidityControlSetpointGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlSetpointGet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *HumidityControlSetpointGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HumidityControlSetpoint),
        0x02,
        Properties1,
        0x25,
    }
}
type HumidityControlSetpointReport struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    Value byte
    data []byte
}

func NewHumidityControlSetpointReport(data []byte) *HumidityControlSetpointReport {
    if len(data) < 3 {
        for i := len(data); i < 3; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlSetpointReport{
        Properties1: data[0],
        Properties2: data[1],
        Value: data[2],
        data: data,
    }
}

type HumidityControlSetpointSupportedGet struct {
    node byte
}

func (c *HumidityControlSetpointSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlSetpointSupportedGet) Set() error {
}

func (c *HumidityControlSetpointSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HumidityControlSetpoint),
        0x04,
        0x25,
    }
}
type HumidityControlSetpointSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewHumidityControlSetpointSupportedReport(data []byte) *HumidityControlSetpointSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlSetpointSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

type HumidityControlSetpointScaleSupportedGet struct {
    node byte
    Properties1 byte
}

func (c *HumidityControlSetpointScaleSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlSetpointScaleSupportedGet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *HumidityControlSetpointScaleSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HumidityControlSetpoint),
        0x06,
        Properties1,
        0x25,
    }
}
type HumidityControlSetpointScaleSupportedReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewHumidityControlSetpointScaleSupportedReport(data []byte) *HumidityControlSetpointScaleSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlSetpointScaleSupportedReport{
        Properties1: data[0],
        data: data,
    }
}

type HumidityControlSetpointCapabilitiesGet struct {
    node byte
    Properties1 byte
}

func (c *HumidityControlSetpointCapabilitiesGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlSetpointCapabilitiesGet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *HumidityControlSetpointCapabilitiesGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HumidityControlSetpoint),
        0x08,
        Properties1,
        0x25,
    }
}
type HumidityControlSetpointCapabilitiesReport struct {
    *report
    node byte
    Properties1 byte
    Properties2 byte
    MinimumValue byte
    Properties3 byte
    MaximumValue byte
    data []byte
}

func NewHumidityControlSetpointCapabilitiesReport(data []byte) *HumidityControlSetpointCapabilitiesReport {
    if len(data) < 5 {
        for i := len(data); i < 5; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlSetpointCapabilitiesReport{
        Properties1: data[0],
        Properties2: data[1],
        MinimumValue: data[2],
        Properties3: data[3],
        MaximumValue: data[4],
        data: data,
    }
}

package commands
type HumidityControlModeSet struct {
    node byte
    Properties1 byte
}

func (c *HumidityControlModeSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlModeSet) Set(Properties1 byte,) error {
    c.Properties1 = Properties1
}

func (c *HumidityControlModeSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(1),
        byte(HumidityControlMode),
        0x01,
        Properties1,
        0x25,
    }
}
type HumidityControlModeGet struct {
    node byte
}

func (c *HumidityControlModeGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlModeGet) Set() error {
}

func (c *HumidityControlModeGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HumidityControlMode),
        0x02,
        0x25,
    }
}
type HumidityControlModeReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewHumidityControlModeReport(data []byte) *HumidityControlModeReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlModeReport{
        Properties1: data[0],
        data: data,
    }
}

type HumidityControlModeSupportedGet struct {
    node byte
}

func (c *HumidityControlModeSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlModeSupportedGet) Set() error {
}

func (c *HumidityControlModeSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HumidityControlMode),
        0x04,
        0x25,
    }
}
type HumidityControlModeSupportedReport struct {
    *report
    node byte
    BitMask byte
    data []byte
}

func NewHumidityControlModeSupportedReport(data []byte) *HumidityControlModeSupportedReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlModeSupportedReport{
        BitMask: data[0],
        data: data,
    }
}

package commands
type HumidityControlOperatingStateGet struct {
    node byte
}

func (c *HumidityControlOperatingStateGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *HumidityControlOperatingStateGet) Set() error {
}

func (c *HumidityControlOperatingStateGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(HumidityControlOperatingState),
        0x01,
        0x25,
    }
}
type HumidityControlOperatingStateReport struct {
    *report
    node byte
    Properties1 byte
    data []byte
}

func NewHumidityControlOperatingStateReport(data []byte) *HumidityControlOperatingStateReport {
    if len(data) < 1 {
        for i := len(data); i < 1; i++ {
            data = append(data, 0x00)
        }
    }

    return &HumidityControlOperatingStateReport{
        Properties1: data[0],
        data: data,
    }
}

package commands
type EntryControlNotification struct {
    node byte
    SequenceNumber byte
    Properties1 byte
    EventType byte
    EventDataLength byte
    EventData byte
}

func (c *EntryControlNotification) SetNode(node int) {
    c.node = byte(node)
}

func (c *EntryControlNotification) Set(SequenceNumber byte,Properties1 byte,EventType byte,EventDataLength byte,EventData byte,) error {
    c.SequenceNumber = SequenceNumber
    c.Properties1 = Properties1
    c.EventType = EventType
    c.EventDataLength = EventDataLength
    c.EventData = EventData
}

func (c *EntryControlNotification) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(5),
        byte(EntryControl),
        0x01,
        SequenceNumber,
        Properties1,
        EventType,
        EventDataLength,
        EventData,
        0x25,
    }
}
type EntryControlKeySupportedGet struct {
    node byte
}

func (c *EntryControlKeySupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *EntryControlKeySupportedGet) Set() error {
}

func (c *EntryControlKeySupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(EntryControl),
        0x02,
        0x25,
    }
}
type EntryControlKeySupportedReport struct {
    *report
    node byte
    KeySupportedBitMaskLength byte
    KeySupportedBitMask byte
    data []byte
}

func NewEntryControlKeySupportedReport(data []byte) *EntryControlKeySupportedReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &EntryControlKeySupportedReport{
        KeySupportedBitMaskLength: data[0],
        KeySupportedBitMask: data[1],
        data: data,
    }
}

type EntryControlEventSupportedGet struct {
    node byte
}

func (c *EntryControlEventSupportedGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *EntryControlEventSupportedGet) Set() error {
}

func (c *EntryControlEventSupportedGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(EntryControl),
        0x04,
        0x25,
    }
}
type EntryControlEventSupportedReport struct {
    *report
    node byte
    Properties1 byte
    DataTypeSupportedBitMask byte
    Properties2 byte
    EventTypeSupportedBitMask byte
    KeyCachedSizesupportedMinimum byte
    KeyCachedSizesupportedMaximum byte
    KeyCachedTimeoutsupportedMinimum byte
    KeyCachedTimeoutsupportedMaximum byte
    data []byte
}

func NewEntryControlEventSupportedReport(data []byte) *EntryControlEventSupportedReport {
    if len(data) < 8 {
        for i := len(data); i < 8; i++ {
            data = append(data, 0x00)
        }
    }

    return &EntryControlEventSupportedReport{
        Properties1: data[0],
        DataTypeSupportedBitMask: data[1],
        Properties2: data[2],
        EventTypeSupportedBitMask: data[3],
        KeyCachedSizesupportedMinimum: data[4],
        KeyCachedSizesupportedMaximum: data[5],
        KeyCachedTimeoutsupportedMinimum: data[6],
        KeyCachedTimeoutsupportedMaximum: data[7],
        data: data,
    }
}

type EntryControlConfigurationSet struct {
    node byte
    KeyCacheSize byte
    KeyCacheTimeout byte
}

func (c *EntryControlConfigurationSet) SetNode(node int) {
    c.node = byte(node)
}

func (c *EntryControlConfigurationSet) Set(KeyCacheSize byte,KeyCacheTimeout byte,) error {
    c.KeyCacheSize = KeyCacheSize
    c.KeyCacheTimeout = KeyCacheTimeout
}

func (c *EntryControlConfigurationSet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(EntryControl),
        0x06,
        KeyCacheSize,
        KeyCacheTimeout,
        0x25,
    }
}
type EntryControlConfigurationGet struct {
    node byte
}

func (c *EntryControlConfigurationGet) SetNode(node int) {
    c.node = byte(node)
}

func (c *EntryControlConfigurationGet) Set() error {
}

func (c *EntryControlConfigurationGet) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(0),
        byte(EntryControl),
        0x07,
        0x25,
    }
}
type EntryControlConfigurationReport struct {
    *report
    node byte
    KeyCacheSize byte
    KeyCacheTimeout byte
    data []byte
}

func NewEntryControlConfigurationReport(data []byte) *EntryControlConfigurationReport {
    if len(data) < 2 {
        for i := len(data); i < 2; i++ {
            data = append(data, 0x00)
        }
    }

    return &EntryControlConfigurationReport{
        KeyCacheSize: data[0],
        KeyCacheTimeout: data[1],
        data: data,
    }
}

package commands
type Initiate struct {
    node byte
    NodeID byte
    StepID byte
}

func (c *Initiate) SetNode(node int) {
    c.node = byte(node)
}

func (c *Initiate) Set(NodeID byte,StepID byte,) error {
    c.NodeID = NodeID
    c.StepID = StepID
}

func (c *Initiate) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(InclusionController),
        0x01,
        NodeID,
        StepID,
        0x25,
    }
}
type Complete struct {
    node byte
    StepID byte
    Status byte
}

func (c *Complete) SetNode(node int) {
    c.node = byte(node)
}

func (c *Complete) Set(StepID byte,Status byte,) error {
    c.StepID = StepID
    c.Status = Status
}

func (c *Complete) Encode() []byte {
    return []byte{
        0x13,
        c.node,
        byte(2),
        byte(InclusionController),
        0x02,
        StepID,
        Status,
        0x25,
    }
}
